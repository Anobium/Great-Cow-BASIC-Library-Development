;Program compiled by Great Cow BASIC (0.98.06 2019-06-12 (Windows 32 bit))
;Need help? See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;check the documentation or email w_cholmondeley at users dot sourceforge dot net.

;********************************************************************************

;Set up the assembler options (Chip type, clock source, other bits and pieces)
 LIST p=18F47K42, r=DEC
#include <P18F47K42.inc>
 CONFIG CP = OFF, LVP = OFF, WRTD = OFF, WDTE = OFF, MVECEN = OFF, MCLRE = EXTMCLR, CLKOUTEN = OFF, RSTOSC = HFINTOSC_1MHZ, FEXTOSC = OFF

;********************************************************************************

;Set aside memory locations for variables
BUFFWIDTH	EQU	13
BUFFWIDTH_H	EQU	14
CHR	EQU	6772
COMMAND	EQU	15
COMPORT	EQU	16
COUNTER	EQU	17
COUNTER_H	EQU	18
DATA	EQU	19
DELAYTEMP	EQU	0
DELAYTEMP2	EQU	1
DUMMY	EQU	20
EPD_BACKGROUND	EQU	21
EPD_BLACK	EQU	22
EPD_BUFFER	EQU	6813
EPD_HEIGHT	EQU	23
EPD_WIDTH	EQU	24
EPD_WIDTH8	EQU	25
GLCDBACKGROUND	EQU	26
GLCDBACKGROUND_H	EQU	27
GLCDCOLOUR	EQU	28
GLCDCOLOUR_H	EQU	29
GLCDDEVICEHEIGHT	EQU	30
GLCDDEVICEHEIGHT_H	EQU	31
GLCDDEVICEWIDTH	EQU	32
GLCDDEVICEWIDTH_H	EQU	33
GLCDFNTDEFAULT	EQU	34
GLCDFNTDEFAULTSIZE	EQU	35
GLCDFONTWIDTH	EQU	36
GLCDFOREGROUND	EQU	37
GLCDFOREGROUND_H	EQU	38
GLCDX	EQU	39
GLCDX_H	EQU	40
GLCDY	EQU	41
GLCDY_H	EQU	42
IND	EQU	43
IND_COL	EQU	45
IND_COL_H	EQU	46
IND_H	EQU	44
IND_RAW	EQU	47
IND_RAW_H	EQU	48
IND_TRANS	EQU	49
IND_TRANS_H	EQU	50
N_COL	EQU	51
N_COL_H	EQU	52
N_PAGE	EQU	53
N_RAW	EQU	54
N_RAW_H	EQU	55
PRINTLEN	EQU	56
REMAINDER	EQU	57
SERDATA	EQU	58
SPICLOCKMODE	EQU	59
SPICURRENTMODE	EQU	60
SPIRXDATA	EQU	61
SPITXDATA	EQU	62
SYSBITVAR0	EQU	63
SYSBYTETEMPA	EQU	5
SYSBYTETEMPB	EQU	9
SYSBYTETEMPX	EQU	0
SYSCHAR	EQU	64
SYSDIVLOOP	EQU	4
SYSDIVMULTA	EQU	7
SYSDIVMULTA_H	EQU	8
SYSDIVMULTB	EQU	11
SYSDIVMULTB_H	EQU	12
SYSDIVMULTX	EQU	2
SYSDIVMULTX_H	EQU	3
SYSPRINTDATAHANDLER	EQU	65
SYSPRINTDATAHANDLER_H	EQU	66
SYSPRINTTEMP	EQU	67
SYSSTRINGA	EQU	7
SYSTEMP1	EQU	68
SYSTEMP1_H	EQU	69
SYSTEMP2	EQU	70
SYSTEMP2_H	EQU	71
SYSWAITTEMPMS	EQU	2
SYSWAITTEMPMS_H	EQU	3
SYSWORDTEMPA	EQU	5
SYSWORDTEMPA_H	EQU	6
SYSWORDTEMPB	EQU	9
SYSWORDTEMPB_H	EQU	10
SYSWORDTEMPX	EQU	0
SYSWORDTEMPX_H	EQU	1
VERBOSE	EQU	72
_GLCDPAGE	EQU	73

;********************************************************************************

;Alias variables
AFSR0	EQU	16361
AFSR0_H	EQU	16362
SYSCHR_0	EQU	6772
SYSCHR_1	EQU	6773

;********************************************************************************

;Vectors
	ORG	0
	goto	BASPROGRAMSTART
	ORG	8
	retfie

;********************************************************************************

;Start of program memory page 0
	ORG	12
BASPROGRAMSTART
;Call initialisation routines
	rcall	INITSYS
	rcall	INITPPS
	rcall	INITUSART
	rcall	INIT_EPD2IN13D

;Start of the main program
;''A demonstration program for Explicit-Paper.
;''--------------------------------------------------------------------------------------------------------------------------------
;''This has been tested using the hardware and software SPI option.
;''********************************************************************************
;Chip Settings.
;#define clock_freq 64
;
;Generated by PIC PPS Tool for Great Cow Basic
;PPS Tool version: 0.0.5.25
;PinManager data: Not available (3)
;Generated for 18f25k42
;
;Template comment at the start of the config file
;
;#define PPSToolPart 18F45k42
;______________
;USART
;#define USART_BAUD_RATE 57600'9600
;#define USART_DELAY     5 ms
;#define USART_BLOCKING
;Set pin USART directions
;Dir portC.7 IN
	bsf	TRISC,7,ACCESS
;Dir portC.6 OUT
	bcf	TRISC,6,ACCESS
;******************************************************************************************************
;ERV what is this?  The following should be used   '#define EPD_EPD2in13D_HardwareSPI     ' remove comment out if you want to use software SPI.
;#define Hardware SPI
;#define SPI_HardwareSPI
;ERV what is this?  This needs to be in the .h within the INIT
;SPIMode ( MasterFast,0)
	movlw	13
	movwf	SPICURRENTMODE,ACCESS
	clrf	SPICLOCKMODE,ACCESS
	rcall	SPIMODE580
;#define SPI_BAUD_RATE_REGISTER 7 '**********||||||****|||****|
;******************************************************************************************************
;Setup the E-Paper
;erv - You need to MIGRATE the GLCD.H I sent you. There are many changes that you need to test against.
;GLCDDeviceHeight = 102
	movlw	102
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth  = 212
	movlw	212
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;#define GLCD_TYPE_EPD2in13D_CHARACTER_MODE_ONLY
;#define GLCD_TYPE_EPD2in13D_LOWMEMORY4_GLCD_MODE
;erv IS GLCD_WIDTH8 A CONSTANT?
;#define GLCD_WIDTH8  GLCD_WIDTH / 8
;Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
;ERV What are these? These need to GLCD_DC ETC = wrong naming convention
;#define EPD_DC     portA.0   ' Data(hight)/ command(low) line
;#define EPD_CS     portC.1   ' Chip select line
;#define EPD_RESET  portD.2   ' Reset line
;#define EPD_DO     portC.5   ' GLCD MOSI connect to MCU SDO
;#define EPD_SCK    portC.3   ' Clock Line
;#define EPD_Busy   portC.0
;ERV What are these? These need to be in the .h within the INIT
;Dir   EPD_DC     OUT
	bcf	TRISA,0,ACCESS
;Dir   EPD_CS     OUT
	bcf	TRISC,1,ACCESS
;Dir   EPD_RESET  OUT
	bcf	TRISD,2,ACCESS
;Dir   EPD_DO     OUT
	bcf	TRISC,5,ACCESS
;Dir   EPD_SCK    OUT
	bcf	TRISC,3,ACCESS
;Dir   EPD_Busy   IN
	bsf	TRISC,0,ACCESS
;#define GLCD_TYPE EPD_EPD2in13D
;#define GLCD_EXTENDEDFONTSET1
;GLCDRotate ( Landscape_rev )     ' optionally you can rotate the screen.
;______________
;******************************************************************************************************
;Main program
;Terminal commands
;#define ESC   chr(27)               'pag 530 manuale GCB
;#define CLS   HSerPrint(ESC+"[2J")
;#define CLS_CoolTerm hserprint CHR(12)
;#define HOME  HSerPrint(ESC+"[H")
;_______________
;CLS_CoolTerm
	movlw	12
	movwf	SYSCHAR,ACCESS
	rcall	FN_CHR
	movlw	low CHR
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high CHR
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT627
;wait 100 ms
	movlw	100
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;Dim ind, counter, ind_raw, ind_col as word
;Dim Data, dummy, Flag, VERBOSE as byte
;Dim x_min, x_max, y_min, y_max as Word
;Dim BuffWidth as Word
;Dim n_page as byte
;Dim MyString, MyString1 as String
MAIN
;______________________________________________________________________
;VERBOSE=0
	clrf	VERBOSE,ACCESS
;ERV NO!!!! In the init
;Reset_EPD2in13D
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;ERV cALL AUTOMATCALLY FROM THE .H
;Init_EPD2in13D
;ERV cALL AUTOMATCALLY FROM THE .H
;Clear_EPD2in13D
;GLCDCLS
;PSET 0, 0, 1
	clrf	GLCDX,ACCESS
	clrf	GLCDX_H,ACCESS
	clrf	GLCDY,ACCESS
	clrf	GLCDY_H,ACCESS
	movlw	1
	movwf	GLCDCOLOUR,ACCESS
	clrf	GLCDCOLOUR_H,ACCESS
	rcall	PSET_EPD2IN13D
;
;
;'    DisplayGrid_EPD2in13D
;HSerGetString MyString
;
;if MyString="g" then
;Grafica
;else if MyString="t" then
;Testo
;else
;BigTesto
;end if
;
;
;Sleep_EPD2in13D
;
;HSerGetString MyString
;if MyString="s" then
;goto main
;end if
;End
;
;sub DisplayGrid_EPD2in13D
;
;SendCommand_EPD2in13D(Data_Trasmission_1)
;wait 2 ms
;for ind_raw=1 to GLCD_HEIGHT
;for ind_col=1 to GLCD_WIDTH
;SendData_EPD2in13D(Foreground)
;next
;next
;wait 10 ms
;SendCommand_EPD2in13D(Data_Trasmission_2)
;wait 2 ms
;counter=0
;ind=GLCD_HEIGHT*GLCD_WIDTH8
;for ind_raw=1 to ind
;counter=counter+1
;if counter>=105 and counter <117  then
;SendData_EPD2in13D(TFT_Black)
;else if counter=117 then
;SendData_EPD2in13D(TFT_Black)           'ogni bit basso
;counter=0
;else
;SendData_EPD2in13D(0xFE)           'solo primo bit basso
;end if
;next
;wait 10 ms
;
;Refresh_EPD2in13D
;
;end sub
;
;sub   DisplayPixels_EPD2in13D( in mode as byte)
;
;if mode = 1 then
;SendCommand_EPD2in13D(Data_Trasmission_1)
;wait 2 ms
;for ind_raw=1 to GLCD_HEIGHT
;for ind_col=1 to GLCD_WIDTH
;SendData_EPD2in13D(GLCDBackground)
;next
;next
;wait 10 ms
;
;SendCommand_EPD2in13D(Data_Trasmission_2)
;wait 2 ms
;end if
;
;ind=BuffWidth
;for ind_raw=1 to ind
;SendData_EPD2in13D(EPD_Buffer(ind_raw))
;next
;wait 10 ms
;
;'    Refresh_EPD2in13D
;
;
;end sub
;
;
;sub   Testo
;
;Flag=0
;Clear_EPD2in13D
;
;GLCD_Open_PageTransaction_EPD2in13D (0, n_Page-1)
;
;Clear_Buffer
;
;Make_Buffer_Text(2,2,"Caso Probabile")
;Make_Buffer_Text(2,12,"perché la rela")
;Make_Buffer_Text(2,22,"zione non era")
;Make_Buffer_Text(2,32,"attendibile.")
;Make_Buffer_Text(2,42,"Comunque la ")
;Make_Buffer_Text(2,52,"nuova versione")
;Make_Buffer_Text(2,62,"darà risultati")
;Make_Buffer_Text(2,72,"migliori?")
;Make_Buffer_Text(2,108,"Seconda Parte")
;Make_Buffer_Text(2,118,"dello schermo")
;Make_Buffer_Text(2,128,"con un buffer")
;Make_Buffer_Text(2,138,"ridotto. Si può")
;Make_Buffer_Text(2,148,"anche disegnare")
;Make_Buffer_Text(2,158,"fig. geometriche")
;
;GLCD_Close_PageTransaction_EPD2in13D
;
;Refresh_EPD2in13D
;
;end sub
;
;sub   BigTesto
;
;Flag=0
;Clear_EPD2in13D
;
;GLCD_Open_PageTransaction_EPD2in13D (0, n_Page-1)
;
;Clear_Buffer
;
;Make_Buffer_BigTest(2,2, " Vela ")
;Make_Buffer_BigTest(2,18," MARE ")
;Make_Buffer_BigTest(2,34," Cielo")
;Make_Buffer_BigTest(2,50," Verde")
;Make_Buffer_BigTest(2,66," Luce ")
;Make_Buffer_BigTest(2,82," BIANCO")
;Make_Buffer_BigTest(2,108,"Nuovo")
;Make_Buffer_BigTest(2,124,"II Parte")
;Make_Buffer_BigTest(2,140,"schermo")
;Make_Buffer_BigTest(2,156,"ridotto ")
;Make_Buffer_BigTest(2,172,"disegna")
;Make_Buffer_BigTest(2,188,"cerchio")
;
;GLCD_Close_PageTransaction_EPD2in13D
;
;Refresh_EPD2in13D
;
;end sub
;sub   Grafica
;
;'   type=1 Filled Box
;'        2 Filled circle
;'        3 Round rectangle
;'        4 Round Ellipse
;'        5 Hyperbole
;'        6 Parabole
;
;Flag=0
;Clear_EPD2in13D
;
;GLCD_Open_PageTransaction_EPD2in13D (0, n_Page-1)
;
;Clear_Buffer
;
;Make_Buffer_Graf( 4, 4,42, 42,0,0,1, GLCDForeground)'Filled Rectangle
;Make_Buffer_Graf( 5, 5,41, 41,0,0,1, GLCDBackground)' 4+2 input
;Make_Buffer_Graf( 6, 6,40, 40,0,0,1, GLCDForeground)'2 inputs dummy
;Make_Buffer_Graf( 7, 7,39, 39,0,0,1, GLCDBackground)
;Make_Buffer_Graf( 8, 8,38, 38,0,0,1, GLCDForeground)
;Make_Buffer_Graf( 9, 9,37, 37,0,0,1, GLCDBackground)
;Make_Buffer_Graf(10,10,36, 36,0,0,1, GLCDForeground)
;Make_Buffer_Graf(11,11,35, 35,0,0,1, GLCDBackground)
;Make_Buffer_Graf(12,12,34, 34,0,0,1, GLCDForeground)
;Make_Buffer_Graf(13,13,33, 33,0,0,1, GLCDBackground)
;Make_Buffer_Graf(14,14,32, 32,0,0,1, GLCDForeground)
;Make_Buffer_Graf(15,15,31, 31,0,0,1, GLCDBackground)
;
;Make_Buffer_Graf(77,25,23,0,0,0,2,GLCDForeground)'Filled Circle
;Make_Buffer_Graf(77,25,19,0,0,0,2,GLCDBackground)'3+2 inputs
;Make_Buffer_Graf(77,25,14,0,0,0,2,GLCDForeground)'3 inputs dummy
;Make_Buffer_Graf(77,25,11,0,0,0,2,GLCDBackground)
;Make_Buffer_Graf(77,25,5 ,0,0,0,2,GLCDForeground)
;Make_Buffer_Graf(77,25,2 ,0,0,0,2,GLCDBackground)
;
;Make_Buffer_Graf(25,60,16,8,0,0,4,GLCDForeground)'Filled Ellipse
;Make_Buffer_Graf(25,60,14,7,0,0,4,GLCDBackground)'4+2 inputs
;Make_Buffer_Graf(25,60,12,6,0,0,4,GLCDForeground)'2 inputs dummy
;Make_Buffer_Graf(25,60,10,5,0,0,4,GLCDBackground)
;Make_Buffer_Graf(25,60,8,4, 0,0,4,GLCDForeground)
;Make_Buffer_Graf(25,60,6,3,0,0, 4,GLCDBackground)
;
;Make_Buffer_Graf(50,50,100,100,0,0,3, GLCDForeground)'Filled rounded
;Make_Buffer_Graf(55,55,95,95,  0,0,3, GLCDBackground)'Rectangles
;Make_Buffer_Graf(60,60,90,90,  0,0,3, GLCDForeground)'4+2 inputs
;Make_Buffer_Graf(65,65,85,85,  0,0,3, GLCDBackground)'2 inputs dummy
;Make_Buffer_Graf(70,70,80,80,  0,0,3, GLCDForeground)
;Make_Buffer_Graf(75,75,75,75,  0,0,3, GLCDBackground)
;Make_Buffer_Graf(80,80,80,80,  0,0,3, GLCDForeground)
;
;Make_Buffer_Graf(25,70,2,102,  46,102,6, GLCDForeground)'Filled Triangle
;Make_Buffer_Graf(25,78,10,98,  38,98, 6, GLCDBackground)'Filled Triangle
;Make_Buffer_Graf(25,86,18,94,  30,94, 6, GLCDForeground)'Filled Triangle
;
;Make_Buffer_Graf( 8, 108,90, 148,0,0,1,GLCDForeground)'filled rectangle
;Make_Buffer_Graf(18,118,80, 136,0,0,1, GLCDBackground)'4+2 inputs
;Make_Buffer_Graf(28,128,70, 126,0,0,1, GLCDForeground)'2 inputs dummy
;
;Make_Buffer_Graf(50,181, 4, 2, 0,0,5, GLCDForeground)'Hyperbole
;Make_Buffer_Graf(50,181, 6, 3, 0,0,5, GLCDBackground)'4+2 inputs
;Make_Buffer_Graf(50,181,10, 5, 0,0,5, GLCDForeground)'2 inputs dummy
;Make_Buffer_Graf(50,181,14, 7, 0,0,5, GLCDBackground)
;Make_Buffer_Graf(50,181,18, 9, 0,0,5, GLCDForeground)
;Make_Buffer_Graf(50,181,22,11, 0,0,5, GLCDBackground)
;Make_Buffer_Graf(50,181,26,13, 0,0,5, GLCDForeground)
;Make_Buffer_Graf(50,181,30,15, 0,0,5, GLCDBackground)
;Make_Buffer_Graf(50,181,34,17, 0,0,5, GLCDForeground)
;
;GLCD_Close_PageTransaction_EPD2in13D
;
;Refresh_EPD2in13D
;
;end sub
;
;sub Make_Buffer_Text(in x0 as Word, in y0 as Word, in string_in as String)
;
;DrawString_EPD2in13D(x0,y0,String_in)   'costruisce il nuovo buffer
;
;end sub
;
;sub Make_Buffer_BigTest(in x0 as Word, in y0 as Word, in string_in as String)
;
;BigPrint_EPD2in13D(x0,y0,String_in)   'costruisce il nuovo buffer
;
;end sub
;
;sub Make_Buffer_Graf(in x_min as Word, in y_min as Word, in x_max as Word, in y_max as Word, in xx3 as word, in yy3 as word, in Type as byte, in LineColor as Word)
;
;Dim x0, y0, a_x, b_y, radius as word
;
;Select Case Type
;case 1
;FilledBox_EPD2in13D(x_min, y_min, x_max, y_max, LineColor)
;case 2
;x0=x_min: y0=y_min: radius=x_max
;FilledCircle(x0, y0, radius, LineColor)  'center and radius
;case 3
;FillRoundRect(x_min, y_min, x_max, y_max, LineColor)
;case 4
;x0=x_min: y0=y_min: a_x=x_max: b_y=y_max
;FilledEllipse(x0, y0, a_x, b_y, LineColor)
;case 5
;x0=x_min: y0=y_min: a_x=x_max
;Hyperbole(x0, y0, a_x, b_y, 1, 1, LineColor)
;case 6
;FilledTriangle(x_min, y_min, x_max, y_max, xx3, yy3, LineColor)
;End Select
;
;end sub
;
;sub Clear_Buffer
;for ind_raw=1 to BuffWidth                 'ripulisce il buffer
;EPD_Buffer(ind_raw)=GLCDBackground
;next
;end sub
	setf	
	movlw	2
	movwf	N_PAGE,ACCESS
	movlw	98
	movwf	BUFFWIDTH,ACCESS
	movlw	5
	movwf	BUFFWIDTH_H,ACCESS
BASPROGRAMEND
	sleep
	bra	BASPROGRAMEND

;********************************************************************************

FN_CHR
;Empty input?
;If SysChar < 0 Then
	movlw	0
	subwf	SYSCHAR,W,ACCESS
	btfsc	STATUS, C,ACCESS
	bra	ENDIF16
;Chr(0) = 0
	banksel	SYSCHR_0
	clrf	SYSCHR_0,BANKED
;Exit Function
	banksel	0
	return
;End If
ENDIF16
;Chr(0) = 1
	movlw	1
	banksel	SYSCHR_0
	movwf	SYSCHR_0,BANKED
;Copy characters
;Chr(1) = SysChar
	movffl	SYSCHAR,SYSCHR_1
	banksel	0
	return

;********************************************************************************

CLS_EPD2IN13D
;SendCommand_EPD2in13D(Data_Trasmission_1)
	movlw	16
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;for ind_raw=1 to EPD_Height
	clrf	IND_RAW,ACCESS
	clrf	IND_RAW_H,ACCESS
	movlw	1
	subwf	EPD_HEIGHT,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoopEnd2
SysForLoop2
	incf	IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	IND_RAW_H,F,ACCESS
;for ind_col=1 to EPD_width
	clrf	IND_COL,ACCESS
	clrf	IND_COL_H,ACCESS
	movlw	1
	subwf	EPD_WIDTH,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoopEnd3
SysForLoop3
	incf	IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	IND_COL_H,F,ACCESS
;SendData_EPD2in13D(EPD_Black)
	movff	EPD_BLACK,DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movff	IND_COL,SysWORDTempA
	movff	IND_COL_H,SysWORDTempA_H
	movff	EPD_WIDTH,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop3
SysForLoopEnd3
;next
	movff	IND_RAW,SysWORDTempA
	movff	IND_RAW_H,SysWORDTempA_H
	movff	EPD_HEIGHT,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop2
SysForLoopEnd2
;wait 10 ms
	movlw	10
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(Data_Trasmission_2)
	movlw	19
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;for ind_raw=1 to EPD_Height
	clrf	IND_RAW,ACCESS
	clrf	IND_RAW_H,ACCESS
	movlw	1
	subwf	EPD_HEIGHT,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoopEnd4
SysForLoop4
	incf	IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	IND_RAW_H,F,ACCESS
;for ind_col=1 to EPD_width
	clrf	IND_COL,ACCESS
	clrf	IND_COL_H,ACCESS
	movlw	1
	subwf	EPD_WIDTH,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoopEnd5
SysForLoop5
	incf	IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	IND_COL_H,F,ACCESS
;SendData_EPD2in13D(EPD_Black)
	movff	EPD_BLACK,DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movff	IND_COL,SysWORDTempA
	movff	IND_COL_H,SysWORDTempA_H
	movff	EPD_WIDTH,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop5
SysForLoopEnd5
;next
	movff	IND_RAW,SysWORDTempA
	movff	IND_RAW_H,SysWORDTempA_H
	movff	EPD_HEIGHT,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop4
SysForLoopEnd4
;wait 10 ms
	movlw	10
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	bra	Delay_MS

;********************************************************************************

Delay_MS
	incf	SysWaitTempMS_H, F,ACCESS
DMS_START
	movlw	129
	movwf	DELAYTEMP2,ACCESS
DMS_OUTER
	movlw	40
	movwf	DELAYTEMP,ACCESS
DMS_INNER
	decfsz	DELAYTEMP, F,ACCESS
	bra	DMS_INNER
	decfsz	DELAYTEMP2, F,ACCESS
	bra	DMS_OUTER
	decfsz	SysWaitTempMS, F,ACCESS
	bra	DMS_START
	decfsz	SysWaitTempMS_H, F,ACCESS
	bra	DMS_START
	return

;********************************************************************************

;Overloaded signature: STRING:byte:
HSERPRINT627
;PrintLen = PrintData(0)
	movffl	SysPRINTDATAHandler,AFSR0
	movffl	SysPRINTDATAHandler_H,AFSR0_H
	movffl	INDF0,PRINTLEN
;If PrintLen <> 0 then
	movf	PRINTLEN,F,ACCESS
	btfsc	STATUS, Z,ACCESS
	bra	ENDIF17
;Write Data
;for SysPrintTemp = 1 to PrintLen
	clrf	SYSPRINTTEMP,ACCESS
	movlw	1
	subwf	PRINTLEN,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoopEnd1
SysForLoop1
	incf	SYSPRINTTEMP,F,ACCESS
;HSerSend(PrintData(SysPrintTemp),comport )
	movf	SYSPRINTTEMP,W,ACCESS
	addwf	SysPRINTDATAHandler,W,ACCESS
	movwf	AFSR0,ACCESS
	movlw	0
	addwfc	SysPRINTDATAHandler_H,W,ACCESS
	movwf	AFSR0_H,ACCESS
	movffl	INDF0,SERDATA
	rcall	HSERSEND617
;next
	movf	PRINTLEN,W,ACCESS
	subwf	SYSPRINTTEMP,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop1
SysForLoopEnd1
;End If
ENDIF17
;CR
	return

;********************************************************************************

;Overloaded signature: BYTE:byte:
HSERSEND617
;Registers/Bits determined by #samevar at top of library
;if comport = 1 Then
	decf	COMPORT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF33
;USART_BLOCKING and NOT USART_TX_BLOCKING
;Wait While TXIF = Off
SysWaitLoop2
	banksel	PIR3
	btfss	PIR3,U1TXIF,BANKED
	bra	SysWaitLoop2
;Write the data byte to the USART.
;Sets register to value of SerData - where register could be TXREG or TXREG1 or U1TXB set via the #samevar
;TXREG = SerData
	movffl	SERDATA,U1TXB
;Add USART_DELAY after the byte is sent by the USART module
;Wait until TRMT = 1
SysWaitLoop3
	banksel	U1ERRIR
	btfss	U1ERRIR,TXMTIF,BANKED
	bra	SysWaitLoop3
;Wait USART_DELAY
	movlw	5
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	banksel	0
	rcall	Delay_MS
;exit now to exit asap, if you have more than one comport in use there is no point in processing
;exit sub
	return
;end if
ENDIF33
	return

;********************************************************************************

HWSPITRANSFER
;One byte transfer count
;SPI1TCNTL = 1
	movlw	1
	banksel	SPI1TCNTL
	movwf	SPI1TCNTL,BANKED
;SPI1TXB = SPITxData
	movffl	SPITXDATA,SPI1TXB
;wait while SPI1RXIF = SPI_RX_IN_PROGRESS
SysWaitLoop1
	banksel	PIR2
	btfss	PIR2,SPI1RXIF,BANKED
	bra	SysWaitLoop1
;SPIRxData = SPI1RXB
	movffl	SPI1RXB,SPIRXDATA
	banksel	0
	return

;********************************************************************************

INITPPS
;This has been added to turn off PPS SPI when in SPI software mode
;Module: UART1  (0x.... è in ESADECIMALE)
;U1RXPPS = 0x0017        'RC7 > RX1
	movlw	23
	banksel	U1RXPPS
	movwf	U1RXPPS,BANKED
;RC6PPS  = 0x0013        'TX1 > RC6
	movlw	19
	movwf	RC6PPS,BANKED
;Module: SPI1
;SPI1SDIPPS = 0x0014     'RC4 > SDI1
	movlw	20
	movwf	SPI1SDIPPS,BANKED
;RC5PPS = 0x001F         'SDO1 > RC5
	movlw	31
	movwf	RC5PPS,BANKED
;RC3PPS = 0x001E         'SCK1 > RC3
	movlw	30
	movwf	RC3PPS,BANKED
;SPI1SCKPPS = 0x0013     'RC3 > SCK1 (bi-directional)
	movlw	19
	movwf	SPI1SCKPPS,BANKED
	banksel	0
	return

;********************************************************************************

INITSYS
;Set up internal oscillator
;Handle OSCCON1 register for parts that have this register
;asm showdebug OSCCON type is 100 'This is the routine to support OSCCON1 config addresss
;osccon type is 100
;OSCCON1 = 0x60 ' NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
	movlw	96
	banksel	OSCCON1
	movwf	OSCCON1,BANKED
;OSCCON3 = 0x00 ' CSWHOLD may proceed; SOSCPWR Low power
	clrf	OSCCON3,BANKED
;OSCEN = 0x00   ' MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
	clrf	OSCEN,BANKED
;OSCTUNE = 0x00 ' HFTUN 0
	clrf	OSCTUNE,BANKED
;The MCU is a ChipFamily16
;Section support many MCUs, 18FxxK40, 18FxxK42 etc etc all have NDIV3 bit
;asm showdebug OSCCON type is 101 ' ChipFamily16 and NDIV3 bit
;osccon type is 101
;Clear NDIV3:0
;NDIV3 = 0
	bcf	OSCCON1,NDIV3,BANKED
;NDIV2 = 0
	bcf	OSCCON1,NDIV2,BANKED
;NDIV1 = 0
	bcf	OSCCON1,NDIV1,BANKED
;NDIV0 = 0
	bcf	OSCCON1,NDIV0,BANKED
;OSCFRQ = 0b00001000  '64mhz
	movlw	8
	movwf	OSCFRQ,BANKED
;Clear BSR on ChipFamily16 MCUs
;BSR = 0
	clrf	BSR,ACCESS
;Clear TBLPTRU on MCUs with this bit as this must be zero
;TBLPTRU = 0
	clrf	TBLPTRU,ACCESS
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	banksel	ADCON0
	bcf	ADCON0,ADFM0,BANKED
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	bcf	ADCON0,ADON,BANKED
;Commence clearing any ANSEL variants in the part
;ANSELA = 0
	banksel	ANSELA
	clrf	ANSELA,BANKED
;ANSELB = 0
	clrf	ANSELB,BANKED
;ANSELC = 0
	clrf	ANSELC,BANKED
;ANSELD = 0
	clrf	ANSELD,BANKED
;ANSELE = 0
	clrf	ANSELE,BANKED
;End clearing any ANSEL variants in the part
;Set comparator register bits for many MCUs with register CM2CON0
;C2EN = 0
	banksel	CM2CON0
	bcf	CM2CON0,C2EN,BANKED
;C1EN = 0
	bcf	CM1CON0,C1EN,BANKED
;Turn off all ports
;PORTA = 0
	clrf	PORTA,ACCESS
;PORTB = 0
	clrf	PORTB,ACCESS
;PORTC = 0
	clrf	PORTC,ACCESS
;PORTD = 0
	clrf	PORTD,ACCESS
;PORTE = 0
	clrf	PORTE,ACCESS
	banksel	0
	return

;********************************************************************************

INITUSART
;Set the default value for comport
;comport = 1
	movlw	1
	movwf	COMPORT,ACCESS
;Set baud rate for for 18fxxK42/K83 series UART
;U1BRGH=SPBRGH_TEMP
	movlw	1
	banksel	U1BRGH
	movwf	U1BRGH,BANKED
;U1BRGL=SPBRGL_TEMP
	movlw	20
	movwf	U1BRGL,BANKED
;U1BRGS = BRGS1_SCRIPT
	bsf	U1CON0,U1BRGS,BANKED
;U1TXEN=1   'Enable TX1
	bsf	U1CON0,U1TXEN,BANKED
;U1RXEN=1   'Enable RX1
	bsf	U1CON0,U1RXEN,BANKED
;ON_U1CON1=1 'Enable USART1
	bsf	U1CON1,ON_U1CON1,BANKED
	banksel	0
	return

;********************************************************************************

INIT_EPD2IN13D
;SET EPD_reset ON
	bsf	LATD,2,ACCESS
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SET EPD_Reset OFF
	bcf	LATD,2,ACCESS
;wait 20 ms
	movlw	20
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SET EPD_reset ON
	bsf	LATD,2,ACCESS
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(Booster_Soft_start)
	movlw	6
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x17)
	movlw	23
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x17)
	movlw	23
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x17)
	movlw	23
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(Power_Setting)
	movlw	1
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x03)
	movlw	3
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x00)
	clrf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x2B)
	movlw	43
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x2B)
	movlw	43
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x03)
	movlw	3
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(Power_ON)
	movlw	4
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;Do While EPD_Busy=OFF
SysDoLoop_S1
	btfsc	PORTC,0,ACCESS
	bra	SysDoLoop_E1
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;Loop
	bra	SysDoLoop_S1
SysDoLoop_E1
;SendCommand_EPD2in13D(Panel_Setting)
	clrf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0xBF)
	movlw	191
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(PLL_Control)
	movlw	48
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x3C)
	movlw	60
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(Resolution_Setting)
	movlw	97
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x68)
	movlw	104
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x00)
	clrf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0xD4)
	movlw	212
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(VCM_DC_Setting)
	movlw	130
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x12)
	movlw	18
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;LoadLUTS_EPD2in13D
	rcall	LOADLUTS_EPD2IN13D
;Colours
;GLCDForeground = TFT_WHITE
	setf	GLCDFOREGROUND,ACCESS
	setf	GLCDFOREGROUND_H,ACCESS
;Default Colours
;GLCDBackground = TFT_BLACK
	clrf	GLCDBACKGROUND,ACCESS
	clrf	GLCDBACKGROUND_H,ACCESS
;Variables required for device
;GLCDDeviceWidth = GLCD_WIDTH - 1
	movlw	211
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	101
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDFontWidth = 6
	movlw	6
	movwf	GLCDFONTWIDTH,ACCESS
;GLCDfntDefault = 0
	clrf	GLCDFNTDEFAULT,ACCESS
;GLCDfntDefaultsize = 1
	movlw	1
	movwf	GLCDFNTDEFAULTSIZE,ACCESS
;ERV this may be needed
;GLCDRotate ( PORTRAIT )
;Clear screen
;GLCDCLS
	bra	CLS_EPD2IN13D

;********************************************************************************

LOADLUTS_EPD2IN13D
;SendCommand_EPD2in13D(VCM_DC_Setting)
	movlw	130
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x00)
	clrf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(Vcom_and_data_interval_setting)
	movlw	80
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x97)
	movlw	151
	movwf	DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(0x20) 'VCOM LUT
	movlw	32
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for counter=1 to 44
	clrf	COUNTER,ACCESS
	clrf	COUNTER_H,ACCESS
SysForLoop6
	incf	COUNTER,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	COUNTER_H,F,ACCESS
;ReadTable Lut_Vcom, Counter, Data
	movff	COUNTER,SYSSTRINGA
	rcall	LUT_VCOM
	movwf	DATA,ACCESS
;SendData_EPD2in13D(Data)
	rcall	SENDDATA_EPD2IN13D
;next
	movff	COUNTER,SysWORDTempA
	movff	COUNTER_H,SysWORDTempA_H
	movlw	44
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop6
SysForLoopEnd6
;SendCommand_EPD2in13D(0x21) 'WW LUT
	movlw	33
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for counter=1 to 42
	clrf	COUNTER,ACCESS
	clrf	COUNTER_H,ACCESS
SysForLoop7
	incf	COUNTER,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	COUNTER_H,F,ACCESS
;ReadTable Lut_WW, Counter, Data
	movff	COUNTER,SYSSTRINGA
	rcall	LUT_WW
	movwf	DATA,ACCESS
;SendData_EPD2in13D(Data)
	rcall	SENDDATA_EPD2IN13D
;next
	movff	COUNTER,SysWORDTempA
	movff	COUNTER_H,SysWORDTempA_H
	movlw	42
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop7
SysForLoopEnd7
;SendCommand_EPD2in13D(0x22) 'BW LUT
	movlw	34
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for counter=1 to 42
	clrf	COUNTER,ACCESS
	clrf	COUNTER_H,ACCESS
SysForLoop8
	incf	COUNTER,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	COUNTER_H,F,ACCESS
;ReadTable Lut_BW, Counter, Data
	movff	COUNTER,SYSSTRINGA
	rcall	LUT_BW
	movwf	DATA,ACCESS
;SendData_EPD2in13D(Data)
	rcall	SENDDATA_EPD2IN13D
;next
	movff	COUNTER,SysWORDTempA
	movff	COUNTER_H,SysWORDTempA_H
	movlw	42
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop8
SysForLoopEnd8
;SendCommand_EPD2in13D(0x23) 'WB LUT
	movlw	35
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for counter=1 to 42
	clrf	COUNTER,ACCESS
	clrf	COUNTER_H,ACCESS
SysForLoop9
	incf	COUNTER,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	COUNTER_H,F,ACCESS
;ReadTable Lut_WB, Counter, Data
	movff	COUNTER,SYSSTRINGA
	rcall	LUT_WB
	movwf	DATA,ACCESS
;SendData_EPD2in13D(Data)
	rcall	SENDDATA_EPD2IN13D
;next
	movff	COUNTER,SysWORDTempA
	movff	COUNTER_H,SysWORDTempA_H
	movlw	42
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop9
SysForLoopEnd9
;SendCommand_EPD2in13D(0x24) 'BB LUT
	movlw	36
	movwf	COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for counter=1 to 42
	clrf	COUNTER,ACCESS
	clrf	COUNTER_H,ACCESS
SysForLoop10
	incf	COUNTER,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	COUNTER_H,F,ACCESS
;ReadTable Lut_BB, Counter, Data
	movff	COUNTER,SYSSTRINGA
	rcall	LUT_BB
	movwf	DATA,ACCESS
;SendData_EPD2in13D(Data)
	rcall	SENDDATA_EPD2IN13D
;next
	movff	COUNTER,SysWORDTempA
	movff	COUNTER_H,SysWORDTempA_H
	movlw	42
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop10
SysForLoopEnd10
	return

;********************************************************************************

LUT_BB
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_BB
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_BB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_BB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_BB
	db	42,128,8,0,0,0,2,144,40,40,0,0,1,128,20,0,0,0,1,80,18,18,0,0,1

;********************************************************************************

LUT_BW
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_BW
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_BW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_BW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_BW
	db	42,64,23,0,0,0,2,144,15,15,0,0,3,64,10,1,0,0,1,160,14,14,0,0,2

;********************************************************************************

LUT_VCOM
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_VCOM
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_VCOM
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_VCOM
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_VCOM
	db	44,0,8,0,0,0,2,96,40,40,0,0,1,0,20,0,0,0,1,0,18,18,0,0,1

;********************************************************************************

LUT_WB
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_WB
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_WB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_WB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_WB
	db	42,128,8,0,0,0,2,144,40,40,0,0,1,128,20,0,0,0,1,80,18,18,0,0,1

;********************************************************************************

LUT_WW
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_WW
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_WW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_WW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_WW
	db	42,64,8,0,0,0,2,144,40,40,0,0,1,64,20,0,0,0,1,160,18,18,0,0,1

;********************************************************************************

PSET_EPD2IN13D
;Dim n_col, n_raw, ind_Trans as word
;Dim remainder as byte
;Dim value as bit
;if GLCDColour <> EPD_Background then
	movff	GLCDCOLOUR,SysWORDTempA
	movff	GLCDCOLOUR_H,SysWORDTempA_H
	movff	EPD_BACKGROUND,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompEqual16
	comf	SysByteTempX,F,ACCESS
	btfss	SysByteTempX,0,ACCESS
	bra	ELSE1_1
;value=1
	bsf	SYSBITVAR0,0,ACCESS
;else
	bra	ENDIF1
ELSE1_1
;value=0
	bcf	SYSBITVAR0,0,ACCESS
;end if
ENDIF1
;n_col=(GLCDX+1)/8       'numero dela colonna su cui è il byte coinvolto
	movlw	1
	addwf	GLCDX,W,ACCESS
	movwf	SysTemp1,ACCESS
	movlw	0
	addwfc	GLCDX_H,W,ACCESS
	movwf	SysTemp1_H,ACCESS
	movff	SysTemp1,SysWORDTempA
	movff	SysTemp1_H,SysWORDTempA_H
	movlw	8
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysDivSub16
	movff	SysWORDTempA,N_COL
	movff	SysWORDTempA_H,N_COL_H
;remainder=(GLCDX+1)%8
	movlw	1
	addwf	GLCDX,W,ACCESS
	movwf	SysTemp1,ACCESS
	movlw	0
	addwfc	GLCDX_H,W,ACCESS
	movwf	SysTemp1_H,ACCESS
	movff	SysTemp1,SysWORDTempA
	movff	SysTemp1_H,SysWORDTempA_H
	movlw	8
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysDivSub16
	movff	SysWORDTempX,REMAINDER
;n_raw=GLCDY*EPD_Width8  'numero di riga del byte coinvolto
	movff	GLCDY,SysWORDTempA
	movff	GLCDY_H,SysWORDTempA_H
	movff	EPD_WIDTH8,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysMultSub16
	movff	SysWORDTempX,N_RAW
	movff	SysWORDTempX_H,N_RAW_H
;if remainder=0 then
	movf	REMAINDER,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ELSE2_1
;ind=n_raw+n_col
	movf	N_COL,W,ACCESS
	addwf	N_RAW,W,ACCESS
	movwf	IND,ACCESS
	movf	N_COL_H,W,ACCESS
	addwfc	N_RAW_H,W,ACCESS
	movwf	IND_H,ACCESS
;else
	bra	ENDIF2
ELSE2_1
;ind=n_raw+n_col+1     'numero del byte coinvolto (a partire dal primo di ind=1)
	movf	N_COL,W,ACCESS
	addwf	N_RAW,W,ACCESS
	movwf	SysTemp1,ACCESS
	movf	N_COL_H,W,ACCESS
	addwfc	N_RAW_H,W,ACCESS
	movwf	SysTemp1_H,ACCESS
	movlw	1
	addwf	SysTemp1,W,ACCESS
	movwf	IND,ACCESS
	movlw	0
	addwfc	SysTemp1_H,W,ACCESS
	movwf	IND_H,ACCESS
;end if
ENDIF2
;Ind_Trans=Ind-_GLCDPage*BuffWidth
	movff	_GLCDPAGE,SysWORDTempA
	clrf	SysWORDTempA_H,ACCESS
	movff	BUFFWIDTH,SysWORDTempB
	movff	BUFFWIDTH_H,SysWORDTempB_H
	rcall	SysMultSub16
	movf	SysWORDTempX,W,ACCESS
	subwf	IND,W,ACCESS
	movwf	IND_TRANS,ACCESS
	movf	SysWORDTempX_H,W,ACCESS
	subwfb	IND_H,W,ACCESS
	movwf	IND_TRANS_H,ACCESS
;if ind_Trans>BuffWidth then
	movff	IND_TRANS,SysWORDTempB
	movff	IND_TRANS_H,SysWORDTempB_H
	movff	BUFFWIDTH,SysWORDTempA
	movff	BUFFWIDTH_H,SysWORDTempA_H
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
;EXIT SUB
	return
;end if
;Data=EPD_Buffer(ind_Trans)
	lfsr	0,EPD_BUFFER
	movf	IND_TRANS,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	IND_TRANS_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	INDF0,DATA
;Select Case remainder
;case 0
SysSelect1Case1
	movf	REMAINDER,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case2
;data.0=value
	bcf	DATA,0,ACCESS
	btfsc	SYSBITVAR0,0,ACCESS
	bsf	DATA,0,ACCESS
;case 1
	bra	SysSelectEnd1
SysSelect1Case2
	decf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case3
;data.7=value
	bcf	DATA,7,ACCESS
	btfsc	SYSBITVAR0,0,ACCESS
	bsf	DATA,7,ACCESS
;case 2
	bra	SysSelectEnd1
SysSelect1Case3
	movlw	2
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case4
;data.6=value
	bcf	DATA,6,ACCESS
	btfsc	SYSBITVAR0,0,ACCESS
	bsf	DATA,6,ACCESS
;case 3
	bra	SysSelectEnd1
SysSelect1Case4
	movlw	3
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case5
;data.5=value
	bcf	DATA,5,ACCESS
	btfsc	SYSBITVAR0,0,ACCESS
	bsf	DATA,5,ACCESS
;case 4
	bra	SysSelectEnd1
SysSelect1Case5
	movlw	4
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case6
;data.4=value
	bcf	DATA,4,ACCESS
	btfsc	SYSBITVAR0,0,ACCESS
	bsf	DATA,4,ACCESS
;case 5
	bra	SysSelectEnd1
SysSelect1Case6
	movlw	5
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case7
;data.3=value
	bcf	DATA,3,ACCESS
	btfsc	SYSBITVAR0,0,ACCESS
	bsf	DATA,3,ACCESS
;case 6
	bra	SysSelectEnd1
SysSelect1Case7
	movlw	6
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case8
;data.2=value
	bcf	DATA,2,ACCESS
	btfsc	SYSBITVAR0,0,ACCESS
	bsf	DATA,2,ACCESS
;case 7
	bra	SysSelectEnd1
SysSelect1Case8
	movlw	7
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelectEnd1
;data.1=value
	bcf	DATA,1,ACCESS
	btfsc	SYSBITVAR0,0,ACCESS
	bsf	DATA,1,ACCESS
;End Select
SysSelectEnd1
;EPD_Buffer(ind_Trans)=Data
	lfsr	0,EPD_BUFFER
	movf	IND_TRANS,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	IND_TRANS_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	DATA,INDF0
	return

;********************************************************************************

SENDCOMMAND_EPD2IN13D
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC OFF
	bcf	LATA,0,ACCESS
;SPITransfer Command, Dummy
	movff	COMMAND,SPITXDATA
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,DUMMY
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
	return

;********************************************************************************

SENDDATA_EPD2IN13D
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;SPITransfer Data, Dummy
	movff	DATA,SPITXDATA
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,DUMMY
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
	return

;********************************************************************************

;Overloaded signature: BYTE:BYTE:
SPIMODE580
;Supports K mode SPI using the specific SPI module
;Turn off SPI
;(Prevents any weird glitches during setup)
;SPI1CON0_EN = 0
	banksel	SPI1CON0
	bcf	SPI1CON0,SPI1CON0_EN,BANKED
;Set clock pulse settings to middle
;SPI1CON1.SMP = 0
	bcf	SPI1CON1,SMP,BANKED
;Data write on rising (idle > active) clock (CPHA = 1)
;SPI1CON1.CKE = 0
	bcf	SPI1CON1,CKE,BANKED
;Clock idle low (CPOL = 0)
;SPI1CON1.CKP = 0
	bcf	SPI1CON1,CKP,BANKED
;If SPIClockMode.0 = Off Then
	btfss	SPICLOCKMODE,0,ACCESS
;SPI1CON1.CKE = 1
	bsf	SPI1CON1,CKE,BANKED
;End If
;If SPIClockMode.1 = On Then
	btfsc	SPICLOCKMODE,1,ACCESS
;SPI1CON1.CKP = 1
	bsf	SPI1CON1,CKP,BANKED
;End If
;SPI1CON1 = 0x40
	movlw	64
	movwf	SPI1CON1,BANKED
;Transfer
;SPI1CON2 = SPI1CON2 or 3
	movlw	3
	iorwf	SPI1CON2,F,BANKED
;Select mode and clock
;SPI1CLK = SSP1_FOSC
	clrf	SPI1CLK,BANKED
;Select Case SPICurrentMode
;Case MasterFast or MasterUltraFast
SysSelect2Case1
	movff	SPICURRENTMODE,SysBYTETempA
	movlw	13
	movwf	SysBYTETempB,ACCESS
	banksel	0
	rcall	SysCompEqual
	movlw	14
	iorwf	SysByteTempX,W,ACCESS
	movwf	SysTemp1,ACCESS
	btfss	SysTemp1,0,ACCESS
	bra	SysSelect2Case2
;asm showdebug Script value is calculated as SPIBAUDRATE_SCRIPT
;script sysbitvar0.0 is calculated as 3
;SPI1BAUD = SPIBAUDRATE_SCRIPT
	movlw	3
	banksel	SPI1BAUD
	movwf	SPI1BAUD,BANKED
;SPI1CON0.MST = 1
	bsf	SPI1CON0,MST,BANKED
;Case Master
	bra	SysSelectEnd2
SysSelect2Case2
	movlw	12
	subwf	SPICURRENTMODE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case3
;asm showdebug Script value is calculated as SPIBAUDRATE_SCRIPT_MASTER
;script sysbitvar0.0 is calculated as 9
;SPI1BAUD = SPIBAUDRATE_SCRIPT_MASTER
	movlw	9
	banksel	SPI1BAUD
	movwf	SPI1BAUD,BANKED
;SPI1CON0.MST = 1
	bsf	SPI1CON0,MST,BANKED
;Case MasterSlow
	bra	SysSelectEnd2
SysSelect2Case3
	movlw	11
	subwf	SPICURRENTMODE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case4
;asm showdebug Script value is calculated as SPIBAUDRATE_SCRIPT_MASTERSLOW
;script sysbitvar0.0 is calculated as 33
;SPI1BAUD = SPIBAUDRATE_SCRIPT_MASTERSLOW
	movlw	33
	banksel	SPI1BAUD
	movwf	SPI1BAUD,BANKED
;SPI1CON0.MST = 1
	bsf	SPI1CON0,MST,BANKED
;Case Slave
	bra	SysSelectEnd2
SysSelect2Case4
	movf	SPICURRENTMODE,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case5
;SPI1CON0.MST = 0
	banksel	SPI1CON0
	bcf	SPI1CON0,MST,BANKED
;Case SlaveSS
	bra	SysSelectEnd2
SysSelect2Case5
	decf	SPICURRENTMODE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelectEnd2
;SPI1CON0.MST = 0
	banksel	SPI1CON0
	bcf	SPI1CON0,MST,BANKED
;End Select
SysSelectEnd2
;override the script calculation
;SPI1BAUD = SPI_BAUD_RATE_REGISTER
	movlw	7
	banksel	SPI1BAUD
	movwf	SPI1BAUD,BANKED
;Enable SPI
;SPI1CON0.EN = 1
	bsf	SPI1CON0,EN,BANKED
	banksel	0
	return

;********************************************************************************

SYSCOMPEQUAL
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;setf SysByteTempX
	setf	SYSBYTETEMPX,ACCESS
;movf SysByteTempB, W
	movf	SYSBYTETEMPB, W,ACCESS
;cpfseq SysByteTempA
	cpfseq	SYSBYTETEMPA,ACCESS
;clrf SysByteTempX
	clrf	SYSBYTETEMPX,ACCESS
	return

;********************************************************************************

SYSCOMPEQUAL16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX,ACCESS
;Test low, exit if false
;movf SysWordTempB, W
	movf	SYSWORDTEMPB, W,ACCESS
;cpfseq SysWordTempA
	cpfseq	SYSWORDTEMPA,ACCESS
;return
	return
;Test high, exit if false
;movf SysWordTempB_H, W
	movf	SYSWORDTEMPB_H, W,ACCESS
;cpfseq SysWordTempA_H
	cpfseq	SYSWORDTEMPA_H,ACCESS
;return
	return
;setf SysByteTempX
	setf	SYSBYTETEMPX,ACCESS
	return

;********************************************************************************

SYSCOMPLESSTHAN16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX,ACCESS
;Test High, exit if more
;movf SysWordTempA_H,W
	movf	SYSWORDTEMPA_H,W,ACCESS
;subwf SysWordTempB_H,W
	subwf	SYSWORDTEMPB_H,W,ACCESS
;btfss STATUS,C
	btfss	STATUS,C,ACCESS
;return
	return
;Test high, exit true if less
;movf SysWordTempB_H,W
	movf	SYSWORDTEMPB_H,W,ACCESS
;subwf SysWordTempA_H,W
	subwf	SYSWORDTEMPA_H,W,ACCESS
;bnc SCLT16True
	bnc	SCLT16TRUE
;Test Low, exit if more or equal
;movf SysWordTempB,W
	movf	SYSWORDTEMPB,W,ACCESS
;subwf SysWordTempA,W
	subwf	SYSWORDTEMPA,W,ACCESS
;btfsc STATUS,C
	btfsc	STATUS,C,ACCESS
;return
	return
SCLT16TRUE
;comf SysByteTempX,F
	comf	SYSBYTETEMPX,F,ACCESS
	return

;********************************************************************************

SYSDIVSUB16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;dim SysDivMultA as word
;dim SysDivMultB as word
;dim SysDivMultX as word
;SysDivMultA = SysWordTempA
	movff	SYSWORDTEMPA,SYSDIVMULTA
	movff	SYSWORDTEMPA_H,SYSDIVMULTA_H
;SysDivMultB = SysWordTempB
	movff	SYSWORDTEMPB,SYSDIVMULTB
	movff	SYSWORDTEMPB_H,SYSDIVMULTB_H
;SysDivMultX = 0
	clrf	SYSDIVMULTX,ACCESS
	clrf	SYSDIVMULTX_H,ACCESS
;Avoid division by zero
;if SysDivMultB = 0 then
	movff	SYSDIVMULTB,SysWORDTempA
	movff	SYSDIVMULTB_H,SysWORDTempA_H
	clrf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompEqual16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF12
;SysWordTempA = 0
	clrf	SYSWORDTEMPA,ACCESS
	clrf	SYSWORDTEMPA_H,ACCESS
;exit sub
	return
;end if
ENDIF12
;Main calc routine
;SysDivLoop = 16
	movlw	16
	movwf	SYSDIVLOOP,ACCESS
SYSDIV16START
;set C off
	bcf	STATUS,C,ACCESS
;Rotate SysDivMultA Left
	rlcf	SYSDIVMULTA,F,ACCESS
	rlcf	SYSDIVMULTA_H,F,ACCESS
;Rotate SysDivMultX Left
	rlcf	SYSDIVMULTX,F,ACCESS
	rlcf	SYSDIVMULTX_H,F,ACCESS
;SysDivMultX = SysDivMultX - SysDivMultB
	movf	SYSDIVMULTB,W,ACCESS
	subwf	SYSDIVMULTX,F,ACCESS
	movf	SYSDIVMULTB_H,W,ACCESS
	subwfb	SYSDIVMULTX_H,F,ACCESS
;Set SysDivMultA.0 On
	bsf	SYSDIVMULTA,0,ACCESS
;If C Off Then
	btfsc	STATUS,C,ACCESS
	bra	ENDIF13
;Set SysDivMultA.0 Off
	bcf	SYSDIVMULTA,0,ACCESS
;SysDivMultX = SysDivMultX + SysDivMultB
	movf	SYSDIVMULTB,W,ACCESS
	addwf	SYSDIVMULTX,F,ACCESS
	movf	SYSDIVMULTB_H,W,ACCESS
	addwfc	SYSDIVMULTX_H,F,ACCESS
;End If
ENDIF13
;decfsz SysDivLoop, F
	decfsz	SYSDIVLOOP, F,ACCESS
;goto SysDiv16Start
	bra	SYSDIV16START
;SysWordTempA = SysDivMultA
	movff	SYSDIVMULTA,SYSWORDTEMPA
	movff	SYSDIVMULTA_H,SYSWORDTEMPA_H
;SysWordTempX = SysDivMultX
	movff	SYSDIVMULTX,SYSWORDTEMPX
	movff	SYSDIVMULTX_H,SYSWORDTEMPX_H
	return

;********************************************************************************

SYSMULTSUB16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;X = LowA * LowB
;movf SysWordTempA, W
	movf	SYSWORDTEMPA, W,ACCESS
;mulwf SysWordTempB
	mulwf	SYSWORDTEMPB,ACCESS
;movff PRODL, SysWordTempX
	movffl	PRODL,SYSWORDTEMPX
;movff PRODH, SysWordTempX_H
	movffl	PRODH,SYSWORDTEMPX_H
;HighX += LowA * HighB
;movf SysWordTempA, W
	movf	SYSWORDTEMPA, W,ACCESS
;mulwf SysWordTempB_H
	mulwf	SYSWORDTEMPB_H,ACCESS
;movf PRODL, W
	movf	PRODL, W,ACCESS
;addwf SysWordTempX_H, F
	addwf	SYSWORDTEMPX_H, F,ACCESS
;HighX += HighA * LowB
;movf SysWordTempA_H, W
	movf	SYSWORDTEMPA_H, W,ACCESS
;mulwf SysWordTempB
	mulwf	SYSWORDTEMPB,ACCESS
;movf PRODL, W
	movf	PRODL, W,ACCESS
;addwf SysWordTempX_H, F
	addwf	SYSWORDTEMPX_H, F,ACCESS
;PRODL = HighA * HighB
;movf SysWordTempA_H, F
	movf	SYSWORDTEMPA_H, F,ACCESS
;mulwf SysWordTempB_H
	mulwf	SYSWORDTEMPB_H,ACCESS
	return

;********************************************************************************


 END
