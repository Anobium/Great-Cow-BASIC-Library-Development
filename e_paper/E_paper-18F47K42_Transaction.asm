;Program compiled by Great Cow BASIC (0.98.<<>> 2019-11-14 (Windows 32 bit))
;Need help? See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;check the documentation or email w_cholmondeley at users dot sourceforge dot net.

;********************************************************************************

;Set up the assembler options (Chip type, clock source, other bits and pieces)
 LIST p=18F47K42, r=DEC
#include <P18F47K42.inc>
 CONFIG CP = OFF, LVP = OFF, WRTD = OFF, WDTE = OFF, MVECEN = OFF, MCLRE = EXTMCLR, CLKOUTEN = OFF, RSTOSC = HFINTOSC_1MHZ, FEXTOSC = OFF

;********************************************************************************

;Set aside memory locations for variables
DATAVAR	EQU	13
DELAYTEMP	EQU	0
DELAYTEMP2	EQU	1
DRAWLINE	EQU	14
DRAWLINE_H	EQU	15
EPD2IN13DADDRESSTYPE	EQU	16
EPD2IN13D_COMMAND	EQU	17
EPD2IN13D_DATA	EQU	18
EPD_BUFFER	EQU	8085
EPD_COUNTER	EQU	19
EPD_IND	EQU	20
EPD_IND_COL	EQU	22
EPD_IND_COL_H	EQU	23
EPD_IND_H	EQU	21
EPD_IND_RAW	EQU	24
EPD_IND_RAW_H	EQU	25
EPD_IND_TRANS	EQU	26
EPD_IND_TRANS_H	EQU	27
EPD_N_COL	EQU	28
EPD_N_COL_H	EQU	29
EPD_N_RAW	EQU	30
EPD_N_RAW_H	EQU	31
GLCDBACKGROUND	EQU	32
GLCDBACKGROUND_H	EQU	33
GLCDCOLOUR	EQU	34
GLCDCOLOUR_H	EQU	35
GLCDDATATEMP	EQU	36
GLCDDATATEMP_H	EQU	37
GLCDDEVICEHEIGHT	EQU	38
GLCDDEVICEHEIGHT_H	EQU	39
GLCDDEVICEWIDTH	EQU	40
GLCDDEVICEWIDTH_H	EQU	41
GLCDFNTDEFAULT	EQU	42
GLCDFNTDEFAULTHEIGHT	EQU	43
GLCDFNTDEFAULTSIZE	EQU	44
GLCDFONTWIDTH	EQU	45
GLCDFOREGROUND	EQU	46
GLCDFOREGROUND_H	EQU	47
GLCDTEMP	EQU	48
GLCDTEMP_H	EQU	49
GLCDX	EQU	50
GLCDX_H	EQU	51
GLCDY	EQU	52
GLCDY_H	EQU	53
GLCD_TIME_BUFF	EQU	54
GLCD_TIME_BUFF_H	EQU	55
GLCD_YORDINATE	EQU	56
GLCD_YORDINATE_H	EQU	57
LINECOLOUR	EQU	58
LINECOLOUR_H	EQU	59
LINEX1	EQU	60
LINEX1_H	EQU	61
LINEX2	EQU	62
LINEX2_H	EQU	63
LINEY1	EQU	64
LINEY1_H	EQU	65
LINEY2	EQU	66
LINEY2_H	EQU	67
N_PAGE	EQU	68
PRINTLOCX	EQU	69
PRINTLOCX_H	EQU	70
PRINTLOCY	EQU	71
PRINTLOCY_H	EQU	72
REMAINDER	EQU	73
SYSBYTETEMPA	EQU	5
SYSBYTETEMPB	EQU	9
SYSBYTETEMPX	EQU	0
SYSDIVLOOP	EQU	4
SYSDIVMULTA	EQU	7
SYSDIVMULTA_H	EQU	8
SYSDIVMULTB	EQU	11
SYSDIVMULTB_H	EQU	12
SYSDIVMULTX	EQU	2
SYSDIVMULTX_H	EQU	3
SYSREPEATTEMP1	EQU	74
SYSREPEATTEMP3	EQU	75
SYSREPEATTEMP4	EQU	76
SYSREPEATTEMP5	EQU	77
SYSREPEATTEMP7	EQU	78
SYSSTRINGA	EQU	7
SYSTEMP1	EQU	79
SYSTEMP1_H	EQU	80
SYSTEMP2	EQU	81
SYSTEMP2_H	EQU	82
SYSTEMP3	EQU	83
SYSWAITTEMPMS	EQU	2
SYSWAITTEMPMS_H	EQU	3
SYSWORDTEMPA	EQU	5
SYSWORDTEMPA_H	EQU	6
SYSWORDTEMPB	EQU	9
SYSWORDTEMPB_H	EQU	10
SYSWORDTEMPX	EQU	0
SYSWORDTEMPX_H	EQU	1
UC1601_BUFFERLOCATIONCALC	EQU	84
UC1601_BUFFERLOCATIONCALC_H	EQU	85
_GLCDPAGE	EQU	86
_GLCDPAGESH	EQU	87
_GLCDPAGESL	EQU	88

;********************************************************************************

;Alias variables
AFSR0	EQU	16361
AFSR0_H	EQU	16362

;********************************************************************************

;Vectors
	ORG	0
	goto	BASPROGRAMSTART
	ORG	8
	retfie

;********************************************************************************

;Start of program memory page 0
	ORG	12
BASPROGRAMSTART
;Call initialisation routines
	rcall	INITSYS
	rcall	INITPPS
	rcall	INIT_EPD2IN13D

;Start of the main program
;''A demonstration program for Explicit-Paper.
;''-------------------------------------------------------------------------
;-------------------------------------------------------
;''This has been tested using the hardware and software SPI option.
;''*************************************************************************
;*******
;Chip Settings.
;#define clock_freq 64
;
;Generated by PIC PPS Tool for Great Cow Basic
;PPS Tool version: 0.0.5.25
;PinManager data: Not available (3)
;Generated for 18f25k42
;
;Template comment at the start of the config file
;
;#define PPSToolPart 18F45k42
;______________
;USART
;#define USART_BAUD_RATE 57600'9600
;#define USART_DELAY     5 ms
;#define USART_BLOCKING
;Set pin USART directions
;Dir portC.7 IN
	bsf	TRISC,7,ACCESS
;Dir portC.6 OUT
	bcf	TRISC,6,ACCESS
;******************************************************************************************************
;The following should be used   '#define EPD_EPD2in13D_HardwareSPI     'remove comment out if you want to use software SPI.
;#define EPD2in13D_HardwareSPI
;#define SPI_BAUD_RATE_REGISTER 7 '**********||||||****|||****|
;***************************************************************************
;***************************
;Setup the E-Paper
;#define GLCD_TYPE GLCD_TYPE_EPD_EPD2in13D
;#define GLCD_EXTENDEDFONTSET1
;#define GLCD_TYPE_EPD2in13D_LOWMEMORY1_GLCD_MODE OFF
;#define GLCD_TYPE_EPD2in13D_LOWMEMORY2_GLCD_MODE ON
;#define GLCD_TYPE_EPD2in13D_LOWMEMORY3_GLCD_MODE OFF
;Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
;ERV These need to GLCD_DC ETC = was wrong naming convention
;#define GLCD_DC     portA.0   ' Data(hight)/ command(low) line
;#define GLCD_CS     portC.1   ' Chip select line
;#define GLCD_RESET  portD.2   ' Reset line
;#define GLCD_DO     portC.5   ' GLCD MOSI connect to MCU SDO
;#define GLCD_SCK    portC.3   ' Clock Line
;#define GLCD_Busy   portC.0
;GLCDRotate ( Landscape_rev )     ' optionally you can rotate the screen.
;Dim ind, counter, ind_raw, ind_col as word
;Dim DataVar, dummy, Flag, VERBOSE as byte
;Dim x_min, x_max, y_min, y_max as Word
;Dim MyString, MyString1 as String
;******************************************************************************************************
;Main program
;GLCD_Open_PageTransaction (0, n_Page-1)   'Open Transaction
;Macro Source: epd_epd2in13d.h (938)
;dim _GLCDPage as byte
;dim _GLCDPagesL, _GLCDPagesH as byte
;Clear_buffer_EPD2in13D
	rcall	CLEAR_BUFFER_EPD2IN13D
;for _GLCDPage = _GLCDPagesL to _GLCDPagesH    '_GLCDPage is a global variable - DO NOT CHANGE!!!
	setf	_GLCDPAGE,ACCESS
	decf	N_PAGE,W,ACCESS
	movwf	SysTemp1,ACCESS
	clrf	SysBYTETempB,ACCESS
	movff	SysTemp1,SysBYTETempA
	call	SysCompLessThan
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoopEnd1
SysForLoop1
	incf	_GLCDPAGE,F,ACCESS
;GLCDLocateString 0,0
	clrf	PRINTLOCX,ACCESS
	clrf	PRINTLOCX_H,ACCESS
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
	rcall	GLCDLOCATESTRING
;if _GLCDPage < _GLCDPagesL or _GLCDPage > _GLCDPagesH then
	decf	N_PAGE,W,ACCESS
	movwf	SysTemp1,ACCESS
	movff	_GLCDPAGE,SysBYTETempA
	clrf	SysBYTETempB,ACCESS
	call	SysCompLessThan
	movff	SysByteTempX,SysTemp2
	movff	_GLCDPAGE,SysBYTETempB
	movff	SysTemp1,SysBYTETempA
	call	SysCompLessThan
	movf	SysTemp2,W,ACCESS
	iorwf	SysByteTempX,W,ACCESS
	movwf	SysTemp1,ACCESS
	btfss	SysTemp1,0,ACCESS
	bra	ENDIF2
;do nothing but send the empty data
;box 10, 10,GLCD_WIDTH-10, GLCD_HEIGHT-10
	movlw	10
	movwf	LINEX1,ACCESS
	clrf	LINEX1_H,ACCESS
	movlw	10
	movwf	LINEY1,ACCESS
	clrf	LINEY1_H,ACCESS
	movlw	94
	movwf	LINEX2,ACCESS
	clrf	LINEX2_H,ACCESS
	movlw	202
	movwf	LINEY2,ACCESS
	clrf	LINEY2_H,ACCESS
	movff	GLCDFOREGROUND,LINECOLOUR
	movff	GLCDFOREGROUND_H,LINECOLOUR_H
	rcall	BOX
;box 20, 20,GLCD_WIDTH-20, GLCD_HEIGHT-20
	movlw	20
	movwf	LINEX1,ACCESS
	clrf	LINEX1_H,ACCESS
	movlw	20
	movwf	LINEY1,ACCESS
	clrf	LINEY1_H,ACCESS
	movlw	84
	movwf	LINEX2,ACCESS
	clrf	LINEX2_H,ACCESS
	movlw	192
	movwf	LINEY2,ACCESS
	clrf	LINEY2_H,ACCESS
	movff	GLCDFOREGROUND,LINECOLOUR
	movff	GLCDFOREGROUND_H,LINECOLOUR_H
	rcall	BOX
;box 30, 30,GLCD_WIDTH-30, GLCD_HEIGHT-30
	movlw	30
	movwf	LINEX1,ACCESS
	clrf	LINEX1_H,ACCESS
	movlw	30
	movwf	LINEY1,ACCESS
	clrf	LINEY1_H,ACCESS
	movlw	74
	movwf	LINEX2,ACCESS
	clrf	LINEX2_H,ACCESS
	movlw	182
	movwf	LINEY2,ACCESS
	clrf	LINEY2_H,ACCESS
	movff	GLCDFOREGROUND,LINECOLOUR
	movff	GLCDFOREGROUND_H,LINECOLOUR_H
	rcall	BOX
;Filledbox 40, 40,GLCD_WIDTH-40, GLCD_HEIGHT-40
	movlw	40
	movwf	LINEX1,ACCESS
	clrf	LINEX1_H,ACCESS
	movlw	40
	movwf	LINEY1,ACCESS
	clrf	LINEY1_H,ACCESS
	movlw	64
	movwf	LINEX2,ACCESS
	clrf	LINEX2_H,ACCESS
	movlw	172
	movwf	LINEY2,ACCESS
	clrf	LINEY2_H,ACCESS
	movff	GLCDFOREGROUND,LINECOLOUR
	movff	GLCDFOREGROUND_H,LINECOLOUR_H
	rcall	FILLEDBOX_EPD2IN13D
;GLCD_Close_PageTransaction                 'Close Transaction
;Macro Source: epd_epd2in13d.h (954)
;end if
ENDIF2
;Pixel_To_Display_EPD2in13D
	rcall	PIXEL_TO_DISPLAY_EPD2IN13D
;next
	decf	N_PAGE,W,ACCESS
	movwf	SysTemp1,ACCESS
	movff	_GLCDPAGE,SysBYTETempA
	movff	SysTemp1,SysBYTETempB
	call	SysCompLessThan
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop1
SysForLoopEnd1
;SendCommand_EPD2in13D(DISPLAY_REFRESH)
	movlw	18
	movwf	EPD2IN13D_COMMAND,ACCESS
	call	SENDCOMMAND_EPD2IN13D
;end
	bra	BASPROGRAMEND
BASPROGRAMEND
	sleep
	bra	BASPROGRAMEND

;********************************************************************************

;Source: glcd.h (1353)
BOX
;dim GLCDTemp as word
;Make sure that starting point (1) is always less than end point (2)
;If LineX1 > LineX2 Then
	movff	LINEX1,SysWORDTempB
	movff	LINEX1_H,SysWORDTempB_H
	movff	LINEX2,SysWORDTempA
	movff	LINEX2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF5
;GLCDTemp = LineX1
	movff	LINEX1,GLCDTEMP
	movff	LINEX1_H,GLCDTEMP_H
;LineX1 = LineX2
	movff	LINEX2,LINEX1
	movff	LINEX2_H,LINEX1_H
;LineX2 = GLCDTemp
	movff	GLCDTEMP,LINEX2
	movff	GLCDTEMP_H,LINEX2_H
;End If
ENDIF5
;If LineY1 > LineY2 Then
	movff	LINEY1,SysWORDTempB
	movff	LINEY1_H,SysWORDTempB_H
	movff	LINEY2,SysWORDTempA
	movff	LINEY2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF6
;GLCDTemp = LineY1
	movff	LINEY1,GLCDTEMP
	movff	LINEY1_H,GLCDTEMP_H
;LineY1 = LineY2
	movff	LINEY2,LINEY1
	movff	LINEY2_H,LINEY1_H
;LineY2 = GLCDTemp
	movff	GLCDTEMP,LINEY2
	movff	GLCDTEMP_H,LINEY2_H
;End If
ENDIF6
;dim DrawLine as word
;Draw lines going across
;For DrawLine = LineX1 To LineX2
	movlw	1
	subwf	LINEX1,W,ACCESS
	movwf	DRAWLINE,ACCESS
	movlw	0
	subwfb	LINEX1_H,W,ACCESS
	movwf	DRAWLINE_H,ACCESS
	movff	LINEX1,SysWORDTempB
	movff	LINEX1_H,SysWORDTempB_H
	movff	LINEX2,SysWORDTempA
	movff	LINEX2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoopEnd2
SysForLoop2
	incf	DRAWLINE,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	DRAWLINE_H,F,ACCESS
;PSet DrawLine, LineY1, LineColour
	movff	DRAWLINE,GLCDX
	movff	DRAWLINE_H,GLCDX_H
	movff	LINEY1,GLCDY
	movff	LINEY1_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	rcall	PSET_EPD2IN13D
;PSet DrawLine, LineY2, LineColour
	movff	DRAWLINE,GLCDX
	movff	DRAWLINE_H,GLCDX_H
	movff	LINEY2,GLCDY
	movff	LINEY2_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	rcall	PSET_EPD2IN13D
;Next
	movff	DRAWLINE,SysWORDTempA
	movff	DRAWLINE_H,SysWORDTempA_H
	movff	LINEX2,SysWORDTempB
	movff	LINEX2_H,SysWORDTempB_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop2
SysForLoopEnd2
;Draw lines going down
;For DrawLine = LineY1 To LineY2
	movlw	1
	subwf	LINEY1,W,ACCESS
	movwf	DRAWLINE,ACCESS
	movlw	0
	subwfb	LINEY1_H,W,ACCESS
	movwf	DRAWLINE_H,ACCESS
	movff	LINEY1,SysWORDTempB
	movff	LINEY1_H,SysWORDTempB_H
	movff	LINEY2,SysWORDTempA
	movff	LINEY2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoopEnd3
SysForLoop3
	incf	DRAWLINE,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	DRAWLINE_H,F,ACCESS
;PSet LineX1, DrawLine, LineColour
	movff	LINEX1,GLCDX
	movff	LINEX1_H,GLCDX_H
	movff	DRAWLINE,GLCDY
	movff	DRAWLINE_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	rcall	PSET_EPD2IN13D
;PSet LineX2, DrawLine, LineColour
	movff	LINEX2,GLCDX
	movff	LINEX2_H,GLCDX_H
	movff	DRAWLINE,GLCDY
	movff	DRAWLINE_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	rcall	PSET_EPD2IN13D
;Next
	movff	DRAWLINE,SysWORDTempA
	movff	DRAWLINE_H,SysWORDTempA_H
	movff	LINEY2,SysWORDTempB
	movff	LINEY2_H,SysWORDTempB_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop3
SysForLoopEnd3
	return

;********************************************************************************

;Source: epd_epd2in13d.h (412)
CLEAR_BUFFER_EPD2IN13D
;initialise global variable. Required variable for Circle - DO NOT DELETE
;GLCD_yordinate = 0
	clrf	GLCD_YORDINATE,ACCESS
	clrf	GLCD_YORDINATE_H,ACCESS
;Dim EPD_Ind_raw, EPD_Ind_col as word
;Dim PrintLocX, PrintLocY as word
;PrintLocX = 0
	clrf	PRINTLOCX,ACCESS
	clrf	PRINTLOCX_H,ACCESS
;PrintLocY = 0
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
;Dim EPD_Ind_raw as Word
;for EPD_Ind_raw=1 to BUFFWIDTH                 'clear the buffer
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop7
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;EPD_Buffer(EPD_Ind_raw)=GLCDBackground
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_RAW,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_RAW_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	GLCDBACKGROUND,INDF0
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	106
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop7
SysForLoopEnd7
	return

;********************************************************************************

;Source: epd_epd2in13d.h (303)
CLS_EPD2IN13D_INIT
;initialise global variable. Required variable for Circle - DO NOT DELETE
;GLCD_yordinate = 0
	clrf	GLCD_YORDINATE,ACCESS
	clrf	GLCD_YORDINATE_H,ACCESS
;Dim EPD_Ind_raw, EPD_Ind_col as word
;Dim PrintLocX, PrintLocY as word
;PrintLocX = 0
	clrf	PRINTLOCX,ACCESS
	clrf	PRINTLOCX_H,ACCESS
;PrintLocY = 0
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
;For EPD_Ind_raw=1 to BUFFWIDTH
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop15
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;EPD_Buffer(EPD_Ind_raw)=GLCDBackground
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_RAW,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_RAW_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	GLCDBACKGROUND,INDF0
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	106
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop15
SysForLoopEnd15
;Clear down "OLD" data
;SendCommand_EPD2in13D(Data_Transmission_1)
	movlw	16
	movwf	EPD2IN13D_COMMAND,ACCESS
	call	SENDCOMMAND_EPD2IN13D
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;for EPD_Ind_raw=1 to GLCD_Height
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop16
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;for EPD_Ind_col=1 to GLCD_Width
	clrf	EPD_IND_COL,ACCESS
	clrf	EPD_IND_COL_H,ACCESS
SysForLoop17
	incf	EPD_IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_COL_H,F,ACCESS
;Was.. speed optimised with macro              SendData_EPD2in13D(GLCDBackGround)
;EPD2in13D_Data = GLCDBackGround
	movff	GLCDBACKGROUND,EPD2IN13D_DATA
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (495)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp5,ACCESS
SysRepeatLoop5
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE44_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF44
ELSE44_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF44
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp5,F,ACCESS
	bra	SysRepeatLoop5
SysRepeatLoopEnd5
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
;next
	movff	EPD_IND_COL,SysWORDTempA
	movff	EPD_IND_COL_H,SysWORDTempA_H
	movlw	104
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop17
SysForLoopEnd17
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	212
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop16
SysForLoopEnd16
;wait 10 ms
	movlw	10
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;Clear down "NEW" data
;SendCommand_EPD2in13D(Data_Transmission_2)
	movlw	19
	movwf	EPD2IN13D_COMMAND,ACCESS
	call	SENDCOMMAND_EPD2IN13D
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;for EPD_Ind_raw=1 to GLCD_Height
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop18
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;for EPD_Ind_col=1 to GLCD_Width
	clrf	EPD_IND_COL,ACCESS
	clrf	EPD_IND_COL_H,ACCESS
SysForLoop19
	incf	EPD_IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_COL_H,F,ACCESS
;Was.. speed optimised with macro              SendData_EPD2in13D(GLCDBackGround)
;EPD2in13D_Data = GLCDBackGround
	movff	GLCDBACKGROUND,EPD2IN13D_DATA
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (495)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp5,ACCESS
SysRepeatLoop6
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE47_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF47
ELSE47_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF47
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp5,F,ACCESS
	bra	SysRepeatLoop6
SysRepeatLoopEnd6
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
;next
	movff	EPD_IND_COL,SysWORDTempA
	movff	EPD_IND_COL_H,SysWORDTempA_H
	movlw	104
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop19
SysForLoopEnd19
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	212
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop18
SysForLoopEnd18
;wait 10 ms
	movlw	10
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	bra	Delay_MS

;********************************************************************************

Delay_MS
	incf	SysWaitTempMS_H, F,ACCESS
DMS_START
	movlw	129
	movwf	DELAYTEMP2,ACCESS
DMS_OUTER
	movlw	40
	movwf	DELAYTEMP,ACCESS
DMS_INNER
	decfsz	DELAYTEMP, F,ACCESS
	bra	DMS_INNER
	decfsz	DELAYTEMP2, F,ACCESS
	bra	DMS_OUTER
	decfsz	SysWaitTempMS, F,ACCESS
	bra	DMS_START
	decfsz	SysWaitTempMS_H, F,ACCESS
	bra	DMS_START
	return

;********************************************************************************

;Source: epd_epd2in13d.h (797)
FILLEDBOX_EPD2IN13D
;Make sure that starting point (1) is always less than end point (2)
;Dim EPD_Ind_raw, EPD_Ind_col as Word
;If LineX1 > LineX2 Then
	movff	LINEX1,SysWORDTempB
	movff	LINEX1_H,SysWORDTempB_H
	movff	LINEX2,SysWORDTempA
	movff	LINEX2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF30
;GLCDTemp = LineX1
	movff	LINEX1,GLCDTEMP
;LineX1 = LineX2
	movff	LINEX2,LINEX1
	movff	LINEX2_H,LINEX1_H
;LineX2 = GLCDTemp
	movff	GLCDTEMP,LINEX2
	clrf	LINEX2_H,ACCESS
;End If
ENDIF30
;If LineY1 > LineY2 Then
	movff	LINEY1,SysWORDTempB
	movff	LINEY1_H,SysWORDTempB_H
	movff	LINEY2,SysWORDTempA
	movff	LINEY2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF31
;GLCDTemp = LineY1
	movff	LINEY1,GLCDTEMP
;LineY1 = LineY2
	movff	LINEY2,LINEY1
	movff	LINEY2_H,LINEY1_H
;LineY2 = GLCDTemp
	movff	GLCDTEMP,LINEY2
	clrf	LINEY2_H,ACCESS
;End If
ENDIF31
;for EPD_Ind_raw=LineY1  to LineY2
	movlw	1
	subwf	LINEY1,W,ACCESS
	movwf	EPD_IND_RAW,ACCESS
	movlw	0
	subwfb	LINEY1_H,W,ACCESS
	movwf	EPD_IND_RAW_H,ACCESS
	movff	LINEY1,SysWORDTempB
	movff	LINEY1_H,SysWORDTempB_H
	movff	LINEY2,SysWORDTempA
	movff	LINEY2_H,SysWORDTempA_H
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoopEnd8
SysForLoop8
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;for EPD_Ind_col=LineX1 to lineX2
	movlw	1
	subwf	LINEX1,W,ACCESS
	movwf	EPD_IND_COL,ACCESS
	movlw	0
	subwfb	LINEX1_H,W,ACCESS
	movwf	EPD_IND_COL_H,ACCESS
	movff	LINEX1,SysWORDTempB
	movff	LINEX1_H,SysWORDTempB_H
	movff	LINEX2,SysWORDTempA
	movff	LINEX2_H,SysWORDTempA_H
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoopEnd9
SysForLoop9
	incf	EPD_IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_COL_H,F,ACCESS
;PSet_EPD2in13D(EPD_Ind_Col, EPD_Ind_raw, LineColour)
	movff	EPD_IND_COL,GLCDX
	movff	EPD_IND_COL_H,GLCDX_H
	movff	EPD_IND_RAW,GLCDY
	movff	EPD_IND_RAW_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	rcall	PSET_EPD2IN13D
;next
	movff	EPD_IND_COL,SysWORDTempA
	movff	EPD_IND_COL_H,SysWORDTempA_H
	movff	LINEX2,SysWORDTempB
	movff	LINEX2_H,SysWORDTempB_H
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop9
SysForLoopEnd9
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movff	LINEY2,SysWORDTempB
	movff	LINEY2_H,SysWORDTempB_H
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop8
SysForLoopEnd8
	return

;********************************************************************************

;Source: glcd.h (1129)
GLCDLOCATESTRING
;dim PrintLocY as word
;if PrintLocY < 2 then
	movff	PRINTLOCY,SysWORDTempA
	movff	PRINTLOCY_H,SysWORDTempA_H
	movlw	2
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ELSE4_1
;PrintLocY = 0
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
;else
	bra	ENDIF4
ELSE4_1
;PrintLocY--
	movlw	1
	subwf	PRINTLOCY,F,ACCESS
	movlw	0
	subwfb	PRINTLOCY_H,F,ACCESS
;PrintLocY = ( PrintLocY * ( GLCDfntDefaultHeight * GLCDfntDefaultSize ) ) mod EPD_CORRECTED_HEIGHT
	movf	GLCDFNTDEFAULTHEIGHT,W,ACCESS
	mulwf	GLCDFNTDEFAULTSIZE,ACCESS
	movffl	PRODL,SysTemp1
	movff	PRINTLOCY,SysWORDTempA
	movff	PRINTLOCY_H,SysWORDTempA_H
	movff	SysTemp1,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysMultSub16
	movff	SysWORDTempX,SysTemp2
	movff	SysWORDTempX_H,SysTemp2_H
	movff	SysTemp2,SysWORDTempA
	movff	SysTemp2_H,SysWORDTempA_H
	movlw	208
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysDivSub16
	movff	SysWORDTempX,PRINTLOCY
	movff	SysWORDTempX_H,PRINTLOCY_H
;end if
ENDIF4
	return

;********************************************************************************

;Source: E_paper-18F47K42_Transaction.gcb (24)
INITPPS
;This has been added to turn off PPS SPI when in SPI software mode
;Module: UART1  (0x.... è in ESADECIMALE)
;U1RXPPS = 0x0017        'RC7 > RX1
	movlw	23
	banksel	U1RXPPS
	movwf	U1RXPPS,BANKED
;RC6PPS  = 0x0013        'TX1 > RC6
	movlw	19
	movwf	RC6PPS,BANKED
;Module: SPI1
;SPI1SDIPPS = 0x0014     'RC4 > SDI1
	movlw	20
	movwf	SPI1SDIPPS,BANKED
;RC5PPS = 0x001F         'SDO1 > RC5
	movlw	31
	movwf	RC5PPS,BANKED
;RC3PPS = 0x001E         'SCK1 > RC3
	movlw	30
	movwf	RC3PPS,BANKED
;SPI1SCKPPS = 0x0013     'RC3 > SCK1 (bi-directional)
	movlw	19
	movwf	SPI1SCKPPS,BANKED
	banksel	0
	return

;********************************************************************************

;Source: system.h (99)
INITSYS
;Set up internal oscillator
;Handle OSCCON1 register for parts that have this register
;asm showdebug OSCCON type is 100 'This is the routine to support OSCCON1 config addresss
;osccon type is 100
;OSCCON1 = 0x60 ' NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
	movlw	96
	banksel	OSCCON1
	movwf	OSCCON1,BANKED
;OSCCON3 = 0x00 ' CSWHOLD may proceed; SOSCPWR Low power
	clrf	OSCCON3,BANKED
;OSCEN = 0x00   ' MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
	clrf	OSCEN,BANKED
;OSCTUNE = 0x00 ' HFTUN 0
	clrf	OSCTUNE,BANKED
;The MCU is a ChipFamily16
;Section support many MCUs, 18FxxK40, 18FxxK42 etc etc all have NDIV3 bit
;asm showdebug OSCCON type is 101 ' ChipFamily16 and NDIV3 bit
;osccon type is 101
;Clear NDIV3:0
;NDIV3 = 0
	bcf	OSCCON1,NDIV3,BANKED
;NDIV2 = 0
	bcf	OSCCON1,NDIV2,BANKED
;NDIV1 = 0
	bcf	OSCCON1,NDIV1,BANKED
;NDIV0 = 0
	bcf	OSCCON1,NDIV0,BANKED
;OSCFRQ = 0b00001000  '64mhz
	movlw	8
	movwf	OSCFRQ,BANKED
;Clear BSR on ChipFamily16 MCUs
;BSR = 0
	clrf	BSR,ACCESS
;Clear TBLPTRU on MCUs with this bit as this must be zero
;TBLPTRU = 0
	clrf	TBLPTRU,ACCESS
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	banksel	ADCON0
	bcf	ADCON0,ADFM0,BANKED
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	bcf	ADCON0,ADON,BANKED
;Commence clearing any ANSEL variants in the part
;ANSELA = 0
	banksel	ANSELA
	clrf	ANSELA,BANKED
;ANSELB = 0
	clrf	ANSELB,BANKED
;ANSELC = 0
	clrf	ANSELC,BANKED
;ANSELD = 0
	clrf	ANSELD,BANKED
;ANSELE = 0
	clrf	ANSELE,BANKED
;End clearing any ANSEL variants in the part
;Set comparator register bits for many MCUs with register CM2CON0
;C2EN = 0
	banksel	CM2CON0
	bcf	CM2CON0,C2EN,BANKED
;C1EN = 0
	bcf	CM1CON0,C1EN,BANKED
;Turn off all ports
;PORTA = 0
	clrf	PORTA,ACCESS
;PORTB = 0
	clrf	PORTB,ACCESS
;PORTC = 0
	clrf	PORTC,ACCESS
;PORTD = 0
	clrf	PORTD,ACCESS
;PORTE = 0
	clrf	PORTE,ACCESS
	banksel	0
	return

;********************************************************************************

;Source: epd_epd2in13d.h (160)
INIT_EPD2IN13D
;dim _GLCDPagesL, _GLCDPagesH  as byte
;asm showdebug Current_buffer_size_is BUFFWIDTH
;current_buffer_size_is 106
;Dir   EPD_DC     OUT
	bcf	TRISA,0,ACCESS
;Dir   EPD_CS     OUT
	bcf	TRISC,1,ACCESS
;Dir   EPD_RESET  OUT
	bcf	TRISD,2,ACCESS
;Dir   EPD_DO     OUT
	bcf	TRISC,5,ACCESS
;Dir   EPD_SCK    OUT
	bcf	TRISC,3,ACCESS
;Dir   EPD_Busy   IN
	bsf	TRISC,0,ACCESS
;SET EPD_RESET ON
	bsf	LATD,2,ACCESS
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SET EPD_RESET OFF
	bcf	LATD,2,ACCESS
;wait 20 ms
	movlw	20
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SET EPD_RESET ON
	bsf	LATD,2,ACCESS
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(BOOSTER_SOFT_START)
	movlw	6
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x17)
	movlw	23
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x17)
	movlw	23
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x17)
	movlw	23
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(POWER_SETTING)
	movlw	1
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x03)
	movlw	3
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x00)
	clrf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x2B)
	movlw	43
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x2B)
	movlw	43
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x03)
	movlw	3
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(POWER_ON)
	movlw	4
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendCommand_EPD2in13D(PANEL_SETTING)
	clrf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(PANEL_SETTING_VALUE or PANEL_SETTING_KWR )
	movlw	191
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(PLL_CONTROL)
	movlw	48
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x3C)
	movlw	60
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(RESOLUTION_SETTING)
	movlw	97
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x68)
	movlw	104
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x00)
	clrf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0xD4)
	movlw	212
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(VCM_DC_SETTING)
	movlw	130
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x12)
	movlw	18
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;LoadLUTS_EPD2in13D
	rcall	LOADLUTS_EPD2IN13D
;Colours
;GLCDForeground =TFT_WHITE
	setf	GLCDFOREGROUND,ACCESS
	setf	GLCDFOREGROUND_H,ACCESS
;Default Colours
;GLCDBackground = TFT_BLACK
	clrf	GLCDBACKGROUND,ACCESS
	clrf	GLCDBACKGROUND_H,ACCESS
;GLCDFontWidth = 6
	movlw	6
	movwf	GLCDFONTWIDTH,ACCESS
;Variables required for device
;GLCDDeviceWidth = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;GLCDDeviceHeight= GLCD_HEIGHT- 1
	movlw	211
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDRotate Portrait
	movlw	4
	movwf	EPD2IN13DADDRESSTYPE,ACCESS
	rcall	ROTATE_EPD2IN13D
;GLCDfntDefault = 0
	clrf	GLCDFNTDEFAULT,ACCESS
;GLCDfntDefaultsize = 1
	movlw	1
	movwf	GLCDFNTDEFAULTSIZE,ACCESS
;GLCDfntDefaultHeight = 8
	movlw	8
	movwf	GLCDFNTDEFAULTHEIGHT,ACCESS
;CLS_EPD2in13D_init
	rcall	CLS_EPD2IN13D_INIT
;_GLCDPagesH = EPD_N_PAGE - 1
	movlw	25
	movwf	_GLCDPAGESH,ACCESS
;_GLCDPagesL = 0
	clrf	_GLCDPAGESL,ACCESS
;_GLCDPage = 0
	clrf	_GLCDPAGE,ACCESS
	return

;********************************************************************************

;Source: epd_epd2in13d.h (256)
LOADLUTS_EPD2IN13D
;Dim DataVar as byte
;Dim Counter as Word
;SendCommand_EPD2in13D(VCM_DC_SETTING)
	movlw	130
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x00)
	clrf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(VCOM_AND_DATA_INTERVAL_SETTING)
	movlw	80
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;Mask VCOM_AND_DATA_INTERVAL bits and then Mask the user bits.
;SendData_EPD2in13D( (0x90 AND 0xF0 ) or ( VCOM_AND_DATA_INTERVAL AND 0X0F ))
	movlw	151
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(0x20) 'VCOM LUT
	movlw	32
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 44
	clrf	EPD_COUNTER,ACCESS
SysForLoop10
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_Vcom, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_VCOM
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	44
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop10
SysForLoopEnd10
;SendCommand_EPD2in13D(0x21) 'WW LUT
	movlw	33
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 42
	clrf	EPD_COUNTER,ACCESS
SysForLoop11
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_WW, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_WW
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	42
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop11
SysForLoopEnd11
;SendCommand_EPD2in13D(0x22) 'BW LUT
	movlw	34
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 42
	clrf	EPD_COUNTER,ACCESS
SysForLoop12
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_BW, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_BW
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	42
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop12
SysForLoopEnd12
;SendCommand_EPD2in13D(0x23) 'WB LUT
	movlw	35
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 42
	clrf	EPD_COUNTER,ACCESS
SysForLoop13
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_WB, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_WB
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	42
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop13
SysForLoopEnd13
;SendCommand_EPD2in13D(0x24) 'BB LUT
	movlw	36
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 42
	clrf	EPD_COUNTER,ACCESS
SysForLoop14
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_BB, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_BB
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	42
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop14
SysForLoopEnd14
	return

;********************************************************************************

LUT_BB
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_BB
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_BB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_BB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_BB
	db	42,128,8,0,0,0,2,144,40,40,0,0,1,128,20,0,0,0,1,80,18,18,0,0,1

;********************************************************************************

LUT_BW
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_BW
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_BW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_BW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_BW
	db	42,64,23,0,0,0,2,144,15,15,0,0,3,64,10,1,0,0,1,160,14,14,0,0,2

;********************************************************************************

LUT_VCOM
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_VCOM
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_VCOM
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_VCOM
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_VCOM
	db	44,0,8,0,0,0,2,96,40,40,0,0,1,0,20,0,0,0,1,0,18,18,0,0,1

;********************************************************************************

LUT_WB
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_WB
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_WB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_WB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_WB
	db	42,128,8,0,0,0,2,144,40,40,0,0,1,128,20,0,0,0,1,80,18,18,0,0,1

;********************************************************************************

LUT_WW
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_WW
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_WW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_WW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_WW
	db	42,64,8,0,0,0,2,144,40,40,0,0,1,64,20,0,0,0,1,160,18,18,0,0,1

;********************************************************************************

;Source: epd_epd2in13d.h (361)
PIXEL_TO_DISPLAY_EPD2IN13D
;Dim EPD_Ind_raw, EPD_Ind_col as Word
;if _GLCDPage = 0 then
	movf	_GLCDPAGE,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF11
;Clear down 'OLD' data - to prevent flashing
;SendCommand_EPD2in13D(Data_Transmission_1)
	movlw	16
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;for EPD_Ind_raw=1 to GLCD_Height
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop4
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;for EPD_Ind_col=1 to GLCD_Width
	clrf	EPD_IND_COL,ACCESS
	clrf	EPD_IND_COL_H,ACCESS
SysForLoop5
	incf	EPD_IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_COL_H,F,ACCESS
;Replaced with macro for speed              SendData_EPD2in13D(GLCDBackGround)
;EPD2in13D_Data = GLCDBackGround
	movff	GLCDBACKGROUND,EPD2IN13D_DATA
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (495)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp1,ACCESS
SysRepeatLoop1
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE14_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF14
ELSE14_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF14
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp1,F,ACCESS
	bra	SysRepeatLoop1
SysRepeatLoopEnd1
;next
	movff	EPD_IND_COL,SysWORDTempA
	movff	EPD_IND_COL_H,SysWORDTempA_H
	movlw	104
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop5
SysForLoopEnd5
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	212
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop4
SysForLoopEnd4
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
;SendCommand_EPD2in13D(DATA_TRANSMISSION_2)
	movlw	19
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;end if
ENDIF11
;dim EPD2in13D_Data as byte
;We need to set the signals as we are optimising the code by using the macro
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;for EPD_Ind_raw=1 to BUFFWIDTH
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop6
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;replaced with macro for speed
;SendData_EPD2in13D(EPD_Buffer(EPD_Ind_raw))
;EPD2in13D_Data = EPD_Buffer(EPD_Ind_raw)
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_RAW,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_RAW_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	INDF0,EPD2IN13D_DATA
;The following line is intentionally commented out, but, it shows the orientation of the pixels to the array. Uncomment to force a two (when the value is 3!) byte write to the Display
;You can then examine the display to see the orientation of the pixels.
;This will write the bytes at the top of each page - so, do not be surprised!
;if EPD_Ind_raw < 3 then EPD2in13D_Data = GLCDForeground
;This macro assumes the use of the variable EPD2in13D_Data
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (495)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp1,ACCESS
SysRepeatLoop2
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE12_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF12
ELSE12_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF12
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp1,F,ACCESS
	bra	SysRepeatLoop2
SysRepeatLoopEnd2
;Now clear the buffer
;EPD_Buffer(EPD_Ind_raw) = GLCDBackground
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_RAW,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_RAW_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	GLCDBACKGROUND,INDF0
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	106
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop6
SysForLoopEnd6
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
	return

;********************************************************************************

;Source: epd_epd2in13d.h (691)
PSET_EPD2IN13D
;Dim EPD_Ind, EPD_N_Col, EPD_N_raw, EPD_Ind_Trans as word
;Dim remainder as byte
;Dim DataVar as byte
;Dim value as bit
;Dim GLCD_Time_Buff as word
;Dim GLCDDataTemp, GLCDY_Temp, GLCDY_withinPage  as word
;Select Case EPD2in13DAddressType
;case Landscape
SysSelect1Case1
	decf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case2
;GLCDDataTemp = GLCDX
	movff	GLCDX,GLCDDATATEMP
	movff	GLCDX_H,GLCDDATATEMP_H
;GLCDX = GLCDY
	movff	GLCDY,GLCDX
	movff	GLCDY_H,GLCDX_H
;GLCDY = GLCD_HEIGHT - GLCDDataTemp - 1
	movf	GLCDDATATEMP,W,ACCESS
	sublw	212
	movwf	SysTemp2,ACCESS
	clrf	SysTemp1,ACCESS
	movf	GLCDDATATEMP_H,W,ACCESS
	subwfb	SysTemp1,W,ACCESS
	movwf	SysTemp2_H,ACCESS
	movlw	1
	subwf	SysTemp2,W,ACCESS
	movwf	GLCDY,ACCESS
	movlw	0
	subwfb	SysTemp2_H,W,ACCESS
	movwf	GLCDY_H,ACCESS
;case Landscape_Rev
	bra	SysSelectEnd1
SysSelect1Case2
	movlw	3
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case3
;GLCDDataTemp = GLCDX
	movff	GLCDX,GLCDDATATEMP
	movff	GLCDX_H,GLCDDATATEMP_H
;GLCDX = GLCD_WIDTH  - GLCDY - 1
	movf	GLCDY,W,ACCESS
	sublw	104
	movwf	SysTemp2,ACCESS
	clrf	SysTemp1,ACCESS
	movf	GLCDY_H,W,ACCESS
	subwfb	SysTemp1,W,ACCESS
	movwf	SysTemp2_H,ACCESS
	movlw	1
	subwf	SysTemp2,W,ACCESS
	movwf	GLCDX,ACCESS
	movlw	0
	subwfb	SysTemp2_H,W,ACCESS
	movwf	GLCDX_H,ACCESS
;GLCDY = GLCDDataTemp
	movff	GLCDDATATEMP,GLCDY
	movff	GLCDDATATEMP_H,GLCDY_H
;case Portrait
	bra	SysSelectEnd1
SysSelect1Case3
	movlw	4
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case4
;Default do nothing
;case Portrait_Rev
	bra	SysSelectEnd1
SysSelect1Case4
	movlw	2
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelectEnd1
;GLCDY = GLCD_HEIGHT - GLCDY - 1
	movf	GLCDY,W,ACCESS
	sublw	212
	movwf	SysTemp2,ACCESS
	clrf	SysTemp1,ACCESS
	movf	GLCDY_H,W,ACCESS
	subwfb	SysTemp1,W,ACCESS
	movwf	SysTemp2_H,ACCESS
	movlw	1
	subwf	SysTemp2,W,ACCESS
	movwf	GLCDY,ACCESS
	movlw	0
	subwfb	SysTemp2_H,W,ACCESS
	movwf	GLCDY_H,ACCESS
;GLCDX = GLCD_WIDTH - GLCDX - 1
	movf	GLCDX,W,ACCESS
	sublw	104
	movwf	SysTemp2,ACCESS
	clrf	SysTemp1,ACCESS
	movf	GLCDX_H,W,ACCESS
	subwfb	SysTemp1,W,ACCESS
	movwf	SysTemp2_H,ACCESS
	movlw	1
	subwf	SysTemp2,W,ACCESS
	movwf	GLCDX,ACCESS
	movlw	0
	subwfb	SysTemp2_H,W,ACCESS
	movwf	GLCDX_H,ACCESS
;end select
SysSelectEnd1
;Exit if not the current page.
;if  ( GLCDY / EPD_PIXELS_PER_PAGE  ) <> _GLCDPage then
	movff	GLCDY,SysWORDTempA
	movff	GLCDY_H,SysWORDTempA_H
	movlw	8
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysDivSub16
	movff	SysWORDTempA,SysTemp2
	movff	SysWORDTempA_H,SysTemp2_H
	movff	SysTemp2,SysWORDTempA
	movff	SysTemp2_H,SysWORDTempA_H
	movff	_GLCDPAGE,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompEqual16
	comf	SysByteTempX,F,ACCESS
	btfsc	SysByteTempX,0,ACCESS
;exit sub
	return
;end if
;buffer location in LOWMEMORY_GLCD_MODE always equals GLCDX + 1
;UC1601_BufferLocationCalc = GLCDX + 1
	movlw	1
	addwf	GLCDX,W,ACCESS
	movwf	UC1601_BUFFERLOCATIONCALC,ACCESS
	movlw	0
	addwfc	GLCDX_H,W,ACCESS
	movwf	UC1601_BUFFERLOCATIONCALC_H,ACCESS
;EPD_N_Col=(GLCDX+1)/8                   'number of the column of the byte to be set
;EPD_N_Col=(GLCDX+1)
	movlw	1
	addwf	GLCDX,W,ACCESS
	movwf	EPD_N_COL,ACCESS
	movlw	0
	addwfc	GLCDX_H,W,ACCESS
	movwf	EPD_N_COL_H,ACCESS
;Repeat 3
	movlw	3
	movwf	SysRepeatTemp4,ACCESS
SysRepeatLoop4
;Set C Off
	bcf	STATUS,C,ACCESS
;Rotate EPD_N_Col Right
	rrcf	EPD_N_COL_H,F,ACCESS
	rrcf	EPD_N_COL,F,ACCESS
;End Repeat
	decfsz	SysRepeatTemp4,F,ACCESS
	bra	SysRepeatLoop4
SysRepeatLoopEnd4
;remainder=(GLCDX+1) % 8
	movlw	1
	addwf	GLCDX,W,ACCESS
	movwf	SysTemp2,ACCESS
	movlw	0
	addwfc	GLCDX_H,W,ACCESS
	movwf	SysTemp2_H,ACCESS
	movff	SysTemp2,SysWORDTempA
	movff	SysTemp2_H,SysWORDTempA_H
	movlw	8
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysDivSub16
	movff	SysWORDTempX,REMAINDER
;EPD_N_raw=GLCDY * GLCD_Width8       'number of the column of the byte to be set
	movff	GLCDY,SysWORDTempA
	movff	GLCDY_H,SysWORDTempA_H
	movlw	13
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysMultSub16
	movff	SysWORDTempX,EPD_N_RAW
	movff	SysWORDTempX_H,EPD_N_RAW_H
;if remainder=0 then
	movf	REMAINDER,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ELSE20_1
;EPD_Ind=EPD_N_raw+EPD_N_Col
	movf	EPD_N_COL,W,ACCESS
	addwf	EPD_N_RAW,W,ACCESS
	movwf	EPD_IND,ACCESS
	movf	EPD_N_COL_H,W,ACCESS
	addwfc	EPD_N_RAW_H,W,ACCESS
	movwf	EPD_IND_H,ACCESS
;else
	bra	ENDIF20
ELSE20_1
;EPD_Ind=EPD_N_raw+EPD_N_Col+1       'Number of the byte to be set (starting from 1)
	movf	EPD_N_COL,W,ACCESS
	addwf	EPD_N_RAW,W,ACCESS
	movwf	SysTemp1,ACCESS
	movf	EPD_N_COL_H,W,ACCESS
	addwfc	EPD_N_RAW_H,W,ACCESS
	movwf	SysTemp1_H,ACCESS
	movlw	1
	addwf	SysTemp1,W,ACCESS
	movwf	EPD_IND,ACCESS
	movlw	0
	addwfc	SysTemp1_H,W,ACCESS
	movwf	EPD_IND_H,ACCESS
;end if
ENDIF20
;GLCD_Time_Buff=_GLCDPage*BUFFWIDTH
	movff	_GLCDPAGE,SysWORDTempA
	clrf	SysWORDTempA_H,ACCESS
	movlw	106
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysMultSub16
	movff	SysWORDTempX,GLCD_TIME_BUFF
	movff	SysWORDTempX_H,GLCD_TIME_BUFF_H
;EPD_Ind_Trans=EPD_Ind
	movff	EPD_IND,EPD_IND_TRANS
	movff	EPD_IND_H,EPD_IND_TRANS_H
;EPD_Ind_Trans=EPD_Ind_Trans-GLCD_Time_Buff
	movf	GLCD_TIME_BUFF,W,ACCESS
	subwf	EPD_IND_TRANS,F,ACCESS
	movf	GLCD_TIME_BUFF_H,W,ACCESS
	subwfb	EPD_IND_TRANS_H,F,ACCESS
;if EPD_Ind_Trans>BUFFWIDTH then       'NOTE:it should be a control also for a
	movff	EPD_IND_TRANS,SysWORDTempB
	movff	EPD_IND_TRANS_H,SysWORDTempB_H
	movlw	106
	movwf	SysWORDTempA,ACCESS
	clrf	SysWORDTempA_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
;EXIT SUB                            'lower bound of ind (ind>GLCD_Time_Buff)
	return
;end if                                'However when the lower bound is violated,
;DataVar=EPD_Buffer(EPD_Ind_Trans)     'Ind_Trans should be negative and, due to
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_TRANS,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_TRANS_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	INDF0,DATAVAR
;Select Case remainder                 'non signed arithmetic, it will be very
;case 0                                'large, thus Exits sub is executed.
SysSelect2Case1
	movf	REMAINDER,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case2
;DataVar.0=GLCDColour.0
	bcf	DATAVAR,0,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,0,ACCESS
;case 1
	bra	SysSelectEnd2
SysSelect2Case2
	decf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case3
;DataVar.7=GLCDColour.0
	bcf	DATAVAR,7,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,7,ACCESS
;case 2
	bra	SysSelectEnd2
SysSelect2Case3
	movlw	2
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case4
;DataVar.6=GLCDColour.0
	bcf	DATAVAR,6,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,6,ACCESS
;case 3
	bra	SysSelectEnd2
SysSelect2Case4
	movlw	3
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case5
;DataVar.5=GLCDColour.0
	bcf	DATAVAR,5,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,5,ACCESS
;case 4
	bra	SysSelectEnd2
SysSelect2Case5
	movlw	4
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case6
;DataVar.4=GLCDColour.0
	bcf	DATAVAR,4,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,4,ACCESS
;case 5
	bra	SysSelectEnd2
SysSelect2Case6
	movlw	5
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case7
;DataVar.3=GLCDColour.0
	bcf	DATAVAR,3,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,3,ACCESS
;case 6
	bra	SysSelectEnd2
SysSelect2Case7
	movlw	6
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case8
;DataVar.2=GLCDColour.0
	bcf	DATAVAR,2,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,2,ACCESS
;case 7
	bra	SysSelectEnd2
SysSelect2Case8
	movlw	7
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelectEnd2
;DataVar.1=GLCDColour.0
	bcf	DATAVAR,1,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,1,ACCESS
;End Select
SysSelectEnd2
;EPD_Buffer(EPD_Ind_Trans)=DataVar
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_TRANS,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_TRANS_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	DATAVAR,INDF0
	return

;********************************************************************************

;Source: epd_epd2in13d.h (898)
ROTATE_EPD2IN13D
;DIM GLCDDataTemp, PrintLocY, PrintLocX as word
;PrintLocY = 0
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
;PrintLocX = 0
	clrf	PRINTLOCX,ACCESS
	clrf	PRINTLOCX_H,ACCESS
;select case EPD2in13DAddressType
;case PORTRAIT
SysSelect3Case1
	movlw	4
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect3Case2
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;case LANDSCAPE
	bra	SysSelectEnd3
SysSelect3Case2
	decf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect3Case3
;GLCDDeviceHeight = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth  = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;case PORTRAIT_REV
	bra	SysSelectEnd3
SysSelect3Case3
	movlw	2
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect3Case4
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth  = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;case LANDSCAPE_REV
	bra	SysSelectEnd3
SysSelect3Case4
	movlw	3
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect3Case5
;GLCDDeviceHeight = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth  = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;case else
	bra	SysSelectEnd3
SysSelect3Case5
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth  = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;end select
SysSelectEnd3
	return

;********************************************************************************

;Source: epd_epd2in13d.h (452)
SENDCOMMAND_EPD2IN13D
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC OFF
	bcf	LATA,0,ACCESS
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp3,ACCESS
SysRepeatLoop3
;IF EPD2in13D_Command.7 = ON THEN
	btfss	EPD2IN13D_COMMAND,7,ACCESS
	bra	ELSE18_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF18
ELSE18_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF18
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Command left
	rlcf	EPD2IN13D_COMMAND,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp3,F,ACCESS
	bra	SysRepeatLoop3
SysRepeatLoopEnd3
;Set EPD_CS ON
	bsf	LATC,1,ACCESS
;do
SysDoLoop_S1
;loop while EPD_Busy=Off
	btfss	PORTC,0,ACCESS
	bra	SysDoLoop_S1
SysDoLoop_E1
	return

;********************************************************************************

;Source: epd_epd2in13d.h (485)
SENDDATA_EPD2IN13D
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (495)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp7,ACCESS
SysRepeatLoop7
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE50_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF50
ELSE50_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF50
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp7,F,ACCESS
	bra	SysRepeatLoop7
SysRepeatLoopEnd7
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
	return

;********************************************************************************

;Source: system.h (2639)
SYSCOMPEQUAL16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX,ACCESS
;Test low, exit if false
;movf SysWordTempB, W
	movf	SYSWORDTEMPB, W,ACCESS
;cpfseq SysWordTempA
	cpfseq	SYSWORDTEMPA,ACCESS
;return
	return
;Test high, exit if false
;movf SysWordTempB_H, W
	movf	SYSWORDTEMPB_H, W,ACCESS
;cpfseq SysWordTempA_H
	cpfseq	SYSWORDTEMPA_H,ACCESS
;return
	return
;setf SysByteTempX
	setf	SYSBYTETEMPX,ACCESS
	return

;********************************************************************************

;Source: system.h (2780)
SYSCOMPLESSTHAN
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;setf SysByteTempX
	setf	SYSBYTETEMPX,ACCESS
;movf SysByteTempB, W
	movf	SYSBYTETEMPB, W,ACCESS
;cpfslt SysByteTempA
	cpfslt	SYSBYTETEMPA,ACCESS
;clrf SysByteTempX
	clrf	SYSBYTETEMPX,ACCESS
	return

;********************************************************************************

;Source: system.h (2810)
SYSCOMPLESSTHAN16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX,ACCESS
;Test High, exit if more
;movf SysWordTempA_H,W
	movf	SYSWORDTEMPA_H,W,ACCESS
;subwf SysWordTempB_H,W
	subwf	SYSWORDTEMPB_H,W,ACCESS
;btfss STATUS,C
	btfss	STATUS,C,ACCESS
;return
	return
;Test high, exit true if less
;movf SysWordTempB_H,W
	movf	SYSWORDTEMPB_H,W,ACCESS
;subwf SysWordTempA_H,W
	subwf	SYSWORDTEMPA_H,W,ACCESS
;bnc SCLT16True
	bnc	SCLT16TRUE
;Test Low, exit if more or equal
;movf SysWordTempB,W
	movf	SYSWORDTEMPB,W,ACCESS
;subwf SysWordTempA,W
	subwf	SYSWORDTEMPA,W,ACCESS
;btfsc STATUS,C
	btfsc	STATUS,C,ACCESS
;return
	return
SCLT16TRUE
;comf SysByteTempX,F
	comf	SYSBYTETEMPX,F,ACCESS
	return

;********************************************************************************

;Source: system.h (2457)
SYSDIVSUB16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;dim SysDivMultA as word
;dim SysDivMultB as word
;dim SysDivMultX as word
;SysDivMultA = SysWordTempA
	movff	SYSWORDTEMPA,SYSDIVMULTA
	movff	SYSWORDTEMPA_H,SYSDIVMULTA_H
;SysDivMultB = SysWordTempB
	movff	SYSWORDTEMPB,SYSDIVMULTB
	movff	SYSWORDTEMPB_H,SYSDIVMULTB_H
;SysDivMultX = 0
	clrf	SYSDIVMULTX,ACCESS
	clrf	SYSDIVMULTX_H,ACCESS
;Avoid division by zero
;if SysDivMultB = 0 then
	movff	SYSDIVMULTB,SysWORDTempA
	movff	SYSDIVMULTB_H,SysWORDTempA_H
	clrf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompEqual16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF36
;SysWordTempA = 0
	clrf	SYSWORDTEMPA,ACCESS
	clrf	SYSWORDTEMPA_H,ACCESS
;exit sub
	return
;end if
ENDIF36
;Main calc routine
;SysDivLoop = 16
	movlw	16
	movwf	SYSDIVLOOP,ACCESS
SYSDIV16START
;set C off
	bcf	STATUS,C,ACCESS
;Rotate SysDivMultA Left
	rlcf	SYSDIVMULTA,F,ACCESS
	rlcf	SYSDIVMULTA_H,F,ACCESS
;Rotate SysDivMultX Left
	rlcf	SYSDIVMULTX,F,ACCESS
	rlcf	SYSDIVMULTX_H,F,ACCESS
;SysDivMultX = SysDivMultX - SysDivMultB
	movf	SYSDIVMULTB,W,ACCESS
	subwf	SYSDIVMULTX,F,ACCESS
	movf	SYSDIVMULTB_H,W,ACCESS
	subwfb	SYSDIVMULTX_H,F,ACCESS
;Set SysDivMultA.0 On
	bsf	SYSDIVMULTA,0,ACCESS
;If C Off Then
	btfsc	STATUS,C,ACCESS
	bra	ENDIF37
;Set SysDivMultA.0 Off
	bcf	SYSDIVMULTA,0,ACCESS
;SysDivMultX = SysDivMultX + SysDivMultB
	movf	SYSDIVMULTB,W,ACCESS
	addwf	SYSDIVMULTX,F,ACCESS
	movf	SYSDIVMULTB_H,W,ACCESS
	addwfc	SYSDIVMULTX_H,F,ACCESS
;End If
ENDIF37
;decfsz SysDivLoop, F
	decfsz	SYSDIVLOOP, F,ACCESS
;goto SysDiv16Start
	bra	SYSDIV16START
;SysWordTempA = SysDivMultA
	movff	SYSDIVMULTA,SYSWORDTEMPA
	movff	SYSDIVMULTA_H,SYSWORDTEMPA_H
;SysWordTempX = SysDivMultX
	movff	SYSDIVMULTX,SYSWORDTEMPX
	movff	SYSDIVMULTX_H,SYSWORDTEMPX_H
	return

;********************************************************************************

;Source: system.h (2212)
SYSMULTSUB16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;X = LowA * LowB
;movf SysWordTempA, W
	movf	SYSWORDTEMPA, W,ACCESS
;mulwf SysWordTempB
	mulwf	SYSWORDTEMPB,ACCESS
;movff PRODL, SysWordTempX
	movffl	PRODL,SYSWORDTEMPX
;movff PRODH, SysWordTempX_H
	movffl	PRODH,SYSWORDTEMPX_H
;HighX += LowA * HighB
;movf SysWordTempA, W
	movf	SYSWORDTEMPA, W,ACCESS
;mulwf SysWordTempB_H
	mulwf	SYSWORDTEMPB_H,ACCESS
;movf PRODL, W
	movf	PRODL, W,ACCESS
;addwf SysWordTempX_H, F
	addwf	SYSWORDTEMPX_H, F,ACCESS
;HighX += HighA * LowB
;movf SysWordTempA_H, W
	movf	SYSWORDTEMPA_H, W,ACCESS
;mulwf SysWordTempB
	mulwf	SYSWORDTEMPB,ACCESS
;movf PRODL, W
	movf	PRODL, W,ACCESS
;addwf SysWordTempX_H, F
	addwf	SYSWORDTEMPX_H, F,ACCESS
;PRODL = HighA * HighB
;movf SysWordTempA_H, F
	movf	SYSWORDTEMPA_H, F,ACCESS
;mulwf SysWordTempB_H
	mulwf	SYSWORDTEMPB_H,ACCESS
	return

;********************************************************************************


 END
