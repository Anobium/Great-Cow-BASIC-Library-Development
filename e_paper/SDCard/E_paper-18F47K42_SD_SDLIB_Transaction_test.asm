;Program compiled by Great Cow BASIC (0.98.<<>> 2019-12-08 (Windows 32 bit))
;Need help? See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;check the documentation or email w_cholmondeley at users dot sourceforge dot net.

;********************************************************************************

;Set up the assembler options (Chip type, clock source, other bits and pieces)
 LIST p=18F47K42, r=DEC
#include <P18F47K42.inc>
 CONFIG CP = OFF, LVP = OFF, WRTD = OFF, WDTE = OFF, MVECEN = OFF, MCLRE = EXTMCLR, CLKOUTEN = OFF, RSTOSC = HFINTOSC_1MHZ, FEXTOSC = OFF

;********************************************************************************

;Set aside memory locations for variables
ARG	EQU	13
ARG_E	EQU	16
ARG_H	EQU	14
ARG_U	EQU	15
CODE	EQU	17
COMPORT	EQU	18
CRC	EQU	19
CRLF1	EQU	20
CRLF2	EQU	21
DATAVAR	EQU	22
DELAYTEMP	EQU	0
DELAYTEMP2	EQU	1
DRAWLINE	EQU	23
DRAWLINE_H	EQU	24
EPD2IN13DADDRESSTYPE	EQU	25
EPD2IN13D_COMMAND	EQU	26
EPD2IN13D_DATA	EQU	27
EPD_BUFFER	EQU	7983
EPD_COUNTER	EQU	28
EPD_IND	EQU	29
EPD_IND_COL	EQU	31
EPD_IND_COL_H	EQU	32
EPD_IND_H	EQU	30
EPD_IND_RAW	EQU	33
EPD_IND_RAW_H	EQU	34
EPD_IND_TRANS	EQU	35
EPD_IND_TRANS_H	EQU	36
EPD_N_COL	EQU	37
EPD_N_COL_H	EQU	38
EPD_N_RAW	EQU	39
EPD_N_RAW_H	EQU	40
FILE_SYSTEM_VER_NUM	EQU	41
GLCDBACKGROUND	EQU	42
GLCDBACKGROUND_H	EQU	43
GLCDCOLOUR	EQU	44
GLCDCOLOUR_H	EQU	45
GLCDDATATEMP	EQU	46
GLCDDATATEMP_H	EQU	47
GLCDDEVICEHEIGHT	EQU	48
GLCDDEVICEHEIGHT_H	EQU	49
GLCDDEVICEWIDTH	EQU	50
GLCDDEVICEWIDTH_H	EQU	51
GLCDFNTDEFAULT	EQU	52
GLCDFNTDEFAULTHEIGHT	EQU	53
GLCDFNTDEFAULTSIZE	EQU	54
GLCDFONTWIDTH	EQU	55
GLCDFOREGROUND	EQU	56
GLCDFOREGROUND_H	EQU	57
GLCDTEMP	EQU	58
GLCDTEMP_H	EQU	59
GLCDX	EQU	60
GLCDX_H	EQU	61
GLCDY	EQU	62
GLCDY_H	EQU	63
GLCD_TIME_BUFF	EQU	64
GLCD_TIME_BUFF_H	EQU	65
GLCD_YORDINATE	EQU	66
GLCD_YORDINATE_H	EQU	67
HSERPRINTCRLFCOUNT	EQU	68
LINECOLOUR	EQU	69
LINECOLOUR_H	EQU	70
LINEX1	EQU	71
LINEX1_H	EQU	72
LINEX2	EQU	73
LINEX2_H	EQU	74
LINEY1	EQU	75
LINEY1_H	EQU	76
LINEY2	EQU	77
LINEY2_H	EQU	78
LOWERPAGE	EQU	79
NRESPONSE	EQU	80
N_BYTES	EQU	81
PRINTLEN	EQU	82
PRINTLOCX	EQU	83
PRINTLOCX_H	EQU	84
PRINTLOCY	EQU	85
PRINTLOCY_H	EQU	86
REMAINDER	EQU	87
SDDATA	EQU	88
SDRESP	EQU	89
SDRESPONSE	EQU	90
SD_COUNTER	EQU	91
SD_COUNTER_H	EQU	92
SERDATA	EQU	93
SPICLOCKMODE	EQU	94
SPICURRENTMODE	EQU	95
SPIRXDATA	EQU	96
SPITXDATA	EQU	97
STRINGPOINTER	EQU	98
SYSBYTETEMPA	EQU	5
SYSBYTETEMPB	EQU	9
SYSBYTETEMPX	EQU	0
SYSCALCTEMPA	EQU	5
SYSDIVLOOP	EQU	4
SYSDIVMULTA	EQU	7
SYSDIVMULTA_H	EQU	8
SYSDIVMULTB	EQU	11
SYSDIVMULTB_H	EQU	12
SYSDIVMULTX	EQU	2
SYSDIVMULTX_H	EQU	3
SYSINPUTSHANDLER	EQU	99
SYSINPUTSHANDLER_H	EQU	100
SYSPRINTDATAHANDLER	EQU	101
SYSPRINTDATAHANDLER_H	EQU	102
SYSPRINTTEMP	EQU	103
SYSREPEATTEMP1	EQU	104
SYSREPEATTEMP3	EQU	105
SYSREPEATTEMP4	EQU	106
SYSREPEATTEMP5	EQU	107
SYSREPEATTEMP6	EQU	108
SYSREPEATTEMP7	EQU	109
SYSREPEATTEMP8	EQU	110
SYSREPEATTEMP9	EQU	111
SYSSTRINGA	EQU	7
SYSSTRINGAHANDLER	EQU	112
SYSSTRINGAHANDLER_H	EQU	113
SYSSTRINGA_H	EQU	8
SYSSTRINGLENGTH	EQU	6
SYSSTRINGPARAM1	EQU	7968
SYSSTRINGPARAM2	EQU	7942
SYSSTRINGPARAM3	EQU	7953
SYSTEMP1	EQU	114
SYSTEMP1_H	EQU	115
SYSTEMP2	EQU	116
SYSTEMP2_H	EQU	117
SYSWAITTEMPMS	EQU	2
SYSWAITTEMPMS_H	EQU	3
SYSWORDTEMPA	EQU	5
SYSWORDTEMPA_H	EQU	6
SYSWORDTEMPB	EQU	9
SYSWORDTEMPB_H	EQU	10
SYSWORDTEMPX	EQU	0
SYSWORDTEMPX_H	EQU	1
UPPERPAGE	EQU	118
_GLCDPAGE	EQU	119
_GLCDPAGESH	EQU	120
_GLCDPAGESL	EQU	121

;********************************************************************************

;Alias variables
AFSR0	EQU	16361
AFSR0_H	EQU	16362

;********************************************************************************

;Vectors
	ORG	0
	goto	BASPROGRAMSTART
	ORG	8
	retfie

;********************************************************************************

;Start of program memory page 0
	ORG	12
BASPROGRAMSTART
;Call initialisation routines
	rcall	INITSYS
	rcall	INITPPS
	rcall	INITUSART
	rcall	INIT_EPD2IN13D

;Start of the main program
;''A demonstration program for Explicit-Paper.
;''-------------------------------------------------------------------------
;-------------------------------------------------------
;''This has been tested using the hardware and software SPI option.
;''*************************************************************************
;*******
;Chip Settings.
;#define clock_freq 64
;
;Generated by PIC PPS Tool for Great Cow Basic
;PPS Tool version: 0.0.5.25
;PinManager data: Not available (3)
;Generated for 18f25k42
;
;Template comment at the start of the config file
;
;#define PPSToolPart 18F45k42
;______________
;USART
;#define USART_BAUD_RATE 57600'9600
;#define USART_DELAY     5 ms
;#define USART_BLOCKING
;Set pin USART directions
;Dir portC.7 IN
	bsf	TRISC,7,ACCESS
;Dir portC.6 OUT
	bcf	TRISC,6,ACCESS
;******************************************************************************************************
;The following should be used   '#define EPD_EPD2in13D_HardwareSPI     'remove comment out if you want to use software SPI.
;#define EPD2in13D_HardwareSPI
;#define SD_HardwareSPI
;#define SPI_BAUD_RATE_REGISTER 7 '**********||||||****|||****|
;***************************************************************************
;***************************
;Setup the E-Paper
;#include <xpt2046.h>    'include per il touch driver di ili9341
;#define GLCD_TYPE GLCD_TYPE_EPD_EPD2in13D
;#define GLCD_EXTENDEDFONTSET1
;NONE GLCD_TYPE_EPD2in13D_LOWMEMORYx_GLCD_MODE def.==>'BuffWidth=2756,n_page=1
;#define GLCD_TYPE_EPD2in13D_LOWMEMORY1_GLCD_MODE ON  'BuffWidth=13,  n_page=212
;#define GLCD_TYPE_EPD2in13D_LOWMEMORY2_GLCD_MODE ON  'BuffWidth=104, n_page=26
;#define GLCD_TYPE_EPD2in13D_LOWMEMORY3_GLCD_MODE ON  'BuffWidth=208, n_page=13
;#define GLCD_TYPE_EPD2in13D_LOWMEMORY4_GLCD_MODE ON  'BuffWidth=1378,n_page=2
;Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
;ERV These need to GLCD_DC ETC = was wrong naming convention
;#define GLCD_DC     portA.0   ' Data(hight)/ command(low) line
;#define GLCD_CS     portC.1   ' Chip select line (negate)
;#define GLCD_RESET  portD.2   ' Reset line       (negate)
;#define GLCD_DO     portC.5   ' GLCD MOSI connect to MCU SDO
;#define GLCD_SCK    portC.3   ' Clock Line
;#define GLCD_Busy   portC.0   ' Busy Line
;--------------*-----------------*------------------*-----------------*--
;Setup SD pins (sono presenti sia l'EPD2in13D card adapter che
;un HW SD Card Adapter chip)
;#define SD_Adaper_CS  portD.7   ' SD-Adapter select line
;#define SD_DO         portC.5   ' MOSI connect to MCU SDO
;#define SD_SCK        portC.3   ' Clock Line
;#define SD_DI         portC.4   ' MISO connect to MCU SDI
;Dir     SD_Adaper_CS  OUT
	bcf	TRISD,7,ACCESS
;Dir     SD_DO         OUT
	bcf	TRISC,5,ACCESS
;Dir     SD_SCK        OUT
	bcf	TRISC,3,ACCESS
;Dir     SD_DI         IN
	bsf	TRISC,4,ACCESS
;GLCDRotate ( Landscape_rev )     ' optionally you can rotate the screen.
;Dim Inf_Addr_Buff, SDBuff_ind  as word
;Dim Main_counter, Main_Counter1, Main_Counter2, Main_Counter3 as Word
;Dim Main_Ind, Main_Ind_trans as word
;Dim Main_MyString, Main_MyString1 as String
;******************************************************************************************************
;Main program
;dim upperPage, lowerPage as Byte
;upperPage = 0
	clrf	UPPERPAGE,BANKED
;lowerPage = EPD_N_PAGE-1
	movlw	12
	movwf	LOWERPAGE,ACCESS
;SET SD_Adaper_CS ON
	bsf	LATD,7,ACCESS
;SET GLCD_CS ON
	bsf	LATC,1,ACCESS
;HSERPRINT "initialization"; HSerPrintCRLF
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable3
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable3
	movwf	TBLPTRH,ACCESS
	movlw	upper StringTable3
	movwf	TBLPTRU,ACCESS
	call	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,BANKED
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,BANKED
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT712
;CallCMD0                      'Card Initialization
	rcall	CALLCMD0
;HSERPRINT "CMD0 Executed"
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable4
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable4
	movwf	TBLPTRH,ACCESS
	movlw	upper StringTable4
	movwf	TBLPTRU,ACCESS
	call	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,BANKED
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,BANKED
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT712
;SET SD_Adaper_CS ON
	bsf	LATD,7,ACCESS
;SET GLCD_CS OFF
	bcf	LATC,1,ACCESS
;GLCD_Open_PageTransaction ( upperPage, lowerPage )
;Macro Source: epd_epd2in13d.h (960)
;dim _GLCDPage as byte
;dim _GLCDPagesL, _GLCDPagesH as byte
;Clear_buffer_EPD2in13D
	rcall	CLEAR_BUFFER_EPD2IN13D
;for _GLCDPage = _GLCDPagesL to _GLCDPagesH    '_GLCDPage is a global variable - DO NOT CHANGE!!!
	decf	UPPERPAGE,W,BANKED
	movwf	_GLCDPAGE,BANKED
	movf	UPPERPAGE,W,BANKED
	subwf	LOWERPAGE,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoopEnd1
SysForLoop1
	incf	_GLCDPAGE,F,BANKED
;GLCDLocateString 0,0
	clrf	PRINTLOCX,ACCESS
	clrf	PRINTLOCX_H,ACCESS
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
	rcall	GLCDLOCATESTRING
;Box_example
	rcall	BOX_EXAMPLE
;GLCD_Close_PageTransaction                 'Close Transaction
;Macro Source: epd_epd2in13d.h (973)
;Pixel_To_Display_EPD2in13D
	call	PIXEL_TO_DISPLAY_EPD2IN13D
;next
	movf	LOWERPAGE,W,ACCESS
	subwf	_GLCDPAGE,W,BANKED
	btfss	STATUS, C,ACCESS
	bra	SysForLoop1
SysForLoopEnd1
;SendCommand_EPD2in13D(DISPLAY_REFRESH)
	movlw	18
	movwf	EPD2IN13D_COMMAND,ACCESS
	call	SENDCOMMAND_EPD2IN13D
;End
	bra	BASPROGRAMEND
;spi constant used equates to 12
	movlw	12
	movwf	SPICURRENTMODE,ACCESS
	clrf	SPICLOCKMODE,ACCESS
	call	SPIMODE667
BASPROGRAMEND
	sleep
	bra	BASPROGRAMEND

;********************************************************************************

;Source: glcd.h (1395)
BOX
;dim GLCDTemp as word
;Make sure that starting point (1) is always less than end point (2)
;If LineX1 > LineX2 Then
	movff	LINEX1,SysWORDTempB
	movff	LINEX1_H,SysWORDTempB_H
	movff	LINEX2,SysWORDTempA
	movff	LINEX2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF4
;GLCDTemp = LineX1
	movff	LINEX1,GLCDTEMP
	movff	LINEX1_H,GLCDTEMP_H
;LineX1 = LineX2
	movff	LINEX2,LINEX1
	movff	LINEX2_H,LINEX1_H
;LineX2 = GLCDTemp
	movff	GLCDTEMP,LINEX2
	movff	GLCDTEMP_H,LINEX2_H
;End If
ENDIF4
;If LineY1 > LineY2 Then
	movff	LINEY1,SysWORDTempB
	movff	LINEY1_H,SysWORDTempB_H
	movff	LINEY2,SysWORDTempA
	movff	LINEY2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF5
;GLCDTemp = LineY1
	movff	LINEY1,GLCDTEMP
	movff	LINEY1_H,GLCDTEMP_H
;LineY1 = LineY2
	movff	LINEY2,LINEY1
	movff	LINEY2_H,LINEY1_H
;LineY2 = GLCDTemp
	movff	GLCDTEMP,LINEY2
	movff	GLCDTEMP_H,LINEY2_H
;End If
ENDIF5
;dim DrawLine as word
;Draw lines going across
;For DrawLine = LineX1 To LineX2
	movlw	1
	subwf	LINEX1,W,ACCESS
	movwf	DRAWLINE,ACCESS
	movlw	0
	subwfb	LINEX1_H,W,ACCESS
	movwf	DRAWLINE_H,ACCESS
	movff	LINEX1,SysWORDTempB
	movff	LINEX1_H,SysWORDTempB_H
	movff	LINEX2,SysWORDTempA
	movff	LINEX2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoopEnd2
SysForLoop2
	incf	DRAWLINE,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	DRAWLINE_H,F,ACCESS
;PSet DrawLine, LineY1, LineColour
	movff	DRAWLINE,GLCDX
	movff	DRAWLINE_H,GLCDX_H
	movff	LINEY1,GLCDY
	movff	LINEY1_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	call	PSET_EPD2IN13D
;PSet DrawLine, LineY2, LineColour
	movff	DRAWLINE,GLCDX
	movff	DRAWLINE_H,GLCDX_H
	movff	LINEY2,GLCDY
	movff	LINEY2_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	call	PSET_EPD2IN13D
;Next
	movff	DRAWLINE,SysWORDTempA
	movff	DRAWLINE_H,SysWORDTempA_H
	movff	LINEX2,SysWORDTempB
	movff	LINEX2_H,SysWORDTempB_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop2
SysForLoopEnd2
;Draw lines going down
;For DrawLine = LineY1 To LineY2
	movlw	1
	subwf	LINEY1,W,ACCESS
	movwf	DRAWLINE,ACCESS
	movlw	0
	subwfb	LINEY1_H,W,ACCESS
	movwf	DRAWLINE_H,ACCESS
	movff	LINEY1,SysWORDTempB
	movff	LINEY1_H,SysWORDTempB_H
	movff	LINEY2,SysWORDTempA
	movff	LINEY2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoopEnd3
SysForLoop3
	incf	DRAWLINE,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	DRAWLINE_H,F,ACCESS
;PSet LineX1, DrawLine, LineColour
	movff	LINEX1,GLCDX
	movff	LINEX1_H,GLCDX_H
	movff	DRAWLINE,GLCDY
	movff	DRAWLINE_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	call	PSET_EPD2IN13D
;PSet LineX2, DrawLine, LineColour
	movff	LINEX2,GLCDX
	movff	LINEX2_H,GLCDX_H
	movff	DRAWLINE,GLCDY
	movff	DRAWLINE_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	call	PSET_EPD2IN13D
;Next
	movff	DRAWLINE,SysWORDTempA
	movff	DRAWLINE_H,SysWORDTempA_H
	movff	LINEY2,SysWORDTempB
	movff	LINEY2_H,SysWORDTempB_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop3
SysForLoopEnd3
	return

;********************************************************************************

;Source: E_paper-18F47K42_SD_SDLIB_Transaction_test.gcb (134)
BOX_EXAMPLE
;box 10, 10,GLCD_WIDTH-10, GLCD_HEIGHT-10
	movlw	10
	movwf	LINEX1,ACCESS
	clrf	LINEX1_H,ACCESS
	movlw	10
	movwf	LINEY1,ACCESS
	clrf	LINEY1_H,ACCESS
	movlw	94
	movwf	LINEX2,ACCESS
	clrf	LINEX2_H,ACCESS
	movlw	202
	movwf	LINEY2,ACCESS
	clrf	LINEY2_H,ACCESS
	movff	GLCDFOREGROUND,LINECOLOUR
	movff	GLCDFOREGROUND_H,LINECOLOUR_H
	rcall	BOX
;box 20, 20,GLCD_WIDTH-20, GLCD_HEIGHT-20
	movlw	20
	movwf	LINEX1,ACCESS
	clrf	LINEX1_H,ACCESS
	movlw	20
	movwf	LINEY1,ACCESS
	clrf	LINEY1_H,ACCESS
	movlw	84
	movwf	LINEX2,ACCESS
	clrf	LINEX2_H,ACCESS
	movlw	192
	movwf	LINEY2,ACCESS
	clrf	LINEY2_H,ACCESS
	movff	GLCDFOREGROUND,LINECOLOUR
	movff	GLCDFOREGROUND_H,LINECOLOUR_H
	rcall	BOX
;box 30, 30,GLCD_WIDTH-30, GLCD_HEIGHT-30
	movlw	30
	movwf	LINEX1,ACCESS
	clrf	LINEX1_H,ACCESS
	movlw	30
	movwf	LINEY1,ACCESS
	clrf	LINEY1_H,ACCESS
	movlw	74
	movwf	LINEX2,ACCESS
	clrf	LINEX2_H,ACCESS
	movlw	182
	movwf	LINEY2,ACCESS
	clrf	LINEY2_H,ACCESS
	movff	GLCDFOREGROUND,LINECOLOUR
	movff	GLCDFOREGROUND_H,LINECOLOUR_H
	rcall	BOX
;Filledbox 40, 40,GLCD_WIDTH-40, GLCD_HEIGHT-40
	movlw	40
	movwf	LINEX1,ACCESS
	clrf	LINEX1_H,ACCESS
	movlw	40
	movwf	LINEY1,ACCESS
	clrf	LINEY1_H,ACCESS
	movlw	64
	movwf	LINEX2,ACCESS
	clrf	LINEX2_H,ACCESS
	movlw	172
	movwf	LINEY2,ACCESS
	clrf	LINEY2_H,ACCESS
	movff	GLCDFOREGROUND,LINECOLOUR
	movff	GLCDFOREGROUND_H,LINECOLOUR_H
	bra	FILLEDBOX_EPD2IN13D

;********************************************************************************

;Source: MySDLib.h (118)
CALLCMD0
;HserPrint "    CMD0"
	lfsr	1,SYSSTRINGPARAM3
	movlw	low StringTable34
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable34
	movwf	TBLPTRH,ACCESS
	movlw	upper StringTable34
	movwf	TBLPTRU,ACCESS
	call	SysReadString
	movlw	low SYSSTRINGPARAM3
	movwf	SysPRINTDATAHandler,BANKED
	movlw	high SYSSTRINGPARAM3
	movwf	SysPRINTDATAHandler_H,BANKED
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT712
;SET SD_Adaper_CS OFF
	bcf	LATD,7,ACCESS
;wait 500 ms
	movlw	244
	movwf	SysWaitTempMS,ACCESS
	movlw	1
	movwf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SET SD_Adaper_CS ON
	bsf	LATD,7,ACCESS
;sembra necessario
;do while SDResponse <> 0x01
SysDoLoop_S1
	decf	SDRESPONSE,W,ACCESS
	btfsc	STATUS, Z,ACCESS
	bra	SysDoLoop_E1
;SD_Counter=0
	clrf	SD_COUNTER,ACCESS
	clrf	SD_COUNTER_H,ACCESS
;SET SD_Adaper_CS ON
	bsf	LATD,7,ACCESS
;SendDummyBytes (10)         'lascia SD_Adaper_CS Off
	movlw	10
	movwf	N_BYTES,ACCESS
	call	SENDDUMMYBYTES
;wait 50 ms
	movlw	50
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand(0x40, 0x00000000, 0x95)
	movlw	64
	movwf	CODE,ACCESS
	clrf	ARG,ACCESS
	clrf	ARG_H,ACCESS
	clrf	ARG_U,ACCESS
	clrf	ARG_E,ACCESS
	movlw	149
	movwf	CRC,ACCESS
	call	SENDCOMMAND
;do while SDResponse <> 0x01 and SD_Counter<50
SysDoLoop_S2
	movff	sdresponse,SysBYTETempA
	movlw	1
	movwf	SysBYTETempB,ACCESS
	call	SysCompEqual
	comf	SysByteTempX,F,ACCESS
	movff	SysByteTempX,SysTemp1
	movff	sd_counter,SysWORDTempA
	movff	sd_counter_H,SysWORDTempA_H
	movlw	50
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	movf	SysTemp1,W,BANKED
	andwf	SysByteTempX,W,ACCESS
	movwf	SysTemp2,BANKED
	btfss	SysTemp2,0,BANKED
	bra	SysDoLoop_E2
;GetSDResponse(1,SDResponse)
	movlw	1
	movwf	NRESPONSE,ACCESS
	movff	SDRESPONSE,SDRESP
	rcall	GETSDRESPONSE
	movff	SDRESP,SDRESPONSE
;Loop
	bra	SysDoLoop_S2
SysDoLoop_E2
;Loop
	bra	SysDoLoop_S1
SysDoLoop_E1
;SET SD_Adaper_CS ON
	bsf	LATD,7,ACCESS
;sertxd(1,"-CMD0 ","  Executed",0)
	movlw	1
	movwf	CRLF1,ACCESS
	lfsr	1,SYSSTRINGPARAM3
	movlw	low StringTable35
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable35
	movwf	TBLPTRH,ACCESS
	movlw	upper StringTable35
	movwf	TBLPTRU,ACCESS
	call	SysReadString
	movlw	low SYSSTRINGPARAM3
	movwf	SysSTRINGAHandler,BANKED
	movlw	high SYSSTRINGPARAM3
	movwf	SysSTRINGAHandler_H,BANKED
	lfsr	1,SYSSTRINGPARAM2
	movlw	low StringTable36
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable36
	movwf	TBLPTRH,ACCESS
	movlw	upper StringTable36
	movwf	TBLPTRU,ACCESS
	call	SysReadString
	movlw	low SYSSTRINGPARAM2
	movwf	SysINPUTSHandler,BANKED
	movlw	high SYSSTRINGPARAM2
	movwf	SysINPUTSHandler_H,BANKED
	clrf	CRLF2,ACCESS
	goto	SERTXD3

;********************************************************************************

;Source: epd_epd2in13d.h (477)
CLEAR_BUFFER_EPD2IN13D
;initialise global variable. Required variable for Circle - DO NOT DELETE
;GLCD_yordinate = 0
	clrf	GLCD_YORDINATE,ACCESS
	clrf	GLCD_YORDINATE_H,ACCESS
;Dim EPD_Ind_raw, EPD_Ind_col as word
;Dim PrintLocX, PrintLocY as word
;PrintLocX = 0
	clrf	PRINTLOCX,ACCESS
	clrf	PRINTLOCX_H,ACCESS
;PrintLocY = 0
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
;Dim EPD_Ind_raw as Word
;for EPD_Ind_raw=1 to BUFFWIDTH                 'clear the buffer
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop7
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;EPD_Buffer(EPD_Ind_raw)=GLCDBackground
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_RAW,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_RAW_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	GLCDBACKGROUND,INDF0
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	208
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop7
SysForLoopEnd7
	return

;********************************************************************************

;Source: epd_epd2in13d.h (417)
CLS_EPD2IN13D
;CLS_EPD2in13D_init
	rcall	CLS_EPD2IN13D_INIT
;Refresh_EPD2in13D
	goto	REFRESH_EPD2IN13D

;********************************************************************************

;Source: epd_epd2in13d.h (367)
CLS_EPD2IN13D_INIT
;initialise global variable. Required variable for Circle - DO NOT DELETE
;GLCD_yordinate = 0
	clrf	GLCD_YORDINATE,ACCESS
	clrf	GLCD_YORDINATE_H,ACCESS
;Dim EPD_Ind_raw, EPD_Ind_col as word
;Dim PrintLocX, PrintLocY as word
;PrintLocX = 0
	clrf	PRINTLOCX,ACCESS
	clrf	PRINTLOCX_H,ACCESS
;PrintLocY = 0
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
;For EPD_Ind_raw=1 to BUFFWIDTH
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop16
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;EPD_Buffer(EPD_Ind_raw)=GLCDBackground
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_RAW,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_RAW_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	GLCDBACKGROUND,INDF0
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	208
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop16
SysForLoopEnd16
;Clear down "OLD" data
;SendCommand_EPD2in13D(Data_Transmission_1)
	movlw	16
	movwf	EPD2IN13D_COMMAND,ACCESS
	call	SENDCOMMAND_EPD2IN13D
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;for EPD_Ind_raw=1 to GLCD_Height
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop17
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;for EPD_Ind_col=1 to GLCD_Width
	clrf	EPD_IND_COL,ACCESS
	clrf	EPD_IND_COL_H,ACCESS
SysForLoop18
	incf	EPD_IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_COL_H,F,ACCESS
;Was.. speed optimised with macro              SendData_EPD2in13D(GLCDBackGround)
;EPD2in13D_Data = GLCDBackGround
	movff	GLCDBACKGROUND,EPD2IN13D_DATA
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (560)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp9,BANKED
SysRepeatLoop9
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE52_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF52
ELSE52_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF52
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp9,F,BANKED
	bra	SysRepeatLoop9
SysRepeatLoopEnd9
;next
	movff	EPD_IND_COL,SysWORDTempA
	movff	EPD_IND_COL_H,SysWORDTempA_H
	movlw	104
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop18
SysForLoopEnd18
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	212
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop17
SysForLoopEnd17
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
;wait 10 ms
	movlw	10
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;Clear down "NEW" data
;SendCommand_EPD2in13D(Data_Transmission_2)
	movlw	19
	movwf	EPD2IN13D_COMMAND,ACCESS
	call	SENDCOMMAND_EPD2IN13D
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;for EPD_Ind_raw=1 to GLCD_Height
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop19
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;for EPD_Ind_col=1 to GLCD_Width
	clrf	EPD_IND_COL,ACCESS
	clrf	EPD_IND_COL_H,ACCESS
SysForLoop20
	incf	EPD_IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_COL_H,F,ACCESS
;Was.. speed optimised with macro              SendData_EPD2in13D(GLCDBackGround)
;EPD2in13D_Data = GLCDBackGround
	movff	GLCDBACKGROUND,EPD2IN13D_DATA
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (560)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp9,BANKED
SysRepeatLoop10
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE55_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF55
ELSE55_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF55
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp9,F,BANKED
	bra	SysRepeatLoop10
SysRepeatLoopEnd10
;next
	movff	EPD_IND_COL,SysWORDTempA
	movff	EPD_IND_COL_H,SysWORDTempA_H
	movlw	104
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop20
SysForLoopEnd20
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	212
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop19
SysForLoopEnd19
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
;wait 10 ms
	movlw	10
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	bra	Delay_MS

;********************************************************************************

Delay_MS
	incf	SysWaitTempMS_H, F,ACCESS
DMS_START
	movlw	129
	movwf	DELAYTEMP2,ACCESS
DMS_OUTER
	movlw	40
	movwf	DELAYTEMP,ACCESS
DMS_INNER
	decfsz	DELAYTEMP, F,ACCESS
	bra	DMS_INNER
	decfsz	DELAYTEMP2, F,ACCESS
	bra	DMS_OUTER
	decfsz	SysWaitTempMS, F,ACCESS
	bra	DMS_START
	decfsz	SysWaitTempMS_H, F,ACCESS
	bra	DMS_START
	return

;********************************************************************************

;Source: epd_epd2in13d.h (894)
FILLEDBOX_EPD2IN13D
;Make sure that starting point (1) is always less than end point (2)
;Dim EPD_Ind_raw, EPD_Ind_col as Word
;If LineX1 > LineX2 Then
	movff	LINEX1,SysWORDTempB
	movff	LINEX1_H,SysWORDTempB_H
	movff	LINEX2,SysWORDTempA
	movff	LINEX2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF29
;GLCDTemp = LineX1
	movff	LINEX1,GLCDTEMP
;LineX1 = LineX2
	movff	LINEX2,LINEX1
	movff	LINEX2_H,LINEX1_H
;LineX2 = GLCDTemp
	movff	GLCDTEMP,LINEX2
	clrf	LINEX2_H,ACCESS
;End If
ENDIF29
;If LineY1 > LineY2 Then
	movff	LINEY1,SysWORDTempB
	movff	LINEY1_H,SysWORDTempB_H
	movff	LINEY2,SysWORDTempA
	movff	LINEY2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF30
;GLCDTemp = LineY1
	movff	LINEY1,GLCDTEMP
;LineY1 = LineY2
	movff	LINEY2,LINEY1
	movff	LINEY2_H,LINEY1_H
;LineY2 = GLCDTemp
	movff	GLCDTEMP,LINEY2
	clrf	LINEY2_H,ACCESS
;End If
ENDIF30
;for EPD_Ind_raw=LineY1  to LineY2
	movlw	1
	subwf	LINEY1,W,ACCESS
	movwf	EPD_IND_RAW,ACCESS
	movlw	0
	subwfb	LINEY1_H,W,ACCESS
	movwf	EPD_IND_RAW_H,ACCESS
	movff	LINEY1,SysWORDTempB
	movff	LINEY1_H,SysWORDTempB_H
	movff	LINEY2,SysWORDTempA
	movff	LINEY2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoopEnd8
SysForLoop8
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;for EPD_Ind_col=LineX1 to lineX2
	movlw	1
	subwf	LINEX1,W,ACCESS
	movwf	EPD_IND_COL,ACCESS
	movlw	0
	subwfb	LINEX1_H,W,ACCESS
	movwf	EPD_IND_COL_H,ACCESS
	movff	LINEX1,SysWORDTempB
	movff	LINEX1_H,SysWORDTempB_H
	movff	LINEX2,SysWORDTempA
	movff	LINEX2_H,SysWORDTempA_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoopEnd9
SysForLoop9
	incf	EPD_IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_COL_H,F,ACCESS
;PSet(EPD_Ind_Col, EPD_Ind_raw, LineColour)
	movff	EPD_IND_COL,GLCDX
	movff	EPD_IND_COL_H,GLCDX_H
	movff	EPD_IND_RAW,GLCDY
	movff	EPD_IND_RAW_H,GLCDY_H
	movff	LINECOLOUR,GLCDCOLOUR
	movff	LINECOLOUR_H,GLCDCOLOUR_H
	rcall	PSET_EPD2IN13D
;next
	movff	EPD_IND_COL,SysWORDTempA
	movff	EPD_IND_COL_H,SysWORDTempA_H
	movff	LINEX2,SysWORDTempB
	movff	LINEX2_H,SysWORDTempB_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop9
SysForLoopEnd9
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movff	LINEY2,SysWORDTempB
	movff	LINEY2_H,SysWORDTempB_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop8
SysForLoopEnd8
	return

;********************************************************************************

;Source: MySDLib.h (108)
GETSDRESPONSE
;Dim SDResp as Byte
;repeat NResponse
	movff	NRESPONSE,SysRepeatTemp6
	movf	SYSREPEATTEMP6,F,BANKED
	btfsc	STATUS, Z,ACCESS
	bra	SysRepeatLoopEnd6
SysRepeatLoop6
;SPITransfer 255, SDResp
	setf	SPITXDATA,BANKED
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDRESP
;end Repeat
	decfsz	SysRepeatTemp6,F,BANKED
	bra	SysRepeatLoop6
SysRepeatLoopEnd6
	return

;********************************************************************************

;Source: glcd.h (1171)
GLCDLOCATESTRING
;dim PrintLocY as word
;if PrintLocY < 2 then
	movff	PRINTLOCY,SysWORDTempA
	movff	PRINTLOCY_H,SysWORDTempA_H
	movlw	2
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysCompLessThan16
	btfss	SysByteTempX,0,ACCESS
	bra	ELSE3_1
;PrintLocY = 0
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
;else
	bra	ENDIF3
ELSE3_1
;PrintLocY--
	movlw	1
	subwf	PRINTLOCY,F,ACCESS
	movlw	0
	subwfb	PRINTLOCY_H,F,ACCESS
;PrintLocY = ( PrintLocY * ( GLCDfntDefaultHeight * GLCDfntDefaultSize ) ) mod EPD_CORRECTED_HEIGHT
	movf	GLCDFNTDEFAULTHEIGHT,W,ACCESS
	mulwf	GLCDFNTDEFAULTSIZE,ACCESS
	movffl	PRODL,SysTemp1
	movff	PRINTLOCY,SysWORDTempA
	movff	PRINTLOCY_H,SysWORDTempA_H
	movff	SysTemp1,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	call	SysMultSub16
	movff	SysWORDTempX,SysTemp2
	movff	SysWORDTempX_H,SysTemp2_H
	movff	SysTemp2,SysWORDTempA
	movff	SysTemp2_H,SysWORDTempA_H
	movlw	208
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	call	SysDivSub16
	movff	SysWORDTempX,PRINTLOCY
	movff	SysWORDTempX_H,PRINTLOCY_H
;end if
ENDIF3
	return

;********************************************************************************

;Overloaded signature: STRING:byte:, Source: usart.h (1251)
HSERPRINT712
;PrintLen = PrintData(0)
	movffl	SysPRINTDATAHandler,AFSR0
	movffl	SysPRINTDATAHandler_H,AFSR0_H
	movffl	INDF0,PRINTLEN
;If PrintLen <> 0 then
	movf	PRINTLEN,F,ACCESS
	btfsc	STATUS, Z,ACCESS
	bra	ENDIF39
;Write Data
;for SysPrintTemp = 1 to PrintLen
	clrf	SYSPRINTTEMP,BANKED
	movlw	1
	subwf	PRINTLEN,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoopEnd10
SysForLoop10
	incf	SYSPRINTTEMP,F,BANKED
;HSerSend(PrintData(SysPrintTemp),comport )
	movf	SYSPRINTTEMP,W,BANKED
	addwf	SysPRINTDATAHandler,W,BANKED
	movwf	AFSR0,ACCESS
	movlw	0
	addwfc	SysPRINTDATAHandler_H,W,BANKED
	movwf	AFSR0_H,ACCESS
	movffl	INDF0,SERDATA
	rcall	HSERSEND702
;next
	movf	PRINTLEN,W,ACCESS
	subwf	SYSPRINTTEMP,W,BANKED
	btfss	STATUS, C,ACCESS
	bra	SysForLoop10
SysForLoopEnd10
;End If
ENDIF39
;CR
	return

;********************************************************************************

;Source: usart.h (1403)
HSERPRINTCRLF
;repeat HSerPrintCRLFCount
	movff	HSERPRINTCRLFCOUNT,SysRepeatTemp8
	movf	SYSREPEATTEMP8,F,BANKED
	btfsc	STATUS, Z,ACCESS
	bra	SysRepeatLoopEnd8
SysRepeatLoop8
;HSerSend(13,comport)
	movlw	13
	movwf	SERDATA,ACCESS
	rcall	HSERSEND702
;HSerSend(10,comport)
	movlw	10
	movwf	SERDATA,ACCESS
	rcall	HSERSEND702
;end Repeat
	decfsz	SysRepeatTemp8,F,BANKED
	bra	SysRepeatLoop8
SysRepeatLoopEnd8
	return

;********************************************************************************

;Overloaded signature: BYTE:, Source: usart.h (653)
HSERSEND701
;Registers/Bits determined by #samevar at top of library
;USART_BLOCKING and NOT USART_TX_BLOCKING
;Wait While TXIF = Off
SysWaitLoop2
	banksel	PIR3
	btfss	PIR3,U1TXIF,BANKED
	bra	SysWaitLoop2
;Write the data byte to the USART.
;Sets register to value of SerData - where register could be TXREG or TXREG1 or U1TXB set via the #samevar
;TXREG = SerData
	movffl	SERDATA,U1TXB
;Wait until TRMT = 1
SysWaitLoop3
	banksel	U1ERRIR
	btfss	U1ERRIR,TXMTIF,BANKED
	bra	SysWaitLoop3
;Add USART_DELAY after the byte is sent by the USART module
;Wait USART_DELAY
	movlw	5
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	banksel	0
	bra	Delay_MS

;********************************************************************************

;Overloaded signature: BYTE:byte:, Source: usart.h (736)
HSERSEND702
;Registers/Bits determined by #samevar at top of library
;if comport = 1 Then
	decf	COMPORT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF50
;USART_BLOCKING and NOT USART_TX_BLOCKING
;Wait While TXIF = Off
SysWaitLoop4
	banksel	PIR3
	btfss	PIR3,U1TXIF,BANKED
	bra	SysWaitLoop4
;Write the data byte to the USART.
;Sets register to value of SerData - where register could be TXREG or TXREG1 or U1TXB set via the #samevar
;TXREG = SerData
	movffl	SERDATA,U1TXB
;Add USART_DELAY after the byte is sent by the USART module
;Wait until TRMT = 1
SysWaitLoop5
	banksel	U1ERRIR
	btfss	U1ERRIR,TXMTIF,BANKED
	bra	SysWaitLoop5
;Wait USART_DELAY
	movlw	5
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	banksel	0
	rcall	Delay_MS
;exit now to exit asap, if you have more than one comport in use there is no point in processing
;exit sub
	return
;end if
ENDIF50
	return

;********************************************************************************

;Source: hwspi.h (595)
HWSPITRANSFER
;One byte transfer count
;SPI1TCNTL = 1
	movlw	1
	banksel	SPI1TCNTL
	movwf	SPI1TCNTL,BANKED
;SPI1TXB = SPITxData
	movffl	SPITXDATA,SPI1TXB
;wait while SPI1RXIF = SPI_RX_IN_PROGRESS
SysWaitLoop1
	banksel	PIR2
	btfss	PIR2,SPI1RXIF,BANKED
	bra	SysWaitLoop1
;SPIRxData = SPI1RXB
	movffl	SPI1RXB,SPIRXDATA
	banksel	0
	return

;********************************************************************************

;Source: E_paper-18F47K42_SD_SDLIB_Transaction_test.gcb (24)
INITPPS
;This has been added to turn off PPS SPI when in SPI software mode
;Module: UART1  (0x.... è in ESADECIMALE)
;U1RXPPS = 0x0017        'RC7 > RX1
	movlw	23
	banksel	U1RXPPS
	movwf	U1RXPPS,BANKED
;RC6PPS  = 0x0013        'TX1 > RC6
	movlw	19
	movwf	RC6PPS,BANKED
;Module: SPI1
;SPI1SDIPPS = 0x0014     'RC4 > SDI1
	movlw	20
	movwf	SPI1SDIPPS,BANKED
;RC5PPS = 0x001F         'SDO1 > RC5
	movlw	31
	movwf	RC5PPS,BANKED
;RC3PPS = 0x001E         'SCK1 > RC3
	movlw	30
	movwf	RC3PPS,BANKED
;SPI1SCKPPS = 0x0013     'RC3 > SCK1 (bi-directional)
	movlw	19
	movwf	SPI1SCKPPS,BANKED
	banksel	0
	return

;********************************************************************************

;Source: system.h (99)
INITSYS
;Set up internal oscillator
;Handle OSCCON1 register for parts that have this register
;asm showdebug OSCCON type is 100 'This is the routine to support OSCCON1 config addresss
;osccon type is 100
;OSCCON1 = 0x60 ' NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
	movlw	96
	banksel	OSCCON1
	movwf	OSCCON1,BANKED
;OSCCON3 = 0x00 ' CSWHOLD may proceed; SOSCPWR Low power
	clrf	OSCCON3,BANKED
;OSCEN = 0x00   ' MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
	clrf	OSCEN,BANKED
;OSCTUNE = 0x00 ' HFTUN 0
	clrf	OSCTUNE,BANKED
;The MCU is a ChipFamily16
;Section support many MCUs, 18FxxK40, 18FxxK42 etc etc all have NDIV3 bit
;asm showdebug OSCCON type is 101 ' ChipFamily16 and NDIV3 bit
;osccon type is 101
;Clear NDIV3:0
;NDIV3 = 0
	bcf	OSCCON1,NDIV3,BANKED
;NDIV2 = 0
	bcf	OSCCON1,NDIV2,BANKED
;NDIV1 = 0
	bcf	OSCCON1,NDIV1,BANKED
;NDIV0 = 0
	bcf	OSCCON1,NDIV0,BANKED
;OSCFRQ = 0b00001000  '64mhz
	movlw	8
	movwf	OSCFRQ,BANKED
;Clear BSR on ChipFamily16 MCUs
;BSR = 0
	clrf	BSR,ACCESS
;Clear TBLPTRU on MCUs with this bit as this must be zero
;TBLPTRU = 0
	clrf	TBLPTRU,ACCESS
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	banksel	ADCON0
	bcf	ADCON0,ADFM0,BANKED
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	bcf	ADCON0,ADON,BANKED
;Commence clearing any ANSEL variants in the part
;ANSELA = 0
	banksel	ANSELA
	clrf	ANSELA,BANKED
;ANSELB = 0
	clrf	ANSELB,BANKED
;ANSELC = 0
	clrf	ANSELC,BANKED
;ANSELD = 0
	clrf	ANSELD,BANKED
;ANSELE = 0
	clrf	ANSELE,BANKED
;End clearing any ANSEL variants in the part
;Set comparator register bits for many MCUs with register CM2CON0
;C2EN = 0
	banksel	CM2CON0
	bcf	CM2CON0,C2EN,BANKED
;C1EN = 0
	bcf	CM1CON0,C1EN,BANKED
;Turn off all ports
;PORTA = 0
	clrf	PORTA,ACCESS
;PORTB = 0
	clrf	PORTB,ACCESS
;PORTC = 0
	clrf	PORTC,ACCESS
;PORTD = 0
	clrf	PORTD,ACCESS
;PORTE = 0
	clrf	PORTE,ACCESS
	banksel	0
	return

;********************************************************************************

;Source: usart.h (454)
INITUSART
;Set the default value for comport
;comport = 1
	movlw	1
	movwf	COMPORT,ACCESS
;Set baud rate for for 18fxxK42/K83 series UART
;U1BRGH=SPBRGH_TEMP
	movlw	1
	banksel	U1BRGH
	movwf	U1BRGH,BANKED
;U1BRGL=SPBRGL_TEMP
	movlw	20
	movwf	U1BRGL,BANKED
;U1BRGS = BRGS1_SCRIPT
	bsf	U1CON0,U1BRGS,BANKED
;U1TXEN=1   'Enable TX1
	bsf	U1CON0,U1TXEN,BANKED
;U1RXEN=1   'Enable RX1
	bsf	U1CON0,U1RXEN,BANKED
;ON_U1CON1=1 'Enable USART1
	bsf	U1CON1,ON_U1CON1,BANKED
	banksel	0
	return

;********************************************************************************

;Source: epd_epd2in13d.h (160)
INIT_EPD2IN13D
;dim _GLCDPagesL, _GLCDPagesH  as byte
;asm showdebug Current_buffer_size_is BUFFWIDTH
;current_buffer_size_is 208
;Dir   EPD_DC     OUT
	bcf	TRISA,0,ACCESS
;Dir   EPD_CS     OUT
	bcf	TRISC,1,ACCESS
;Dir   EPD_RESET  OUT
	bcf	TRISD,2,ACCESS
;Dir   EPD_DO     OUT
	bcf	TRISC,5,ACCESS
;Dir   EPD_SCK    OUT
	bcf	TRISC,3,ACCESS
;Dir   EPD_Busy   IN
	bsf	TRISC,0,ACCESS
;SET EPD_RESET ON
	bsf	LATD,2,ACCESS
;wait 300 ms
	movlw	44
	movwf	SysWaitTempMS,ACCESS
	movlw	1
	movwf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SET EPD_RESET OFF
	bcf	LATD,2,ACCESS
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SET EPD_RESET ON
	bsf	LATD,2,ACCESS
;wait 300 ms
	movlw	44
	movwf	SysWaitTempMS,ACCESS
	movlw	1
	movwf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(BOOSTER_SOFT_START)
	movlw	6
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x17)
	movlw	23
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x17)
	movlw	23
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x17)
	movlw	23
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(POWER_SETTING)
	movlw	1
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x03)
	movlw	3
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x00)
	clrf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x2B)
	movlw	43
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x2B)
	movlw	43
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x03)
	movlw	3
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;wait 200 ms
	movlw	200
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
;SendCommand_EPD2in13D(POWER_ON)
	movlw	4
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendCommand_EPD2in13D(PANEL_SETTING)
	clrf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(PANEL_SETTING_VALUE or PANEL_SETTING_KWR )
	movlw	191
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(PLL_CONTROL)
	movlw	48
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x3C)
	movlw	60
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(RESOLUTION_SETTING)
	movlw	97
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x68)
	movlw	104
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0x00)
	clrf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendData_EPD2in13D(0xD4)
	movlw	212
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(VCM_DC_SETTING)
	movlw	130
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x12)
	movlw	18
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;LoadLUTS_EPD2in13D
	rcall	LOADLUTS_EPD2IN13D
;Colours
;GLCDForeground =TFT_WHITE
	setf	GLCDFOREGROUND,ACCESS
	setf	GLCDFOREGROUND_H,ACCESS
;Default Colours
;GLCDBackground = TFT_BLACK
	clrf	GLCDBACKGROUND,ACCESS
	clrf	GLCDBACKGROUND_H,ACCESS
;GLCDFontWidth = 6
	movlw	6
	movwf	GLCDFONTWIDTH,ACCESS
;GLCDCLS
	rcall	CLS_EPD2IN13D
;Variables required for device
;GLCDDeviceWidth = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;GLCDDeviceHeight= GLCD_HEIGHT- 1
	movlw	211
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDRotate Portrait
	movlw	4
	movwf	EPD2IN13DADDRESSTYPE,ACCESS
	rcall	ROTATE_EPD2IN13D
;GLCDfntDefault = 0
	clrf	GLCDFNTDEFAULT,ACCESS
;GLCDfntDefaultsize = 1
	movlw	1
	movwf	GLCDFNTDEFAULTSIZE,ACCESS
;GLCDfntDefaultHeight = 8
	movlw	8
	movwf	GLCDFNTDEFAULTHEIGHT,ACCESS
;_GLCDPagesH = EPD_N_PAGE - 1
	movlw	12
	movwf	_GLCDPAGESH,BANKED
;_GLCDPagesL = 0
	clrf	_GLCDPAGESL,BANKED
;_GLCDPage = 0
	clrf	_GLCDPAGE,BANKED
	return

;********************************************************************************

;Source: epd_epd2in13d.h (320)
LOADLUTS_EPD2IN13D
;Dim DataVar as byte
;Dim Counter as Word
;SendCommand_EPD2in13D(VCM_DC_SETTING)
	movlw	130
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SendData_EPD2in13D(0x00)
	clrf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(VCOM_AND_DATA_INTERVAL_SETTING)
	movlw	80
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;Mask VCOM_AND_DATA_INTERVAL bits and then Mask the user bits.
;SendData_EPD2in13D( (0x90 AND 0xF0 ) or ( VCOM_AND_DATA_INTERVAL AND 0X0F ))
	movlw	151
	movwf	EPD2IN13D_DATA,ACCESS
	rcall	SENDDATA_EPD2IN13D
;SendCommand_EPD2in13D(0x20) 'VCOM LUT
	movlw	32
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 44
	clrf	EPD_COUNTER,ACCESS
SysForLoop11
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_Vcom, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_VCOM
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	44
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop11
SysForLoopEnd11
;SendCommand_EPD2in13D(0x21) 'WW LUT
	movlw	33
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 42
	clrf	EPD_COUNTER,ACCESS
SysForLoop12
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_WW, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_WW
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	42
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop12
SysForLoopEnd12
;SendCommand_EPD2in13D(0x22) 'BW LUT
	movlw	34
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 42
	clrf	EPD_COUNTER,ACCESS
SysForLoop13
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_BW, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_BW
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	42
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop13
SysForLoopEnd13
;SendCommand_EPD2in13D(0x23) 'WB LUT
	movlw	35
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 42
	clrf	EPD_COUNTER,ACCESS
SysForLoop14
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_WB, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_WB
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	42
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop14
SysForLoopEnd14
;SendCommand_EPD2in13D(0x24) 'BB LUT
	movlw	36
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;for EPD_Counter=1 to 42
	clrf	EPD_COUNTER,ACCESS
SysForLoop15
	incf	EPD_COUNTER,F,ACCESS
;ReadTable Lut_BB, EPD_Counter, DataVar
	movff	EPD_COUNTER,SYSSTRINGA
	rcall	LUT_BB
	movwf	DATAVAR,ACCESS
;SendData_EPD2in13D(DataVar)
	movff	DATAVAR,EPD2IN13D_DATA
	rcall	SENDDATA_EPD2IN13D
;next
	movlw	42
	subwf	EPD_COUNTER,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop15
SysForLoopEnd15
	return

;********************************************************************************

LUT_BB
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_BB
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_BB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_BB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_BB
	db	42,128,8,0,0,0,2,144,40,40,0,0,1,128,20,0,0,0,1,80,18,18,0,0,1

;********************************************************************************

LUT_BW
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_BW
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_BW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_BW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_BW
	db	42,64,23,0,0,0,2,144,15,15,0,0,3,64,10,1,0,0,1,160,14,14,0,0,2

;********************************************************************************

LUT_VCOM
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_VCOM
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_VCOM
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_VCOM
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_VCOM
	db	44,0,8,0,0,0,2,96,40,40,0,0,1,0,20,0,0,0,1,0,18,18,0,0,1

;********************************************************************************

LUT_WB
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_WB
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_WB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_WB
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_WB
	db	42,128,8,0,0,0,2,144,40,40,0,0,1,128,20,0,0,0,1,80,18,18,0,0,1

;********************************************************************************

LUT_WW
	movlw	25
	cpfslt	SysStringA,ACCESS
	retlw	0
	movf	SysStringA, W,ACCESS
	addlw	low TableLUT_WW
	movwf	TBLPTRL,ACCESS
	movlw	high TableLUT_WW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRH,ACCESS
	movlw	upper TableLUT_WW
	btfsc	STATUS, C,ACCESS
	addlw	1
	movwf	TBLPTRU,ACCESS
	tblrd*
	movf	TABLAT, W,ACCESS
	return
TableLUT_WW
	db	42,64,8,0,0,0,2,144,40,40,0,0,1,64,20,0,0,0,1,160,18,18,0,0,1

;********************************************************************************

;Source: epd_epd2in13d.h (426)
PIXEL_TO_DISPLAY_EPD2IN13D
;Dim EPD_Ind_raw, EPD_Ind_col as Word
;if _GLCDPage = 0 then
	movf	_GLCDPAGE,F,BANKED
	btfss	STATUS, Z,ACCESS
	bra	ENDIF10
;Clear down 'OLD' data - to prevent flashing
;SendCommand_EPD2in13D(Data_Transmission_1)
	movlw	16
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;for EPD_Ind_raw=1 to GLCD_Height
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop4
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;for EPD_Ind_col=1 to GLCD_Width
	clrf	EPD_IND_COL,ACCESS
	clrf	EPD_IND_COL_H,ACCESS
SysForLoop5
	incf	EPD_IND_COL,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_COL_H,F,ACCESS
;Replaced with macro for speed              SendData_EPD2in13D(GLCDBackGround)
;EPD2in13D_Data = GLCDBackGround
	movff	GLCDBACKGROUND,EPD2IN13D_DATA
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (560)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp1,BANKED
SysRepeatLoop1
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE13_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF13
ELSE13_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF13
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp1,F,BANKED
	bra	SysRepeatLoop1
SysRepeatLoopEnd1
;next
	movff	EPD_IND_COL,SysWORDTempA
	movff	EPD_IND_COL_H,SysWORDTempA_H
	movlw	104
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop5
SysForLoopEnd5
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	212
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop4
SysForLoopEnd4
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
;SendCommand_EPD2in13D(DATA_TRANSMISSION_2)
	movlw	19
	movwf	EPD2IN13D_COMMAND,ACCESS
	rcall	SENDCOMMAND_EPD2IN13D
;end if
ENDIF10
;dim EPD2in13D_Data as byte
;We need to set the signals as we are optimising the code by using the macro
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;for EPD_Ind_raw=1 to BUFFWIDTH
	clrf	EPD_IND_RAW,ACCESS
	clrf	EPD_IND_RAW_H,ACCESS
SysForLoop6
	incf	EPD_IND_RAW,F,ACCESS
	btfsc	STATUS,Z,ACCESS
	incf	EPD_IND_RAW_H,F,ACCESS
;replaced with macro for speed
;SendData_EPD2in13D(EPD_Buffer(EPD_Ind_raw))
;EPD2in13D_Data = EPD_Buffer(EPD_Ind_raw)
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_RAW,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_RAW_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	INDF0,EPD2IN13D_DATA
;The following line is intentionally commented out, but, it shows the orientation of the pixels to the array. Uncomment to force a two (when the value is 3!) byte write to the Display
;You can then examine the display to see the orientation of the pixels.
;This will write the bytes at the top of each page - so, do not be surprised!
;if EPD_Ind_raw < 3 then EPD2in13D_Data = GLCDForeground
;This macro assumes the use of the variable EPD2in13D_Data
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (560)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp1,BANKED
SysRepeatLoop2
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE11_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF11
ELSE11_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF11
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp1,F,BANKED
	bra	SysRepeatLoop2
SysRepeatLoopEnd2
;Now clear the buffer
;EPD_Buffer(EPD_Ind_raw) = GLCDBackground
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_RAW,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_RAW_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	GLCDBACKGROUND,INDF0
;next
	movff	EPD_IND_RAW,SysWORDTempA
	movff	EPD_IND_RAW_H,SysWORDTempA_H
	movlw	208
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
	bra	SysForLoop6
SysForLoopEnd6
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
	return

;********************************************************************************

;Source: epd_epd2in13d.h (772)
PSET_EPD2IN13D
;Dim EPD_Ind, EPD_N_Col, EPD_N_raw, EPD_Ind_Trans as word
;Dim remainder as byte
;Dim DataVar as byte
;Dim value as bit
;Dim GLCD_Time_Buff as word
;Dim GLCDDataTemp, GLCDY_Temp, GLCDY_withinPage  as word
;Select Case EPD2in13DAddressType
;case Landscape
SysSelect1Case1
	decf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case2
;GLCDDataTemp = GLCDX
	movff	GLCDX,GLCDDATATEMP
	movff	GLCDX_H,GLCDDATATEMP_H
;GLCDX = GLCDY
	movff	GLCDY,GLCDX
	movff	GLCDY_H,GLCDX_H
;GLCDY = GLCD_HEIGHT - GLCDDataTemp - 1
	movf	GLCDDATATEMP,W,ACCESS
	sublw	212
	movwf	SysTemp2,BANKED
	clrf	SysTemp1,BANKED
	movf	GLCDDATATEMP_H,W,ACCESS
	subwfb	SysTemp1,W,BANKED
	movwf	SysTemp2_H,BANKED
	movlw	1
	subwf	SysTemp2,W,BANKED
	movwf	GLCDY,ACCESS
	movlw	0
	subwfb	SysTemp2_H,W,BANKED
	movwf	GLCDY_H,ACCESS
;case Landscape_Rev
	bra	SysSelectEnd1
SysSelect1Case2
	movlw	3
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case3
;GLCDDataTemp = GLCDX
	movff	GLCDX,GLCDDATATEMP
	movff	GLCDX_H,GLCDDATATEMP_H
;GLCDX = GLCD_WIDTH  - GLCDY - 1
	movf	GLCDY,W,ACCESS
	sublw	104
	movwf	SysTemp2,BANKED
	clrf	SysTemp1,BANKED
	movf	GLCDY_H,W,ACCESS
	subwfb	SysTemp1,W,BANKED
	movwf	SysTemp2_H,BANKED
	movlw	1
	subwf	SysTemp2,W,BANKED
	movwf	GLCDX,ACCESS
	movlw	0
	subwfb	SysTemp2_H,W,BANKED
	movwf	GLCDX_H,ACCESS
;GLCDY = GLCDDataTemp
	movff	GLCDDATATEMP,GLCDY
	movff	GLCDDATATEMP_H,GLCDY_H
;case Portrait
	bra	SysSelectEnd1
SysSelect1Case3
	movlw	4
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case4
;Default do nothing
;case Portrait_Rev
	bra	SysSelectEnd1
SysSelect1Case4
	movlw	2
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelectEnd1
;GLCDY = GLCD_HEIGHT - GLCDY - 1
	movf	GLCDY,W,ACCESS
	sublw	212
	movwf	SysTemp2,BANKED
	clrf	SysTemp1,BANKED
	movf	GLCDY_H,W,ACCESS
	subwfb	SysTemp1,W,BANKED
	movwf	SysTemp2_H,BANKED
	movlw	1
	subwf	SysTemp2,W,BANKED
	movwf	GLCDY,ACCESS
	movlw	0
	subwfb	SysTemp2_H,W,BANKED
	movwf	GLCDY_H,ACCESS
;GLCDX = GLCD_WIDTH - GLCDX - 1
	movf	GLCDX,W,ACCESS
	sublw	104
	movwf	SysTemp2,BANKED
	clrf	SysTemp1,BANKED
	movf	GLCDX_H,W,ACCESS
	subwfb	SysTemp1,W,BANKED
	movwf	SysTemp2_H,BANKED
	movlw	1
	subwf	SysTemp2,W,BANKED
	movwf	GLCDX,ACCESS
	movlw	0
	subwfb	SysTemp2_H,W,BANKED
	movwf	GLCDX_H,ACCESS
;end select
SysSelectEnd1
;Exit if not the current page.
;if  ( GLCDY / EPD_PIXELS_PER_PAGE  ) <> _GLCDPage then
	movff	GLCDY,SysWORDTempA
	movff	GLCDY_H,SysWORDTempA_H
	movlw	16
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysDivSub16
	movff	SysWORDTempA,SysTemp2
	movff	SysWORDTempA_H,SysTemp2_H
	movff	SysTemp2,SysWORDTempA
	movff	SysTemp2_H,SysWORDTempA_H
	movff	_GLCDPAGE,SysWORDTempB
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompEqual16
	comf	SysByteTempX,F,ACCESS
	btfsc	SysByteTempX,0,ACCESS
;exit sub
	return
;end if
;EPD_N_Col=(GLCDX+1)/8                   'number of the column of the byte to be set
;EPD_N_Col=(GLCDX+1)
	movlw	1
	addwf	GLCDX,W,ACCESS
	movwf	EPD_N_COL,ACCESS
	movlw	0
	addwfc	GLCDX_H,W,ACCESS
	movwf	EPD_N_COL_H,ACCESS
;Repeat 3
	movlw	3
	movwf	SysRepeatTemp4,BANKED
SysRepeatLoop4
;Set C Off
	bcf	STATUS,C,ACCESS
;Rotate EPD_N_Col Right
	rrcf	EPD_N_COL_H,F,ACCESS
	rrcf	EPD_N_COL,F,ACCESS
;End Repeat
	decfsz	SysRepeatTemp4,F,BANKED
	bra	SysRepeatLoop4
SysRepeatLoopEnd4
;remainder=(GLCDX+1) % 8
	movlw	1
	addwf	GLCDX,W,ACCESS
	movwf	SysTemp2,BANKED
	movlw	0
	addwfc	GLCDX_H,W,ACCESS
	movwf	SysTemp2_H,BANKED
	movff	SysTemp2,SysWORDTempA
	movff	SysTemp2_H,SysWORDTempA_H
	movlw	8
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysDivSub16
	movff	SysWORDTempX,REMAINDER
;EPD_N_raw=GLCDY * GLCD_Width8       'number of the column of the byte to be set
	movff	GLCDY,SysWORDTempA
	movff	GLCDY_H,SysWORDTempA_H
	movlw	13
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysMultSub16
	movff	SysWORDTempX,EPD_N_RAW
	movff	SysWORDTempX_H,EPD_N_RAW_H
;if remainder=0 then
	movf	REMAINDER,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ELSE19_1
;EPD_Ind=EPD_N_raw+EPD_N_Col
	movf	EPD_N_COL,W,ACCESS
	addwf	EPD_N_RAW,W,ACCESS
	movwf	EPD_IND,ACCESS
	movf	EPD_N_COL_H,W,ACCESS
	addwfc	EPD_N_RAW_H,W,ACCESS
	movwf	EPD_IND_H,ACCESS
;else
	bra	ENDIF19
ELSE19_1
;EPD_Ind=EPD_N_raw+EPD_N_Col+1       'Number of the byte to be set (starting from 1)
	movf	EPD_N_COL,W,ACCESS
	addwf	EPD_N_RAW,W,ACCESS
	movwf	SysTemp1,BANKED
	movf	EPD_N_COL_H,W,ACCESS
	addwfc	EPD_N_RAW_H,W,ACCESS
	movwf	SysTemp1_H,BANKED
	movlw	1
	addwf	SysTemp1,W,BANKED
	movwf	EPD_IND,ACCESS
	movlw	0
	addwfc	SysTemp1_H,W,BANKED
	movwf	EPD_IND_H,ACCESS
;end if
ENDIF19
;GLCD_Time_Buff=_GLCDPage*BUFFWIDTH
	movff	_GLCDPAGE,SysWORDTempA
	clrf	SysWORDTempA_H,ACCESS
	movlw	208
	movwf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysMultSub16
	movff	SysWORDTempX,GLCD_TIME_BUFF
	movff	SysWORDTempX_H,GLCD_TIME_BUFF_H
;EPD_Ind_Trans=EPD_Ind
	movff	EPD_IND,EPD_IND_TRANS
	movff	EPD_IND_H,EPD_IND_TRANS_H
;EPD_Ind_Trans=EPD_Ind_Trans-GLCD_Time_Buff
	movf	GLCD_TIME_BUFF,W,ACCESS
	subwf	EPD_IND_TRANS,F,ACCESS
	movf	GLCD_TIME_BUFF_H,W,ACCESS
	subwfb	EPD_IND_TRANS_H,F,ACCESS
;if EPD_Ind_Trans>BUFFWIDTH then       'NOTE:it should be a control also for a
	movff	EPD_IND_TRANS,SysWORDTempB
	movff	EPD_IND_TRANS_H,SysWORDTempB_H
	movlw	208
	movwf	SysWORDTempA,ACCESS
	clrf	SysWORDTempA_H,ACCESS
	rcall	SysCompLessThan16
	btfsc	SysByteTempX,0,ACCESS
;EXIT SUB                            'lower bound of ind (ind>GLCD_Time_Buff)
	return
;end if                                'However when the lower bound is violated,
;DataVar=EPD_Buffer(EPD_Ind_Trans)     'Ind_Trans should be negative and, due to
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_TRANS,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_TRANS_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	INDF0,DATAVAR
;Select Case remainder                 'non signed arithmetic, it will be very
;case 0                                'large, thus Exits sub is executed.
SysSelect2Case1
	movf	REMAINDER,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case2
;DataVar.0=GLCDColour.0
	bcf	DATAVAR,0,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,0,ACCESS
;case 1
	bra	SysSelectEnd2
SysSelect2Case2
	decf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case3
;DataVar.7=GLCDColour.0
	bcf	DATAVAR,7,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,7,ACCESS
;case 2
	bra	SysSelectEnd2
SysSelect2Case3
	movlw	2
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case4
;DataVar.6=GLCDColour.0
	bcf	DATAVAR,6,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,6,ACCESS
;case 3
	bra	SysSelectEnd2
SysSelect2Case4
	movlw	3
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case5
;DataVar.5=GLCDColour.0
	bcf	DATAVAR,5,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,5,ACCESS
;case 4
	bra	SysSelectEnd2
SysSelect2Case5
	movlw	4
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case6
;DataVar.4=GLCDColour.0
	bcf	DATAVAR,4,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,4,ACCESS
;case 5
	bra	SysSelectEnd2
SysSelect2Case6
	movlw	5
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case7
;DataVar.3=GLCDColour.0
	bcf	DATAVAR,3,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,3,ACCESS
;case 6
	bra	SysSelectEnd2
SysSelect2Case7
	movlw	6
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect2Case8
;DataVar.2=GLCDColour.0
	bcf	DATAVAR,2,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,2,ACCESS
;case 7
	bra	SysSelectEnd2
SysSelect2Case8
	movlw	7
	subwf	REMAINDER,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelectEnd2
;DataVar.1=GLCDColour.0
	bcf	DATAVAR,1,ACCESS
	btfsc	GLCDCOLOUR,0,ACCESS
	bsf	DATAVAR,1,ACCESS
;End Select
SysSelectEnd2
;EPD_Buffer(EPD_Ind_Trans)=DataVar
	lfsr	0,EPD_BUFFER
	movf	EPD_IND_TRANS,W,ACCESS
	addwf	AFSR0,F,ACCESS
	movf	EPD_IND_TRANS_H,W,ACCESS
	addwfc	AFSR0_H,F,ACCESS
	movffl	DATAVAR,INDF0
	return

;********************************************************************************

;Source: epd_epd2in13d.h (497)
REFRESH_EPD2IN13D
;Not required as this process has already happenend from INIT
;LoadLUTS_EPD2in13D
;SendCommand_EPD2in13D(DISPLAY_REFRESH)
	movlw	18
	movwf	EPD2IN13D_COMMAND,ACCESS
	bra	SENDCOMMAND_EPD2IN13D

;********************************************************************************

;Source: epd_epd2in13d.h (919)
ROTATE_EPD2IN13D
;DIM GLCDDataTemp, PrintLocY, PrintLocX as word
;PrintLocY = 0
	clrf	PRINTLOCY,ACCESS
	clrf	PRINTLOCY_H,ACCESS
;PrintLocX = 0
	clrf	PRINTLOCX,ACCESS
	clrf	PRINTLOCX_H,ACCESS
;select case EPD2in13DAddressType
;case PORTRAIT
SysSelect4Case1
	movlw	4
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect4Case2
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;case LANDSCAPE
	bra	SysSelectEnd4
SysSelect4Case2
	decf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect4Case3
;GLCDDeviceHeight = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth  = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;case PORTRAIT_REV
	bra	SysSelectEnd4
SysSelect4Case3
	movlw	2
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect4Case4
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth  = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;case LANDSCAPE_REV
	bra	SysSelectEnd4
SysSelect4Case4
	movlw	3
	subwf	EPD2IN13DADDRESSTYPE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect4Case5
;GLCDDeviceHeight = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth  = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;case else
	bra	SysSelectEnd4
SysSelect4Case5
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	211
	movwf	GLCDDEVICEHEIGHT,ACCESS
	clrf	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDDeviceWidth  = GLCD_WIDTH - 1
	movlw	103
	movwf	GLCDDEVICEWIDTH,ACCESS
	clrf	GLCDDEVICEWIDTH_H,ACCESS
;end select
SysSelectEnd4
	return

;********************************************************************************

;Source: MySDLib.h (83)
SENDCOMMAND
;SET SD_Adaper_CS OFF
	bcf	LATD,7,ACCESS
;SPITransfer 0xFF, SDData
	setf	SPITXDATA,BANKED
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDDATA
;SPITransfer Code, SDData
	movff	CODE,SPITXDATA
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDDATA
;SPITransfer Arg_E, SDData
	movff	ARG_E,SPITXDATA
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDDATA
;SPITransfer Arg_U, SDData
	movff	ARG_U,SPITXDATA
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDDATA
;SPITransfer Arg_H, SDData
	movff	ARG_H,SPITXDATA
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDDATA
;SPITransfer [byte]Arg, SDData
	movff	ARG,SPITXDATA
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDDATA
;SPITransfer CRC, SDData
	movff	CRC,SPITXDATA
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDDATA
;SendPulses      'NECESSARIO!!!!
	rcall	SENDPULSES
;SPITransfer 0xFF, SDData
	return

;********************************************************************************

;Source: epd_epd2in13d.h (517)
SENDCOMMAND_EPD2IN13D
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC OFF
	bcf	LATA,0,ACCESS
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp3,BANKED
SysRepeatLoop3
;IF EPD2in13D_Command.7 = ON THEN
	btfss	EPD2IN13D_COMMAND,7,ACCESS
	bra	ELSE17_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF17
ELSE17_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF17
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Command left
	rlcf	EPD2IN13D_COMMAND,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp3,F,BANKED
	bra	SysRepeatLoop3
SysRepeatLoopEnd3
;Set EPD_CS ON
	bsf	LATC,1,ACCESS
;do
SysDoLoop_S3
;loop while EPD_Busy=Off
	btfss	PORTC,0,ACCESS
	bra	SysDoLoop_S3
SysDoLoop_E3
	return

;********************************************************************************

;Source: epd_epd2in13d.h (550)
SENDDATA_EPD2IN13D
;SET EPD_CS OFF
	bcf	LATC,1,ACCESS
;SET EPD_DC ON
	bsf	LATA,0,ACCESS
;SendData_EPD2in13D_Macro
;Macro Source: epd_epd2in13d.h (560)
;REPEAT 8
	movlw	8
	movwf	SysRepeatTemp7,BANKED
SysRepeatLoop7
;IF EPD2in13D_Data.7 = ON THEN
	btfss	EPD2IN13D_DATA,7,ACCESS
	bra	ELSE49_1
;Set EPD_DO ON
	bsf	LATC,5,ACCESS
;ELSE
	bra	ENDIF49
ELSE49_1
;Set EPD_DO OFF
	bcf	LATC,5,ACCESS
;END IF
ENDIF49
;SET EPD_SCK On
	bsf	LATC,3,ACCESS
;Rotate EPD2in13D_Data left
	rlcf	EPD2IN13D_DATA,F,ACCESS
;Set EPD_SCK Off
	bcf	LATC,3,ACCESS
;END REPEAT
	decfsz	SysRepeatTemp7,F,BANKED
	bra	SysRepeatLoop7
SysRepeatLoopEnd7
;SET EPD_CS ON
	bsf	LATC,1,ACCESS
	return

;********************************************************************************

;Source: MySDLib.h (76)
SENDDUMMYBYTES
;repeat n_bytes
	movff	N_BYTES,SysRepeatTemp5
	movf	SYSREPEATTEMP5,F,BANKED
	btfsc	STATUS, Z,ACCESS
	bra	SysRepeatLoopEnd5
SysRepeatLoop5
;SPITransfer 0xFF, SDData
	setf	SPITXDATA,BANKED
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDDATA
;end repeat
	decfsz	SysRepeatTemp5,F,BANKED
	bra	SysRepeatLoop5
SysRepeatLoopEnd5
	return

;********************************************************************************

;Source: MySDLib.h (100)
SENDPULSES
;Set SD_Adaper_CS OFF
;SPITransfer 0xFF, SDData
	setf	SPITXDATA,BANKED
	rcall	HWSPITRANSFER
	movff	SPIRXDATA,SDDATA
;Set SD_Adaper_CS ON
	return

;********************************************************************************

;Overloaded signature: BYTE:STRING:STRING:BYTE:, Source: Sertxd.h (1)
SERTXD3
;if CRLF1 >0 Then
	movf	CRLF1,W,ACCESS
	sublw	0
	btfsc	STATUS, C,ACCESS
	bra	ELSE42_1
;HSerPrintCRLF CRLF1     'carriage return + line feed
	movff	CRLF1,HSERPRINTCRLFCOUNT
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINTCRLF
;Else
	bra	ENDIF42
ELSE42_1
;HSerSend CRLF1
	movff	CRLF1,SERDATA
	rcall	HSERSEND701
;End if
ENDIF42
;HSerPrint stringa
	movff	SysSTRINGAHandler,SysPRINTDATAHandler
	movff	SysSTRINGAHandler_H,SysPRINTDATAHandler_H
	movlw	1
	movwf	COMPORT,ACCESS
	call	HSERPRINT712
;HSerPrint inputS
	movff	SysINPUTSHandler,SysPRINTDATAHandler
	movff	SysINPUTSHandler_H,SysPRINTDATAHandler_H
	movlw	1
	movwf	COMPORT,ACCESS
	call	HSERPRINT712
;if CRLF2 >0 Then
	movf	CRLF2,W,ACCESS
	sublw	0
	btfsc	STATUS, C,ACCESS
	bra	ELSE43_1
;HSerPrintCRLF CRLF2
	movff	CRLF2,HSERPRINTCRLFCOUNT
	movlw	1
	movwf	COMPORT,ACCESS
	call	HSERPRINTCRLF
;Else
	bra	ENDIF43
ELSE43_1
;HSerSend CRLF2
	movff	CRLF2,SERDATA
	call	HSERSEND701
;End if
ENDIF43
	return

;********************************************************************************

;Overloaded signature: BYTE:BYTE:, Source: hwspi.h (354)
SPIMODE667
;Supports K mode SPI using the specific SPI module
;Turn off SPI
;(Prevents any weird glitches during setup)
;SPI1CON0_EN = 0
	banksel	SPI1CON0
	bcf	SPI1CON0,SPI1CON0_EN,BANKED
;Set clock pulse settings to middle
;SPI1CON1.SMP = 0
	bcf	SPI1CON1,SMP,BANKED
;Data write on rising (idle > active) clock (CPHA = 1)
;SPI1CON1.CKE = 0
	bcf	SPI1CON1,CKE,BANKED
;Clock idle low (CPOL = 0)
;SPI1CON1.CKP = 0
	bcf	SPI1CON1,CKP,BANKED
;If SPIClockMode.0 = Off Then
	btfss	SPICLOCKMODE,0,ACCESS
;SPI1CON1.CKE = 1
	bsf	SPI1CON1,CKE,BANKED
;End If
;If SPIClockMode.1 = On Then
	btfsc	SPICLOCKMODE,1,ACCESS
;SPI1CON1.CKP = 1
	bsf	SPI1CON1,CKP,BANKED
;End If
;SPI1CON1 = 0x40
	movlw	64
	movwf	SPI1CON1,BANKED
;Transfer
;SPI1CON2 = SPI1CON2 or 3
	movlw	3
	iorwf	SPI1CON2,F,BANKED
;Select mode and clock
;SPI1CLK = SSP1_FOSC
	clrf	SPI1CLK,BANKED
;Select Case SPICurrentMode
;Case MasterFast or MasterUltraFast
SysSelect3Case1
	movff	SPICURRENTMODE,SysBYTETempA
	movlw	13
	movwf	SysBYTETempB,ACCESS
	banksel	0
	rcall	SysCompEqual
	movlw	14
	iorwf	SysByteTempX,W,ACCESS
	movwf	SysTemp1,BANKED
	btfss	SysTemp1,0,BANKED
	bra	SysSelect3Case2
;asm showdebug Script value is calculated as SPIBAUDRATE_SCRIPT
;script sysbitvar0.5 is calculated as 3
;SPI1BAUD = SPIBAUDRATE_SCRIPT
	movlw	3
	banksel	SPI1BAUD
	movwf	SPI1BAUD,BANKED
;SPI1CON0.MST = 1
	bsf	SPI1CON0,MST,BANKED
;Case Master
	bra	SysSelectEnd3
SysSelect3Case2
	movlw	12
	subwf	SPICURRENTMODE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect3Case3
;asm showdebug Script value is calculated as SPIBAUDRATE_SCRIPT_MASTER
;script sysbitvar0.5 is calculated as 9
;SPI1BAUD = SPIBAUDRATE_SCRIPT_MASTER
	movlw	9
	banksel	SPI1BAUD
	movwf	SPI1BAUD,BANKED
;SPI1CON0.MST = 1
	bsf	SPI1CON0,MST,BANKED
;Case MasterSlow
	bra	SysSelectEnd3
SysSelect3Case3
	movlw	11
	subwf	SPICURRENTMODE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect3Case4
;asm showdebug Script value is calculated as SPIBAUDRATE_SCRIPT_MASTERSLOW
;script sysbitvar0.5 is calculated as 33
;SPI1BAUD = SPIBAUDRATE_SCRIPT_MASTERSLOW
	movlw	33
	banksel	SPI1BAUD
	movwf	SPI1BAUD,BANKED
;SPI1CON0.MST = 1
	bsf	SPI1CON0,MST,BANKED
;Case Slave
	bra	SysSelectEnd3
SysSelect3Case4
	movf	SPICURRENTMODE,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect3Case5
;SPI1CON0.MST = 0
	banksel	SPI1CON0
	bcf	SPI1CON0,MST,BANKED
;Case SlaveSS
	bra	SysSelectEnd3
SysSelect3Case5
	decf	SPICURRENTMODE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelectEnd3
;SPI1CON0.MST = 0
	banksel	SPI1CON0
	bcf	SPI1CON0,MST,BANKED
;End Select
SysSelectEnd3
;override the script calculation
;SPI1BAUD = SPI_BAUD_RATE_REGISTER
	movlw	7
	banksel	SPI1BAUD
	movwf	SPI1BAUD,BANKED
;Enable SPI
;SPI1CON0.EN = 1
	bsf	SPI1CON0,EN,BANKED
	banksel	0
	return

;********************************************************************************

;Source: system.h (2613)
SYSCOMPEQUAL
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;setf SysByteTempX
	setf	SYSBYTETEMPX,ACCESS
;movf SysByteTempB, W
	movf	SYSBYTETEMPB, W,ACCESS
;cpfseq SysByteTempA
	cpfseq	SYSBYTETEMPA,ACCESS
;clrf SysByteTempX
	clrf	SYSBYTETEMPX,ACCESS
	return

;********************************************************************************

;Source: system.h (2639)
SYSCOMPEQUAL16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX,ACCESS
;Test low, exit if false
;movf SysWordTempB, W
	movf	SYSWORDTEMPB, W,ACCESS
;cpfseq SysWordTempA
	cpfseq	SYSWORDTEMPA,ACCESS
;return
	return
;Test high, exit if false
;movf SysWordTempB_H, W
	movf	SYSWORDTEMPB_H, W,ACCESS
;cpfseq SysWordTempA_H
	cpfseq	SYSWORDTEMPA_H,ACCESS
;return
	return
;setf SysByteTempX
	setf	SYSBYTETEMPX,ACCESS
	return

;********************************************************************************

;Source: system.h (2810)
SYSCOMPLESSTHAN16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX,ACCESS
;Test High, exit if more
;movf SysWordTempA_H,W
	movf	SYSWORDTEMPA_H,W,ACCESS
;subwf SysWordTempB_H,W
	subwf	SYSWORDTEMPB_H,W,ACCESS
;btfss STATUS,C
	btfss	STATUS,C,ACCESS
;return
	return
;Test high, exit true if less
;movf SysWordTempB_H,W
	movf	SYSWORDTEMPB_H,W,ACCESS
;subwf SysWordTempA_H,W
	subwf	SYSWORDTEMPA_H,W,ACCESS
;bnc SCLT16True
	bnc	SCLT16TRUE
;Test Low, exit if more or equal
;movf SysWordTempB,W
	movf	SYSWORDTEMPB,W,ACCESS
;subwf SysWordTempA,W
	subwf	SYSWORDTEMPA,W,ACCESS
;btfsc STATUS,C
	btfsc	STATUS,C,ACCESS
;return
	return
SCLT16TRUE
;comf SysByteTempX,F
	comf	SYSBYTETEMPX,F,ACCESS
	return

;********************************************************************************

;Source: system.h (2457)
SYSDIVSUB16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;dim SysDivMultA as word
;dim SysDivMultB as word
;dim SysDivMultX as word
;SysDivMultA = SysWordTempA
	movff	SYSWORDTEMPA,SYSDIVMULTA
	movff	SYSWORDTEMPA_H,SYSDIVMULTA_H
;SysDivMultB = SysWordTempB
	movff	SYSWORDTEMPB,SYSDIVMULTB
	movff	SYSWORDTEMPB_H,SYSDIVMULTB_H
;SysDivMultX = 0
	clrf	SYSDIVMULTX,ACCESS
	clrf	SYSDIVMULTX_H,ACCESS
;Avoid division by zero
;if SysDivMultB = 0 then
	movff	SYSDIVMULTB,SysWORDTempA
	movff	SYSDIVMULTB_H,SysWORDTempA_H
	clrf	SysWORDTempB,ACCESS
	clrf	SysWORDTempB_H,ACCESS
	rcall	SysCompEqual16
	btfss	SysByteTempX,0,ACCESS
	bra	ENDIF35
;SysWordTempA = 0
	clrf	SYSWORDTEMPA,ACCESS
	clrf	SYSWORDTEMPA_H,ACCESS
;exit sub
	return
;end if
ENDIF35
;Main calc routine
;SysDivLoop = 16
	movlw	16
	movwf	SYSDIVLOOP,ACCESS
SYSDIV16START
;set C off
	bcf	STATUS,C,ACCESS
;Rotate SysDivMultA Left
	rlcf	SYSDIVMULTA,F,ACCESS
	rlcf	SYSDIVMULTA_H,F,ACCESS
;Rotate SysDivMultX Left
	rlcf	SYSDIVMULTX,F,ACCESS
	rlcf	SYSDIVMULTX_H,F,ACCESS
;SysDivMultX = SysDivMultX - SysDivMultB
	movf	SYSDIVMULTB,W,ACCESS
	subwf	SYSDIVMULTX,F,ACCESS
	movf	SYSDIVMULTB_H,W,ACCESS
	subwfb	SYSDIVMULTX_H,F,ACCESS
;Set SysDivMultA.0 On
	bsf	SYSDIVMULTA,0,ACCESS
;If C Off Then
	btfsc	STATUS,C,ACCESS
	bra	ENDIF36
;Set SysDivMultA.0 Off
	bcf	SYSDIVMULTA,0,ACCESS
;SysDivMultX = SysDivMultX + SysDivMultB
	movf	SYSDIVMULTB,W,ACCESS
	addwf	SYSDIVMULTX,F,ACCESS
	movf	SYSDIVMULTB_H,W,ACCESS
	addwfc	SYSDIVMULTX_H,F,ACCESS
;End If
ENDIF36
;decfsz SysDivLoop, F
	decfsz	SYSDIVLOOP, F,ACCESS
;goto SysDiv16Start
	bra	SYSDIV16START
;SysWordTempA = SysDivMultA
	movff	SYSDIVMULTA,SYSWORDTEMPA
	movff	SYSDIVMULTA_H,SYSWORDTEMPA_H
;SysWordTempX = SysDivMultX
	movff	SYSDIVMULTX,SYSWORDTEMPX
	movff	SYSDIVMULTX_H,SYSWORDTEMPX_H
	return

;********************************************************************************

;Source: system.h (2212)
SYSMULTSUB16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;X = LowA * LowB
;movf SysWordTempA, W
	movf	SYSWORDTEMPA, W,ACCESS
;mulwf SysWordTempB
	mulwf	SYSWORDTEMPB,ACCESS
;movff PRODL, SysWordTempX
	movffl	PRODL,SYSWORDTEMPX
;movff PRODH, SysWordTempX_H
	movffl	PRODH,SYSWORDTEMPX_H
;HighX += LowA * HighB
;movf SysWordTempA, W
	movf	SYSWORDTEMPA, W,ACCESS
;mulwf SysWordTempB_H
	mulwf	SYSWORDTEMPB_H,ACCESS
;movf PRODL, W
	movf	PRODL, W,ACCESS
;addwf SysWordTempX_H, F
	addwf	SYSWORDTEMPX_H, F,ACCESS
;HighX += HighA * LowB
;movf SysWordTempA_H, W
	movf	SYSWORDTEMPA_H, W,ACCESS
;mulwf SysWordTempB
	mulwf	SYSWORDTEMPB,ACCESS
;movf PRODL, W
	movf	PRODL, W,ACCESS
;addwf SysWordTempX_H, F
	addwf	SYSWORDTEMPX_H, F,ACCESS
;PRODL = HighA * HighB
;movf SysWordTempA_H, F
	movf	SYSWORDTEMPA_H, F,ACCESS
;mulwf SysWordTempB_H
	mulwf	SYSWORDTEMPB_H,ACCESS
	return

;********************************************************************************

;Source: system.h (1240)
SYSREADSTRING
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;Get length
;TBLRD*+
	tblrd*+
;movff TABLAT,SysCalcTempA
	movffl	TABLAT,SYSCALCTEMPA
;movff TABLAT,INDF1
	movffl	TABLAT,INDF1
;goto SysStringReadCheck
	bra	SYSSTRINGREADCHECK
SYSREADSTRINGPART
;TBLRD*+
	tblrd*+
;movf TABLAT, W
	movf	TABLAT, W,ACCESS
;movwf SysCalcTempA
	movwf	SYSCALCTEMPA,ACCESS
;addwf SysStringLength,F
	addwf	SYSSTRINGLENGTH,F,ACCESS
;Check length
SYSSTRINGREADCHECK
;If length is 0, exit
;movf SysCalcTempA,F
	movf	SYSCALCTEMPA,F,ACCESS
;btfsc STATUS,Z
	btfsc	STATUS,Z,ACCESS
;return
	return
;Copy
SYSSTRINGREAD
;Copy char
;TBLRD*+
	tblrd*+
;movff TABLAT,PREINC1
	movffl	TABLAT,PREINC1
;decfsz SysCalcTempA, F
	decfsz	SYSCALCTEMPA, F,ACCESS
;goto SysStringRead
	bra	SYSSTRINGREAD
	return

;********************************************************************************

SysStringTables

StringTable3
	db	14,105,110,105,116,105,97,108,105,122,97,116,105,111,110


StringTable4
	db	13,67,77,68,48,32,69,120,101,99,117,116,101,100


StringTable34
	db	8,32,32,32,32,67,77,68,48


StringTable35
	db	6,45,67,77,68,48,32


StringTable36
	db	10,32,32,69,120,101,99,117,116,101,100


;********************************************************************************


 END
