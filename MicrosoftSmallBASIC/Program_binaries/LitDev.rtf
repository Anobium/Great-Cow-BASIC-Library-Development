{\rtf1\ansi
{\fonttbl\f0\fswiss Helvetica;}

\f0\pard\qc{\fs45\b LitDev Extension API}\par

\f0\pard\sb300\shading2000{\fs36\b LD3DView}\par
\f0\pard{\fs20 3D Visualisation in the GraphicsWindow.{\line}{\line}Coordinates have the following directions and have no correspondence to the GraphicsWindow coordinates.{\line}X - Left(-) to Right(+){\line}Y - Down(-) to Up(+){\line}Z - Far(-) to Near(+){\line}{\line}For more details on the underlying methods see http://msdn.microsoft.com/en-us/library/ms747437%28v=vs.90%29.aspx{\line}Several of the AddShape methods use HelixToolkit (recompiled and slightly modified for SmallBasic) http://helixToolkit.codeplex.com{\line}{\line}Also see LDVector for vector algebra methods.}\par

\f0\pard\sb180\shading1000{\fs30\b AddAmbientLight(shapeName,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an ambient light source.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The light colour.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Light name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddArrow(shapeName,length,diameter,arrowLength,arrowDiameter,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an arrow geometry object pointing up starting at (0,0,0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b length}\par
\f0\pard{\fs20 The length of the arrow.}\par
\f0\pard\sb75{\fs24\b diameter}\par
\f0\pard{\fs20 The diameter of the arrow shaft.}\par
\f0\pard\sb75{\fs24\b arrowLength}\par
\f0\pard{\fs20 The length of the arrow head.}\par
\f0\pard\sb75{\fs24\b arrowDiameter}\par
\f0\pard{\fs20 The diameter of the arrow head.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 The number of divisions for the arrow (default 18).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddBackImage(shapeName,geometryName,textures,imageName,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an image to a back surface of geometry object.{\line}A geometry 'skin' may contain several segment images in one image.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b textures}\par
\f0\pard{\fs20 A space or colon deliminated list of the texture coordinates for each node.{\line}Each node has 2 values between 0 and 1 indicating the x,y image mapping to the node.{\line}The may be defaulted to "" if the texture has previously been set.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The image to load to the geometry.{\line}Value returned from ImageList.LoadImage or local or network image file.{\line}A colour or gradient brush can also be used here.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular - additional specular highlights.}\par
\f0\pard\sb180\shading1000{\fs30\b AddCone(shapeName,baseRadius,topRadius,height,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a cone geometry object pointing up with base centred at (0,0,0).{\line}Note a cylinder is a cone with baseRadius = topRadius.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b baseRadius}\par
\f0\pard{\fs20 The radius of the base.}\par
\f0\pard\sb75{\fs24\b topRadius}\par
\f0\pard{\fs20 The radius of the top  if truncated (default 0).}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the cone.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 The number of divisions for the cone (default 18).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddCube(shapeName,sideLength,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a cube geometry object centered on (0,0,0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b sideLength}\par
\f0\pard{\fs20 The side length of the cube.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddDirectionalLight(shapeName,colour,xDir,yDir,zDir) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a directional light source.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The light colour.}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 The x direction of the light.}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 The y direction of the light.}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 The z direction of the light.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Light name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddGeometry(shapeName,points,indices,normals,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a geometry object.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b points}\par
\f0\pard{\fs20 A space or colon deliminated list of point coordinates.}\par
\f0\pard\sb75{\fs24\b indices}\par
\f0\pard{\fs20 A space or colon deliminated list of indices for each triangle (counter-clockwise for outward face).}\par
\f0\pard\sb75{\fs24\b normals}\par
\f0\pard{\fs20 An optional space or colon deliminated list of the outward normals for each node or "".}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddIcosahedron(shapeName,radius,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an icosahedron geometry object centred at (0,0,0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 The radius of the icosahedron.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddImage(shapeName,geometryName,textures,imageName,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an image to a geometry object.{\line}A geometry 'skin' may contain several segment images in one image.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b textures}\par
\f0\pard{\fs20 A space or colon deliminated list of the texture coordinates for each node.{\line}Each node has 2 values between 0 and 1 indicating the x,y image mapping to the node.{\line}The may be defaulted to "" if the texture has previously been set.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The image to load to the geometry.{\line}Value returned from ImageList.LoadImage or local or network image file.{\line}A colour or gradient brush can also be used here.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular - additional specular highlights.}\par
\f0\pard\sb180\shading1000{\fs30\b AddPipe(shapeName,length,innerDiameter,outerDiameter,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a pipe geometry object pointing up with base centred at (0,0,0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b length}\par
\f0\pard{\fs20 The length of the pipe.}\par
\f0\pard\sb75{\fs24\b innerDiameter}\par
\f0\pard{\fs20 The inner diameter of the pipe.}\par
\f0\pard\sb75{\fs24\b outerDiameter}\par
\f0\pard{\fs20 The outer diameter of the pipe.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 The number of divisions for the pipe (default 18).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddPointLight(shapeName,colour,xPos,yPos,zPos,range) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a non-directional point light source.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The light colour.}\par
\f0\pard\sb75{\fs24\b xPos}\par
\f0\pard{\fs20 The x position of the light.}\par
\f0\pard\sb75{\fs24\b yPos}\par
\f0\pard{\fs20 The y position of the light.}\par
\f0\pard\sb75{\fs24\b zPos}\par
\f0\pard{\fs20 The z position of the light.}\par
\f0\pard\sb75{\fs24\b range}\par
\f0\pard{\fs20 The light range.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Light name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddPyramid(shapeName,sideLength,height,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a pyramid geometry object pointing up with base centred at (0,0,0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b sideLength}\par
\f0\pard{\fs20 The radius of the base.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the cone.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRectangle(shapeName,width,height,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a rectangle geometry object centred at (0,0,0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the rectangle.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the rectangle.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRevolute(shapeName,path,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a revolute geometry object.  This is a surface starting at (0,0,0) and pointing up.{\line}Its shape is defined by a set points (Y,Z) where Y is the vertical distance along the surface from 0 and Z is the radius of revolution.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 A space or colon deliminated list of 2D point coordinates describing the revolute shape.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 The radial divisions, default 10 (affects number of triangles and smoothness).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddSphere(shapeName,radius,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a sphere geometry object centred on (0,0,0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 The sphere radius.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 The sphere divisions, default 10 (affects number of triangles and smoothness).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddSpotLight(shapeName,colour,xPos,yPos,zPos,xDir,yDir,zDir,angle,range) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a directional spot light source.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The light colour.}\par
\f0\pard\sb75{\fs24\b xPos}\par
\f0\pard{\fs20 The x position of the light.}\par
\f0\pard\sb75{\fs24\b yPos}\par
\f0\pard{\fs20 The y position of the light.}\par
\f0\pard\sb75{\fs24\b zPos}\par
\f0\pard{\fs20 The z position of the light.}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 The x direction of the light.}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 The y direction of the light.}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 The z direction of the light.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The cone angle the light in degrees.}\par
\f0\pard\sb75{\fs24\b range}\par
\f0\pard{\fs20 The light range.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Light name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddTube(shapeName,path,diameter,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a tube geometry object.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 A space or colon deliminated list of 3D point coordinates.}\par
\f0\pard\sb75{\fs24\b diameter}\par
\f0\pard{\fs20 The tube diameter.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 The tube radial divisions, default 10 (affects number of triangles and smoothness).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView Geometry name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddView(width,height,performance) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a 3DView (GraphicsWindow shape).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the 3DView.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the 3DView.}\par
\f0\pard\sb75{\fs24\b performance}\par
\f0\pard{\fs20 A flag to favour speed over quality "True" or "False".{\line}"True" removes visual clipping (clip 3DView to input width and height), hit-testing (unused) and anti-aliasing (not needed).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 3DView viewport3D name.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateRotation(shapeName,geometryName,xDir,yDir,zDir,startAngle,endAngle,duration,repeats) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Animate a geometry rotation about an axis vector.{\line}This uses the second rotation, the first is still available for another axis rotation.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object to animate.}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 X direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 Y direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 Z direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b startAngle}\par
\f0\pard{\fs20 The starting angle in degrees (e.g. 0).}\par
\f0\pard\sb75{\fs24\b endAngle}\par
\f0\pard{\fs20 The final angle in degrees (e.g. 360).}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 The animation duration (time in sec).}\par
\f0\pard\sb75{\fs24\b repeats}\par
\f0\pard{\fs20 The number of times to repeat the animation (-1 is for ever).}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateRotation2(shapeName,geometryName,xDir,yDir,zDir,startAngle,endAngle,duration,repeats) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Animate a geometry rotation about an axis vector.{\line}This uses the third rotation, the first is still available for another axis rotation.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object to animate.}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 X direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 Y direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 Z direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b startAngle}\par
\f0\pard{\fs20 The starting angle in degrees (e.g. 0).}\par
\f0\pard\sb75{\fs24\b endAngle}\par
\f0\pard{\fs20 The final angle in degrees (e.g. 360).}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 The animation duration (time in sec).}\par
\f0\pard\sb75{\fs24\b repeats}\par
\f0\pard{\fs20 The number of times to repeat the animation (-1 is for ever).}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateTranslation(shapeName,geometryName,x,y,z,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Animate a geometry translation.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object to animate.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 X position to animate to.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Y position to animate to.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 Z position to animate to.}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 The animation duration (sec).}\par
\f0\pard\sb180\shading1000{\fs30\b AutoControl(pitchRoll,shift,keyDistance,speed) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set auto control of the camera.{\line}This mode is a general purpose camera control, mainly for moving within a scene (a flyby mode).{\line}Move forwards and backwards with mouse wheel (faster with Shift down, slower with Control down).{\line}Yaw and Pitch camera moving with left mouse button.{\line}Yaw with A,D or Left,Right keys, move forwards and backwards with W,S or Up,Down keys.{\line}Roll camera moving with right mouse button.{\line}Double left click an object to center it (Centre of rotation).{\line}Double right click to reset the up direction to Y.{\line}Yaw and Pitch scene moving with Shift and left mouse button after selecting an object to rotate scene about.{\line}X, Y, Z keys change the view direction and up direction to face in these directions towards (0,0,0), with Shift then the negative direction.}\par
\f0\pard\sb75{\fs24\b pitchRoll}\par
\f0\pard{\fs20 Allow pitch and roll movement, "True" or "False".}\par
\f0\pard\sb75{\fs24\b shift}\par
\f0\pard{\fs20 Allow the Shift/Control key modifiers for mouse control, "True" or "False".}\par
\f0\pard\sb75{\fs24\b keyDistance}\par
\f0\pard{\fs20 The distance to view the scene from using keys, (0 prevents the X,Y,Z key shortcuts, -1 also prevents the A,D,W,S and arrow keys).}\par
\f0\pard\sb75{\fs24\b speed}\par
\f0\pard{\fs20 Forwards and backwards speed multiplier (default 1).}\par
\f0\pard\sb180\shading1000{\fs30\b AutoControl2(keyDistance,speed) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set auto control of the camera.{\line}This mode is mainly to rotate and view a 3D scene rather than move through the scene (an inspection mode).{\line}Zoom in or out with mouse wheel (faster with Shift down, slower with Control down).{\line}Pan left/right with A,D or Left,Right keys, pan up/down with W,S or Up,Down keys.{\line}Double left click an object to center it (Centre of rotation).{\line}Double right click to reset the up direction to Y.{\line}Yaw and Pitch scene moving with left mouse button after selecting an object to rotate scene about.{\line}Roll scene moving with right mouse button.{\line}X, Y, Z keys change the view direction and up direction to face in these directions towards selected center, with Shift then the negative direction.}\par
\f0\pard\sb75{\fs24\b keyDistance}\par
\f0\pard{\fs20 The distance to view the scene from using keys, (0 prevents the X,Y,Z key shortcuts).}\par
\f0\pard\sb75{\fs24\b speed}\par
\f0\pard{\fs20 Forwards and backwards speed multiplier (default 1).}\par
\f0\pard\sb180\shading1000{\fs30\b BoundingBox(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the bounding box extent of a geometry.{\line}This is the current position (after any transformations).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of dimensions or "FAILED".{\line}array[1] = sizeX (width){\line}array[2] = sizeY (height){\line}array[3] = sizeZ (depth){\line}array[4] = X (Xmin){\line}array[5] = Y (Ymin){\line}array[6] = Z (Zmin)}\par
\f0\pard\sb180\shading1000{\fs30\b CameraProperties(shapeName,nearDistance,farDistance,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the angle of view, near and far clipping distances.{\line}These are all of the fundamental perspective camera properties.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b nearDistance}\par
\f0\pard{\fs20 The near clipping distance (can improve near object e.g. wall hit detection).{\line}A negative value is 0.001 (default is 0.125).}\par
\f0\pard\sb75{\fs24\b farDistance}\par
\f0\pard{\fs20 The far clipping distance (can improve performance).{\line}A negative value is infinity (default).}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The view angle cone of the camera in degrees (affects perspective vanishing point).{\line}If this is negative, then an Orthographic (no perspective) camera is used with view width set to -angle). }\par
\f0\pard\sb180\shading1000{\fs30\b CloneObject(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a complete copy of a geometry object and all of its properties.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The object to copy's name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The new copied 3DView object name.}\par
\f0\pard\sb180\shading1000{\fs30\b Freeze(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Freeze a geometry object to improve performance a bit - it cannot then be modified in any way.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The object to freeze.}\par
\f0\pard\sb180\shading1000{\fs30\b GetCameraDirection(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the camera direction.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of the camera direction vector.}\par
\f0\pard\sb180\shading1000{\fs30\b GetCameraPosition(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the camera position.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of the camera position coordinates.}\par
\f0\pard\sb180\shading1000{\fs30\b GetCameraUpDirection(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the camera up direction.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of the camera up direction vector.}\par
\f0\pard\sb180\shading1000{\fs30\b GetPosition(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the transformed (current) center position of an existing geometry.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20  An array of the transformed position or "FAILED".{\line}array[1] = X (Xcen){\line}array[2] = Y (Ycen){\line}array[3] = Z (Zcen)}\par
\f0\pard\sb180\shading1000{\fs30\b HitTest(shapeName,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Perform a hit test in the 3DView.{\line}A negative value for the coordinates defaults to the screen centre (camera view).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x coordinate in the GraphicsWindow coordinates within the 3DView.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y coordinate in the GraphicsWindow coordinates within the 3DView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array with the hit object name and its distance or "" for no hit.}\par
\f0\pard\sb180\shading1000{\fs30\b LastRotationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last completed rotation animation geometry object.}\par
\f0\pard\sb180\shading1000{\fs30\b LastTranslationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last completed translation animation geometry object.}\par
\f0\pard\sb180\shading1000{\fs30\b LoadModel(shapeName,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Load geometry models from a file.{\line}Supported formats include 3ds, lwo, obj, objz, stl and off.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file to load.{\line}Often image files etc are also required with the same name in the same folder.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array with the added geometry names.}\par
\f0\pard\sb180\shading1000{\fs30\b ModifyObject(shapeName,geometryName,action) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Perform an action on a light or geometry object.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry or light name.}\par
\f0\pard\sb75{\fs24\b action}\par
\f0\pard{\fs20 The action to perform.{\line}The allowed actions are:{\line}"X" remove{\line}"H" hide{\line}"S" show}\par
\f0\pard\sb180\shading1000{\fs30\b MoveCamera(shapeName,yaw,pitch,roll,move) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move the camera view direction and position.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b yaw}\par
\f0\pard{\fs20 The Left/Right rotation in degrees (Yaw).}\par
\f0\pard\sb75{\fs24\b pitch}\par
\f0\pard{\fs20 The Up/Down rotation in degrees (Pitch).}\par
\f0\pard\sb75{\fs24\b roll}\par
\f0\pard{\fs20 Spin view about view direction in degrees (Roll).}\par
\f0\pard\sb75{\fs24\b move}\par
\f0\pard{\fs20 The Forward/Backward movement in device coordinates (along the view direction).}\par
\f0\pard\sb180\shading1000{\fs30\b QueuedRotationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The number of currently queued completed rotation animations.}\par
\f0\pard\sb180\shading1000{\fs30\b QueuedTranslationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The number of currently queued completed translation animations.}\par
\f0\pard\sb180\shading1000{\fs30\b ResetCamera(shapeName,xPos,yPos,zPos,xDir,yDir,zDir,xUp,yUp,zUp) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset the camera position, view direction and up vector (optional).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b xPos}\par
\f0\pard{\fs20 The x position of the camera.}\par
\f0\pard\sb75{\fs24\b yPos}\par
\f0\pard{\fs20 The y position of the camera.}\par
\f0\pard\sb75{\fs24\b zPos}\par
\f0\pard{\fs20 The z position of the camera.}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 The x direction of the camera.}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 The y direction of the camera.}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 The z direction of the camera.}\par
\f0\pard\sb75{\fs24\b xUp}\par
\f0\pard{\fs20 The optional x up direction of the camera or "".}\par
\f0\pard\sb75{\fs24\b yUp}\par
\f0\pard{\fs20 The optional y up direction of the camera or "".}\par
\f0\pard\sb75{\fs24\b zUp}\par
\f0\pard{\fs20 The optional z up direction of the camera or "".}\par
\f0\pard\sb180\shading1000{\fs30\b ResetMaterial(shapeName,geometryName,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset the material for an existing geometry.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb180\shading1000{\fs30\b ReverseNormals(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reverse the outward normals for a geometry.{\line}For example, make the inside surface of a sphere the visible surface instead of the outside surface (skydome).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object to reverse outward normals.}\par
\f0\pard\sb180\shading1000{\fs30\b RotateGeometry(shapeName,geometryName,x,y,z,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotate a geometry object about its centre.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 X direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Y direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 Z direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 An angle in degrees to rotate.}\par
\f0\pard\sb180\shading1000{\fs30\b RotateGeometry2(shapeName,geometryName,x,y,z,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotate a geometry object about its centre (a second rotation).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 X direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Y direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 Z direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 An angle in degrees to rotate.}\par
\f0\pard\sb180\shading1000{\fs30\b RotateGeometry3(shapeName,geometryName,x,y,z,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotate a geometry object about its centre (a third rotation).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 X direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Y direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 Z direction of vector to rotate about.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 An angle in degrees to rotate.}\par
\f0\pard\sb180\shading1000{\fs30\b RotationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a rotation animation is completed.}\par
\f0\pard\sb180\shading1000{\fs30\b ScaleGeometry(shapeName,geometryName,scaleX,scaleY,scaleZ) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scale (zoom) a geometry object about its centre.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 X scale factor.}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 Y scale factor.}\par
\f0\pard\sb75{\fs24\b scaleZ}\par
\f0\pard{\fs20 Z scale factor.}\par
\f0\pard\sb180\shading1000{\fs30\b SetBackMaterial(shapeName,geometryName,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the back face material for an existing geometry.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 A colour or gradient brush for the object.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 A material for the object.{\line}The available options are:{\line}"E" Emmissive - constant brightness.{\line}"D" Diffusive - affected by lights.{\line}"S" Specular  - specular highlights.}\par
\f0\pard\sb180\shading1000{\fs30\b SetBillBoard(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set an object to rotate to always face the camera.{\line}This uses the 2nd and 3rd rotations.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb180\shading1000{\fs30\b SetCentre(shapeName,geometryName,x,y,z,options) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the centre for rotation and scale transformations of a geometry.{\line}By default this is the centre of a bounding box for the geometry, often 0,0,0.{\line}The centre is defined in the coordinates used to create the geometry.{\line}It does not have to be within the geometry.{\line}If a coordinate value is set to "", then the default value is used.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x coordinate of the centre.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y coordinate of the centre.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 The z coordinate of the centre.}\par
\f0\pard\sb75{\fs24\b options}\par
\f0\pard{\fs20 Options to control centre setting.  Multiples can be set, e.g. "R1R2R3" to set all rotations.{\line}"R1" First rotation transformation{\line}"R2" Second rotation transformation{\line}"R3" Third rotation transformation{\line}"S" Scale transformation}\par
\f0\pard\sb180\shading1000{\fs30\b SpecularExponent \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or set the specular exponent used for specular materials (default 5).}\par
\f0\pard\sb180\shading1000{\fs30\b SwapUpDirection(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotate (swap) the Y and Z direction of a geometry.{\line}This can be useful for geometries created with a Z up convention, coverting it to a Y up direction used by this extension.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb180\shading1000{\fs30\b TranslateGeometry(shapeName,geometryName,dx,dy,dz) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Translate (move) a geometry object.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The 3DView object.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 The geometry object.}\par
\f0\pard\sb75{\fs24\b dx}\par
\f0\pard{\fs20 X direction translation.}\par
\f0\pard\sb75{\fs24\b dy}\par
\f0\pard{\fs20 Y direction translation.}\par
\f0\pard\sb75{\fs24\b dz}\par
\f0\pard{\fs20 Z direction translation.}\par
\f0\pard\sb180\shading1000{\fs30\b TranslationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a translation animation is completed.}\par
\f0\pard\sb300\shading2000{\fs36\b LDArray}\par
\f0\pard{\fs20 A 1-Dimensional array method that is much faster than the standard SmallBasic arrays.{\line}{\line}Useful for arrays with greater than 100 to 1000 elements.{\line}An error will result in a return value "FAILED";}\par

\f0\pard\sb180\shading1000{\fs30\b Copy(array1,array2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy one array to another array.{\line}The dimensions of the 2 arrays must be the same.}\par
\f0\pard\sb75{\fs24\b array1}\par
\f0\pard{\fs20 The array to copy from.}\par
\f0\pard\sb75{\fs24\b array2}\par
\f0\pard{\fs20 The array to copy to.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b CopyNew(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy one array to a new array.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to copy.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A copy of the array or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CopyToSBArray(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy LDArray type to SmallBasic array type.{\line}{\line}The reverse operation (SmallBasic to LDArray) isn't possible becuase the SmallBasic indexes are not necessarily contiguous integers.{\line}Note also that a SmallBasic array cannot hold an empty string value, so these will not be copied.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The SmallBasic array or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Count(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the number of non-empty "" elements in the array.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of non-empty values in the array.}\par
\f0\pard\sb180\shading1000{\fs30\b Create(maxSize) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new array (can be used for numbers or character strings).}\par
\f0\pard\sb75{\fs24\b maxSize}\par
\f0\pard{\fs20 The maximum number of elements in the array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The array name or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromIndices(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new array from the indices of a Small Basic array.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 The SB array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The new array or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromValues(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new array from the values of a Small Basic array.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 The SB array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The new array or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Delete(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delete an existing array (not generally required, but can save memory if lots of arrays are created).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b GetIndex(sbArray,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the index of the first occurance of a value in an SB array.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 The SB array.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to find.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The index of value in the array, "" if not present or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetValue(array,index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get value in array.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index at which to get the value (indexed starting from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The value or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Load(array,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Load an array from a file.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to load the data into.{\line}The array must already exist.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file path to load the array from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of elements loaded.}\par
\f0\pard\sb180\shading1000{\fs30\b Save(array,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save an array to a file.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to save.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file path to save the file to.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of elements saved.}\par
\f0\pard\sb180\shading1000{\fs30\b Search(array,searchstring,match) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Obtain an array of the indices that have values that contain searchstring.{\line}The search is case in-sensitive.{\line}The input array is unchanged and the match array must be previously created with the same size as the array to check.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to check for matches.}\par
\f0\pard\sb75{\fs24\b searchstring}\par
\f0\pard{\fs20 The string to search for.}\par
\f0\pard\sb75{\fs24\b match}\par
\f0\pard{\fs20 An array to hold the index of matched values.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of matches found.}\par
\f0\pard\sb180\shading1000{\fs30\b SetValue(array,index,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set value in array.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index at which to add the value (indexed starting from 1).}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b Sort(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Perform a sort on an LDArray.  {\line}{\line}By default the sort is by string value, therefore 10 comes before 2.{\line}To sort by number value, all values must be a number (or empty).{\line}{\line}Empty values are placed at the end of the sort.{\line}The input array is replaced by the sorted array.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to sort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b SortIndex(array,index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Obtain an array of the indices in sort order of an array.{\line}{\line}By default the sort is by string value, therefore 10 comes before 2.{\line}To sort by number value, all values must be a number (or empty).{\line}{\line}Empty values are placed at the end of the sort.{\line}The input array is unchanged and the index array must be previously created with the same size as the array to sort.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to obtain an index order sort.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 An array to hold the index order of the sorted array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb300\shading2000{\fs36\b LDBits}\par
\f0\pard{\fs20 Bitwise logic to store binary flags in a single number as bits.{\line}A 32 bit number is used internally.{\line}This is like a 32 dimension array of 1s and 0s stored in single number.{\line}The bits (1 to 32) are indexed from 1.}\par

\f0\pard\sb180\shading1000{\fs30\b AndBits(var1,var2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Logically And 2 numbers.}\par
\f0\pard\sb75{\fs24\b var1}\par
\f0\pard{\fs20 The first number.}\par
\f0\pard\sb75{\fs24\b var2}\par
\f0\pard{\fs20 The second number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The And number (where both input bits are set).}\par
\f0\pard\sb180\shading1000{\fs30\b GetBit(var,bit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the bit value in a number.}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 The number to test.}\par
\f0\pard\sb75{\fs24\b bit}\par
\f0\pard{\fs20 A bit to test (1 to 32).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 0 (unset) or 1 (set).}\par
\f0\pard\sb180\shading1000{\fs30\b GetBits(var) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of bit values.}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 The number to get the bits.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 32 dimension array of bits (0 or 1).}\par
\f0\pard\sb180\shading1000{\fs30\b Not(var) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Logically Not a number.}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 The number to Not.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The Not number (all bits reversed).}\par
\f0\pard\sb180\shading1000{\fs30\b OrBits(var1,var2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Logically Or 2 numbers.}\par
\f0\pard\sb75{\fs24\b var1}\par
\f0\pard{\fs20 The first number.}\par
\f0\pard\sb75{\fs24\b var2}\par
\f0\pard{\fs20 The second number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The Or number (where either input bits are set).}\par
\f0\pard\sb180\shading1000{\fs30\b SetBit(var,bit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a bit in a number.}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 The number to set the bit.}\par
\f0\pard\sb75{\fs24\b bit}\par
\f0\pard{\fs20 A bit to set (1 to 32).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The modified number with bit set.}\par
\f0\pard\sb180\shading1000{\fs30\b UnsetBit(var,bit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Unset a bit in a number.}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 The number to unset the bit.}\par
\f0\pard\sb75{\fs24\b bit}\par
\f0\pard{\fs20 A bit to unset (1 to 32).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The modified number with bit unset.}\par
\f0\pard\sb180\shading1000{\fs30\b XOrBits(var1,var2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Logically XOr 2 numbers.}\par
\f0\pard\sb75{\fs24\b var1}\par
\f0\pard{\fs20 The first number.}\par
\f0\pard\sb75{\fs24\b var2}\par
\f0\pard{\fs20 The second number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The XOr number (where exclusively either input bits are set).}\par
\f0\pard\sb300\shading2000{\fs36\b LDBlueTooth}\par
\f0\pard{\fs20 BlueTooth control.{\line}The Advanced features refer to non file transfer (effectively writing a device driver).{\line}To communicate with a USB bluetooth stick you also need have an external bluetooth device, setting it to be dicoverable etc before running your SmallBasic program.}\par

\f0\pard\sb180\shading1000{\fs30\b Connect() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Advanced feature.{\line}Connect an external device and service to the bluetooth USB stick.{\line}You must first Initialise, then set the device, service and encoding.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False" on success or failure.}\par
\f0\pard\sb180\shading1000{\fs30\b DataAvailable \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The number of bytes of data received and waiting to be read.{\line}This could be used in a Timer to check for data received.}\par
\f0\pard\sb180\shading1000{\fs30\b Device \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The current bluetooth device.}\par
\f0\pard\sb180\shading1000{\fs30\b Encode \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Advanced feature.{\line}The current bluetooth data encoding.}\par
\f0\pard\sb180\shading1000{\fs30\b GetDevices() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of discovered bluetooth devices.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of devices or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b GetEncodings() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Advanced feature.{\line}Get a list of available encodings.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of encodings or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b GetServices() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Advanced feature.{\line}Get a list of available service protocols.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of services or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Initialise() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Initialise a bluetooth USB stick and detect discoverable external devices.{\line}As devices come into or out of range the devices list is updated.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False" for success or failure configuring a bluetooth interface.}\par
\f0\pard\sb180\shading1000{\fs30\b InRange \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a bluetooth device comes in range.{\line}Seems to keep firing unexpectedly.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDevice \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last device in or out of range.}\par
\f0\pard\sb180\shading1000{\fs30\b LastError \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the last error message.{\line}Error messages may be set for various failures.}\par
\f0\pard\sb180\shading1000{\fs30\b OutOfRange \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a bluetooth device goes out of range.{\line}Doesn't seem to work as expected.}\par
\f0\pard\sb180\shading1000{\fs30\b ReceiveData() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Advanced feature.{\line}Receive (fetch) data from a bluetooth device.{\line}The device must be Initialised and Connected.{\line}The encoding should also be set.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 String of received characters or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b ReceiveFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Receive (fetch) a file from an attached external bluetooth device.{\line}You must first Initialise, then set the device.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The location to save the received file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A result status message "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b SendData(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Advanced feature.{\line}Send data to a bluetooth device.{\line}The device must be Initialised and Connected.{\line}The encoding should also be set.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 A string of characters to send.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A result status message "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b SendFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Send a file to an attached external bluetooth device.{\line}You must first Initialise, then set the device.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file to send.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A result status message "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Service \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Advanced feature.{\line}The current bluetooth service.}\par
\f0\pard\sb300\shading2000{\fs36\b LDCall}\par
\f0\pard{\fs20 Call Functions with arguments, asyncronously from any extension or from a pre-compiled SmallBasic exe.}\par

\f0\pard\sb180\shading1000{\fs30\b CallAsync(dll,extension,obj,method,arguments) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Call any extension method asynchronously.{\line}See example LDCallAsync.{\line}If dll, extension, obj and arguments are all "", then method may be a subroutine in your SmallBasic program.}\par
\f0\pard\sb75{\fs24\b dll}\par
\f0\pard{\fs20 The extension dll (e.g. "LitDev.dll" or "SmallBasicLibrary.dll").}\par
\f0\pard\sb75{\fs24\b extension}\par
\f0\pard{\fs20 The extension namespace (usually the same as the dll name, e.g. "LitDev" or "MicroSoft.SmallBasic.Library" for SmallBasicLibrary.dll).}\par
\f0\pard\sb75{\fs24\b obj}\par
\f0\pard{\fs20 The extension object name.}\par
\f0\pard\sb75{\fs24\b method}\par
\f0\pard{\fs20 The extension method name.}\par
\f0\pard\sb75{\fs24\b arguments}\par
\f0\pard{\fs20 An array of arguments or "" for none.  A single argument doesn't have to be in an array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "PENDING" or an error message on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b CallComplete \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when an asynchronous subroutine method call completes.}\par
\f0\pard\sb180\shading1000{\fs30\b CallInclude(include,method) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Call a method in an included pre-compiled file.}\par
\f0\pard\sb75{\fs24\b include}\par
\f0\pard{\fs20 The include file name returned by Include method.}\par
\f0\pard\sb75{\fs24\b method}\par
\f0\pard{\fs20 The subroutine name to call in the included exe.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Compile(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Compile a secondary Small Basic file.{\line}Assumes that Small Basic is installed in the default location for your OS.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 A Small Basic file to compile (.sb).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The path of the compiled file (.exe) or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Function(funcName,arg1) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Call a Small Basic Sub as a function with one input argument.{\line}{\line}The input arguments(s) will be copied to an array called "args".{\line}The result should be put in a variable (may be an array) called "return".{\line}The variable "args" should be set to "" at the start of the program.{\line}The input parameter(s) are unchanged, while "args" and "return" are set to "" on return.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 The Small Basic Sub name.}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 An input value (may be an array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The result of the function held in optional variable "return" or an error message.}\par
\f0\pard\sb180\shading1000{\fs30\b Function2(funcName,arg1,arg2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Call a Small Basic Sub as a function with two input arguments.{\line}{\line}See Function for more details.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 The Small Basic Sub name.}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 1st input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg2}\par
\f0\pard{\fs20 2nd input value (may be an array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The result of the function held in variable "return" or an error message.}\par
\f0\pard\sb180\shading1000{\fs30\b Function3(funcName,arg1,arg2,arg3) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Call a Small Basic Sub as a function with three input arguments.{\line}{\line}See Function for more details.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 The Small Basic Sub name.}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 1st input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg2}\par
\f0\pard{\fs20 2nd input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg3}\par
\f0\pard{\fs20 3rd input value (may be an array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The result of the function held in variable "return" or an error message.}\par
\f0\pard\sb180\shading1000{\fs30\b Function4(funcName,arg1,arg2,arg3,arg4) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Call a Small Basic Sub as a function with four input arguments.{\line}{\line}See Function for more details.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 The Small Basic Sub name.}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 1st input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg2}\par
\f0\pard{\fs20 2nd input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg3}\par
\f0\pard{\fs20 3rd input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg4}\par
\f0\pard{\fs20 4th input value (may be an array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The result of the function held in variable "return" or an error message.}\par
\f0\pard\sb180\shading1000{\fs30\b Function5(funcName,arg1,arg2,arg3,arg4,arg5) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Call a Small Basic Sub as a function with five input arguments.{\line}{\line}See Function for more details.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 The Small Basic Sub name.}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 1st input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg2}\par
\f0\pard{\fs20 2nd input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg3}\par
\f0\pard{\fs20 3rd input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg4}\par
\f0\pard{\fs20 4th input value (may be an array).}\par
\f0\pard\sb75{\fs24\b arg5}\par
\f0\pard{\fs20 5th input value (may be an array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The result of the function held in variable "return" or an error message.}\par
\f0\pard\sb180\shading1000{\fs30\b Include(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reference a previously compiled program to use a subroutine method from.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 The full path to a secondary compiled Small Basic program to use (.exe)}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A name for the include file or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b LastCall \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last asynchronous call name.}\par
\f0\pard\sb180\shading1000{\fs30\b LastResult \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last asynchronous call return value.}\par
\f0\pard\sb300\shading2000{\fs36\b LDChart}\par
\f0\pard{\fs20 Chart control.}\par

\f0\pard\sb180\shading1000{\fs30\b AddChart(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a chart control.{\line}The current GraphicsWindow.BackgroundColor will be used for the background.{\line}The current GraphicsWindow.PenColor and Font properties will be used for the label text.{\line}For Example:{\line}GraphicsWindow.FontName = "Segoe UI"{\line}GraphicsWindow.FontBold = "False"}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the chart.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the chart.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The chart shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b ColourMap(chartName,hue,saturation,lightness,hsl,start,end,centralColour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set colour mapping for the chart.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 The chart name.}\par
\f0\pard\sb75{\fs24\b hue}\par
\f0\pard{\fs20 A hue (colour 0 to 360), default 0 (red).}\par
\f0\pard\sb75{\fs24\b saturation}\par
\f0\pard{\fs20 A saturation (intensity 0 to 1), default 0.5.}\par
\f0\pard\sb75{\fs24\b lightness}\par
\f0\pard{\fs20 A lightness (brightness 0 to 1), default 0.5.}\par
\f0\pard\sb75{\fs24\b hsl}\par
\f0\pard{\fs20 The parameter to change for different segments, options are:{\line}"Hue" (default) rainbow colours{\line}"Saturation" increasing intensity of colour{\line}"Lightness" increasing brightness}\par
\f0\pard\sb75{\fs24\b start}\par
\f0\pard{\fs20 Starting value for colour variation in the range [0 to 1], default 0.}\par
\f0\pard\sb75{\fs24\b end}\par
\f0\pard{\fs20 Ending value for colour variation in the range [0 to 1], default 1.}\par
\f0\pard\sb75{\fs24\b centralColour}\par
\f0\pard{\fs20 An optional circular gradient color centered on chart, default "".}\par
\f0\pard\sb180\shading1000{\fs30\b DoughnutFraction \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Radius fraction removed for doughnut chart, default 0.7.{\line} }\par
\f0\pard\sb180\shading1000{\fs30\b Highlight(chartName,label,fraction) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Highlight a chart value (move segment out).}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 The chart name.}\par
\f0\pard\sb75{\fs24\b label}\par
\f0\pard{\fs20 The segment label.}\par
\f0\pard\sb75{\fs24\b fraction}\par
\f0\pard{\fs20 A fraction of the radius to move segment out (0 to return it).}\par
\f0\pard\sb180\shading1000{\fs30\b HighlightDuration \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Time in ms for Highlight animations, default 100.{\line} }\par
\f0\pard\sb180\shading1000{\fs30\b LastChart \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last clicked chart.}\par
\f0\pard\sb180\shading1000{\fs30\b LastLabel \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last clicked chart segment label.}\par
\f0\pard\sb180\shading1000{\fs30\b Legend(chartName,scale,legend,background) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set legend properties.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 The chart name.}\par
\f0\pard\sb75{\fs24\b scale}\par
\f0\pard{\fs20 A scale factor for the legend and text labels, default 1}\par
\f0\pard\sb75{\fs24\b legend}\par
\f0\pard{\fs20 A legend style, options are:{\line}"None" no legend{\line}"Legend" separate legend{\line}"Overlay" names overlaying chart{\line}"Percent" percentages overlaying chart{\line}"Legend_Percent" (default) separate legend and percentages overlaying chart{\line}"}\par
\f0\pard\sb75{\fs24\b background}\par
\f0\pard{\fs20 The legend label text background is coloured, "True" or "False" (default).}\par
\f0\pard\sb180\shading1000{\fs30\b Properties(chartName,style,scale) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set chart properties.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 The chart name.}\par
\f0\pard\sb75{\fs24\b style}\par
\f0\pard{\fs20 A style for the chart, options are:{\line}"Pie" (default){\line}"Doughnut"{\line}"Bubble"{\line}"Bar"{\line}"Column"}\par
\f0\pard\sb75{\fs24\b scale}\par
\f0\pard{\fs20 A scale factor for the chart, default 1.}\par
\f0\pard\sb180\shading1000{\fs30\b SetData(chartName,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set data for a chart.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 The chart name.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 The data to set, which is a 1D array, indices are item names.{\line}Example:{\line}data["Fred"] = 25{\line}data["Mary"] = 15{\line}data["John"] = 40}\par
\f0\pard\sb180\shading1000{\fs30\b Update(chartName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Redraw (update) a chart.{\line}This restores any highlighted segments or applies any modified chart properties.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 The chart name.}\par
\f0\pard\sb180\shading1000{\fs30\b ValueClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a chart segment is clicked.}\par
\f0\pard\sb300\shading2000{\fs36\b LDClient}\par
\f0\pard{\fs20 Server and Client communication between computers.{\line}Separate programs are required for the server and client - this is for the client.}\par

\f0\pard\sb180\shading1000{\fs30\b CheckServer(server) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Test if a server is available for connection.{\line}Do not call this method at a high frequency (> 1 per second).}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 The server connection ip:port (e.g. "192.168.1.60:100").{\line}This value is returned by LDServer.Start.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "AVAILABLE" or "UNAVAILABLE"}\par
\f0\pard\sb180\shading1000{\fs30\b CloseDelay \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 A delay in ms (default 100) when disconnecting to allow a message to be sent before connection closed (Disconnect).{\line}This delay should also be set for the server in LDServer.CloseDelay.}\par
\f0\pard\sb180\shading1000{\fs30\b Connect(server,auto) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Connect to a server.}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 The server connection ip:port (e.g. "192.168.1.60:100").{\line}This value is returned by LDServer.Start.}\par
\f0\pard\sb75{\fs24\b auto}\par
\f0\pard{\fs20 Enable auto message passing "True" or "False".{\line}If this is used (recommended) then all client data is passed via server to all other clients, {\line}and no processing of send and receive events is required.{\line}The data is updated to arrays of data (indexed by client name) that is returned from the Update methods.{\line}The auto option should be the same for server and all clients.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" or "ALREADY_CONNECTED"}\par
\f0\pard\sb180\shading1000{\fs30\b Disconnect() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Disconnect the client from the server.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" or "NOT_CONNECTED"}\par
\f0\pard\sb180\shading1000{\fs30\b Disconnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when server disconnects this client.}\par
\f0\pard\sb180\shading1000{\fs30\b GetClients() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of current connected clients.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of current client names or "" for none.}\par
\f0\pard\sb180\shading1000{\fs30\b LastServerMessage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last server message.}\par
\f0\pard\sb180\shading1000{\fs30\b Name \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 This client's name.{\line}Get or set your name.}\par
\f0\pard\sb180\shading1000{\fs30\b SendMessage(message) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Send a message to the server.}\par
\f0\pard\sb75{\fs24\b message}\par
\f0\pard{\fs20 The message may be any variable including an array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" or "NOT_CONNECTED"}\par
\f0\pard\sb180\shading1000{\fs30\b ServerMessage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when the server sends a message to this client.}\par
\f0\pard\sb180\shading1000{\fs30\b UpdateDynamic(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Update client data when using the auto message passing.{\line}This is for small quantities of frequently changing data, like sprite coordinates.{\line}this method uses the last updated client data stored on the client and is therefore fast.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 The data for this client to propagate to other clients.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array indexed by client names with current data for all existing clients.}\par
\f0\pard\sb180\shading1000{\fs30\b UpdateStatic(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Update client data when using the auto message passing.{\line}This is for larger quantities of infrequently changing data, like client configuration.{\line}This method uses data stored and retrieved from the server so may be slower than UpdateDynamic since it waits for server retreived data,{\line}guaranteeing that all client data is fully synced.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 The data for this client to propagate to other clients.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array indexed by client names with current data for all existing clients.}\par
\f0\pard\sb300\shading2000{\fs36\b LDClipboard}\par
\f0\pard{\fs20 Clipboard methods.}\par

\f0\pard\sb180\shading1000{\fs30\b Clear() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Clear the clipboard;}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ClipboardChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when the clipboard status changes.}\par
\f0\pard\sb180\shading1000{\fs30\b GetFileList() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of file names from the clipboard.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of files or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetImage() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Load an image from the clipboard into ImageList.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The ImageList name or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetText() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get text from the clipboard.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The clipboard text or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ImageTransparency \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Use an extended format for SetImage that includes transparency ("True" default or "False").{\line}This extended format may not be recognised by some applications when pasted.}\par
\f0\pard\sb180\shading1000{\fs30\b SetFileList(fileList) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a list of files to the clipboard.}\par
\f0\pard\sb75{\fs24\b fileList}\par
\f0\pard{\fs20 An array (or single file) of file names (full path).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetImage(imageName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set an ImageList image to the clipboard.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetText(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set text to the clipboard.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to add to the clipboard.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDColours}\par
\f0\pard{\fs20 Gets the Standard SmallBasic colours and other colour utilities.}\par

\f0\pard\sb180\shading1000{\fs30\b GetBlue(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the Blue component of a colour.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to get the component from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The blue component (0 to 255).}\par
\f0\pard\sb180\shading1000{\fs30\b GetGreen(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the Green component of a colour.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to get the component from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The green component (0 to 255).}\par
\f0\pard\sb180\shading1000{\fs30\b GetHue(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the Hue component of a colour.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to get the component from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The hue component (0 to 360).}\par
\f0\pard\sb180\shading1000{\fs30\b GetLightness(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the Lightness component of a colour.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to get the component from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The lightness component (0 to 1).}\par
\f0\pard\sb180\shading1000{\fs30\b GetOpacity(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the Opacity component of a colour.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to get the component from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The opacity component (0 to 255).}\par
\f0\pard\sb180\shading1000{\fs30\b GetRed(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the Red component of a colour.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to get the component from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The red component (0 to 255).}\par
\f0\pard\sb180\shading1000{\fs30\b GetSaturation(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the Saturation component of a colour.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to get the component from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The saturation component (0 to 1).}\par
\f0\pard\sb180\shading1000{\fs30\b HSLtoRGB(H,S,L) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert a Hue, Saturation, Lightness (HSL) color to a Red, Green, Blue (RGB) colour used by SmallBasic.}\par
\f0\pard\sb75{\fs24\b H}\par
\f0\pard{\fs20 Hue (0 to 360).}\par
\f0\pard\sb75{\fs24\b S}\par
\f0\pard{\fs20 Saturation (0 to 1).}\par
\f0\pard\sb75{\fs24\b L}\par
\f0\pard{\fs20 Lightness (0 to 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An RGB colour}\par
\f0\pard\sb180\shading1000{\fs30\b SetOpacity(colour,opacity) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Modify the opacity of a colour.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to modify.}\par
\f0\pard\sb75{\fs24\b opacity}\par
\f0\pard{\fs20 The opacity (0 to 255).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The modified colour.}\par
\f0\pard\sb300\shading2000{\fs36\b LDCommPort}\par
\f0\pard{\fs20 Sends and receives data over the serial port{\line}Original Code by Nino Carrillo}\par

\f0\pard\sb180\shading1000{\fs30\b AvailablePorts() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Returns a list of available serial ports.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array containing the names of available serial ports.}\par
\f0\pard\sb180\shading1000{\fs30\b ClosePort() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Closes the open serial port.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOCONNECTION" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataReceived \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when the serial port receives data.}\par
\f0\pard\sb180\shading1000{\fs30\b ErrorReceived \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when the serial port receives an error.}\par
\f0\pard\sb180\shading1000{\fs30\b LastError \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last error for which an error event was raised.}\par
\f0\pard\sb180\shading1000{\fs30\b LastPort \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last port name for which an event was raised.}\par
\f0\pard\sb180\shading1000{\fs30\b OpenPort(portName,baudRate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Opens a serial port for use.  Assumes 8 databits, no parity.}\par
\f0\pard\sb75{\fs24\b portName}\par
\f0\pard{\fs20 String identifying which port to open in the form of "COM8".}\par
\f0\pard\sb75{\fs24\b baudRate}\par
\f0\pard{\fs20 Integer baud rate, for example 9600.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Error message, "SUCCESS", "NOSERIALPORTS", "PORTNOTFOUND" or "CONNECTIONFAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b RXAll() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reads all available bytes in the open comm port input buffer.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Returns a string of bytes ("NOCONNECTION" or "FAILED" on failure).}\par
\f0\pard\sb180\shading1000{\fs30\b RXByte() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reads one byte from the open serial port and returns that byte as an integer.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 One integer value between 0 and 255 ("NOCONNECTION" or "FAILED" on failure).}\par
\f0\pard\sb180\shading1000{\fs30\b RXChar() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reads one byte from the open serial port and returns that byte as a unicode character.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 One unicode character ("NOCONNECTION" or "FAILED" on failure).}\par
\f0\pard\sb180\shading1000{\fs30\b SetDataBits(dataBits) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sets current port data bits. {\line}5 to 8 (default).}\par
\f0\pard\sb75{\fs24\b dataBits}\par
\f0\pard{\fs20 The data bits:{\line}5 to 8 (default).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOCONNECTION" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetEncoding(encoding) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sets current port encoding for send and receive text conversion.}\par
\f0\pard\sb75{\fs24\b encoding}\par
\f0\pard{\fs20 The encoding:{\line}"Ascii" (default), "Unicode", "UTF7", "UTF8", "UTF32" or "BigEndianUnicode".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOCONNECTION" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetHandshake(handshake) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sets or clears hardware flow control for the current port.}\par
\f0\pard\sb75{\fs24\b handshake}\par
\f0\pard{\fs20 "H" to select hardware flow control, "HX" for hardware and software flow control, "X" for software fow control, any other character to clear.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOCONNECTION" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetParity(parity) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sets current port parity. }\par
\f0\pard\sb75{\fs24\b parity}\par
\f0\pard{\fs20 The parity:{\line}"None" (default), "Even", "Mark", "Odd" or "Space".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOCONNECTION" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetStopBits(stopBits) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Current port stop bits. }\par
\f0\pard\sb75{\fs24\b stopBits}\par
\f0\pard{\fs20 The stop bits:{\line}"One" (default), "None", "OnePointFive" or "Two".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOCONNECTION" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SwapPort(portName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Switch the current active port to a previously opened port.}\par
\f0\pard\sb75{\fs24\b portName}\par
\f0\pard{\fs20 String identifying a port that is already opened.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Error message, "SUCCESS" or "PORTNOTFOUND".}\par
\f0\pard\sb180\shading1000{\fs30\b TXByte(dataByte) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sends one byte to the serial port.}\par
\f0\pard\sb75{\fs24\b dataByte}\par
\f0\pard{\fs20 The byte to be written to the port.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOCONNECTION" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b TXString(dataString) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sends a string to the serial port.}\par
\f0\pard\sb75{\fs24\b dataString}\par
\f0\pard{\fs20 String value to be sent.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOCONNECTION" or "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDController}\par
\f0\pard{\fs20 Get input from one or more USB attached game controllers (e.g. gamepad or joystick).  If there is more than 1 attached device, then they are numbered from 1.{\line}{\line}SlimDX runtme for .Net 4.0 requires to be installed before this object can be used (http://slimdx.org/download.php).}\par

\f0\pard\sb180\shading1000{\fs30\b Buttons(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the pressed state of controller buttons.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 A USB attached controller number (e.g. joystick or gamepad) indexed from 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of button states ("True" or "False")}\par
\f0\pard\sb180\shading1000{\fs30\b Count \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the number of attached controllers.}\par
\f0\pard\sb180\shading1000{\fs30\b Position(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the position of a controller joystick.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 A USB attached controller number (e.g. joystick or gamepad) indexed from 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of (X,Y,Z) position values (-100 to 100)}\par
\f0\pard\sb180\shading1000{\fs30\b POV(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the POV (Point Of View) of controller.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 A USB attached controller number (e.g. joystick or gamepad) indexed from 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of (X,Y,Z) POV values (degrees)}\par
\f0\pard\sb180\shading1000{\fs30\b Rotation(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the rotation of a controller joystick.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 A USB attached controller number (e.g. joystick or gamepad) indexed from 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of (X,Y,Z) rotation values (-100 to 100)}\par
\f0\pard\sb180\shading1000{\fs30\b Sliders(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the slider position of controller sliders.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 A USB attached controller number (e.g. joystick or gamepad) indexed from 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of slider positions (0 to 100)}\par
\f0\pard\sb300\shading2000{\fs36\b LDControls}\par
\f0\pard{\fs20 Controls for the GraphicsWindow.}\par

\f0\pard\sb180\shading1000{\fs30\b AddBrowser(width,height,url) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a web browser.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The browser width.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The browser height.}\par
\f0\pard\sb75{\fs24\b url}\par
\f0\pard{\fs20 The html pane to load (e.g. http://smallbasic.com or www.google.com)}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The browser control name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddCheckBox(title) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a checkbox dialog control.}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 The title of the control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The checkbox shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddComboBox(list,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a combobox dialog control.}\par
\f0\pard\sb75{\fs24\b list}\par
\f0\pard{\fs20 An array containing the combobox data.{\line}{\line}The first index is the row or node number and the value of the array is the display text at the current node.{\line}{\line}list[1] = "Option 1"{\line}list[2] = "Option 2"{\line}list[3] = "Option 3"{\line}list[4] = "Option 4"}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The drop down height of the control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The combobox shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddContextMenu(shapeName,items,images) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a right click context menu for a control or shape that supports context menus.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The control or shape name.}\par
\f0\pard\sb75{\fs24\b items}\par
\f0\pard{\fs20 An array of context menu item selection texts.}\par
\f0\pard\sb75{\fs24\b images}\par
\f0\pard{\fs20 Optional array of image icons, any or all may be "".{\line}They may be the result of ImageList.LoadImage or local or network image file.}\par
\f0\pard\sb180\shading1000{\fs30\b AddDataView(width,height,headings) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a dataview control.{\line}All rows and columns are indexed from 1.{\line}This control always appears on top of all other objects in the GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the control.}\par
\f0\pard\sb75{\fs24\b headings}\par
\f0\pard{\fs20 An array of headings for the dataview.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The dataview shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddDocumentViewer(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a document viewer dialog control.{\line}You can view XPS documents (MS version of PDF) with this.{\line}Drag and drop is auto set for this control.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The document viewer shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddListBox(list,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a listbox dialog control.}\par
\f0\pard\sb75{\fs24\b list}\par
\f0\pard{\fs20 An array containing the listbox data.{\line}{\line}The first index is the row or node number and the value of the array is the display text at the current node.{\line}{\line}list[1] = "Option 1"{\line}list[2] = "Option 2"{\line}list[3] = "Option 3"{\line}list[4] = "Option 4"{\line}{\line}Alternatively, this can be a LDArray or LDList.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The listbox shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddListView(width,height,headings) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a ListView control.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the control.}\par
\f0\pard\sb75{\fs24\b headings}\par
\f0\pard{\fs20 An array of headings for the listview.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The listview shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddMediaPlayer(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a media player (to play videos etc).{\line}Drag and drop is auto set for this control.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The media player width.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The media player height.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The media player control name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddMenu(width,height,menuList,iconList,checkList) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a menu control.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the control.}\par
\f0\pard\sb75{\fs24\b menuList}\par
\f0\pard{\fs20 An array of menu items.  The index is the menu display name and the value is the parent display name.{\line}The top level display name should be "Main".  The names should be unique since they will be returned on click event.{\line}A separator is "-", "--", "---" etc since they have to be unique and cannot be selected.{\line}{\line}menuList["File"] = "Main"{\line}menuList["Open"] = "File"{\line}menuList["-"] = "File"{\line}menuList["Exit"] = "File"{\line}menuList["Help"] = "Main"{\line}menuList["Show Help"] = "Help"}\par
\f0\pard\sb75{\fs24\b iconList}\par
\f0\pard{\fs20 An optional array of icon images (URL or ImageList) or "" for none.{\line}{\line}iconList["File"] = Program.Directory+"/file.png"}\par
\f0\pard\sb75{\fs24\b checkList}\par
\f0\pard{\fs20 An optional array to identify items as checkable or "" for none.{\line}The value is the initial checked state "True" or "False".{\line}{\line}checkList["Show Help"] = "True"}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The menu shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddPasswordBox(width,height,length) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a password box control (texbox with characters not displayed and PasswordEntered event only when return is pressed).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the control.}\par
\f0\pard\sb75{\fs24\b length}\par
\f0\pard{\fs20 The maximum number of characters in the password.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The password box shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddProgressBar(width,height,orientation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a progress bar control.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the control.}\par
\f0\pard\sb75{\fs24\b orientation}\par
\f0\pard{\fs20 Horizontal or vertical ("H" or "V").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The progress bar shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRadioButton(title,group) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a radio button control.{\line}Only one radio button in a group can be set (they are exclusive).}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 A text description for the radio button.}\par
\f0\pard\sb75{\fs24\b group}\par
\f0\pard{\fs20 A name to group radio buttons.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The radio button shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRichTextBox(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a RichTextBox.{\line}Drag and drop is auto set for this control.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the RichTextBox.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the RichTextBox.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The RichTextBox name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddSlider(width,height,orientation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a slider control.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the control.}\par
\f0\pard\sb75{\fs24\b orientation}\par
\f0\pard{\fs20 Horizontal or vertical ("H" or "V").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The slider shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddTreeView(tree,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a treeview dialog control.}\par
\f0\pard\sb75{\fs24\b tree}\par
\f0\pard{\fs20 A 2D array containing the treeview data.{\line}{\line}The first index is the row or node number and the second index is the parent node of the current node (0 for top level).{\line}The value of the array is the display text at the current node.{\line}{\line}tree[1][0] = "Level 1"{\line}tree[2][1] = "Level 1 1"{\line}tree[3][1] = "Level 1 2"{\line}tree[4][0] = "Level 2"}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the control.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The treeview shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AllowDrop(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set shape to allow drag and drop.{\line}Currently only the following are implemented without using FileDropped event to process the dropped file(s):{\line}File path to TextBox (or file paths to MultiLineTextBox).{\line}File opened in RichTextBox.{\line}XPS file opened in DocumentViewer.{\line}Image set in Image or Background.{\line}Media for MediaPlayer (only works if valid media is already loaded).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to allow drop or "Background".}\par
\f0\pard\sb180\shading1000{\fs30\b BrowserHistory(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of the browser history (pages loaded).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The browser name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The array of urls in the history.}\par
\f0\pard\sb180\shading1000{\fs30\b BrowserNavigate(shapeName,direction) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move browser page forward or backwards.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The browser name.}\par
\f0\pard\sb75{\fs24\b direction}\par
\f0\pard{\fs20 "F" or "B" for forwards or backwards.}\par
\f0\pard\sb180\shading1000{\fs30\b BrowserPageLoaded \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a browser page is loaded.}\par
\f0\pard\sb180\shading1000{\fs30\b BrowserSetURL(shapeName,url) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a web browser page.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The browser name.}\par
\f0\pard\sb75{\fs24\b url}\par
\f0\pard{\fs20 The html pane to load (e.g. http://smallbasic.com or www.google.com)}\par
\f0\pard\sb180\shading1000{\fs30\b CheckBoxChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a checkbox is clicked.}\par
\f0\pard\sb180\shading1000{\fs30\b CheckBoxGetState(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a checkbox checked state.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The checkbox to get state.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The checkbox checked state.}\par
\f0\pard\sb180\shading1000{\fs30\b CheckBoxState(shapeName,state) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a checkbox checked state.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The checkbox shape name.}\par
\f0\pard\sb75{\fs24\b state}\par
\f0\pard{\fs20 The checkbox check state ("True" or "False").}\par
\f0\pard\sb180\shading1000{\fs30\b ComboBoxContent(shapeName,list) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Replace a combobox list.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The combobox shape name.}\par
\f0\pard\sb75{\fs24\b list}\par
\f0\pard{\fs20 An array containing the combobox data.{\line}{\line}The first index is the row or node number and the value of the array is the display text at the current node.{\line}{\line}list[1] = "Option 1"{\line}list[2] = "Option 2"{\line}list[3] = "Option 3"{\line}list[4] = "Option 4"}\par
\f0\pard\sb180\shading1000{\fs30\b ComboBoxGetSelected(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a combobox selected node.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The combobox to get node.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The combobox selected node.}\par
\f0\pard\sb180\shading1000{\fs30\b ComboBoxItemChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a combobox selection changes or selected item is clicked.}\par
\f0\pard\sb180\shading1000{\fs30\b ComboBoxSelect(shapeName,node) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Select a node in a combobox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The combobox shape name.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 The node to select.}\par
\f0\pard\sb180\shading1000{\fs30\b ContextMenuClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a shape or control right click context menu item is selected.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewAllowSort(shapeName,allow) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Allow a dataview control to be column sorted by user clicking header.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b allow}\par
\f0\pard{\fs20 Allow "True" (default) or disallow "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewAllowUserEntry(shapeName,allow) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Allow user to add data in the last row.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b allow}\par
\f0\pard{\fs20 Allow user data entry "True" (default) or "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewButtonClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a dataview button is clicked.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewCellValueChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a dataview cell value changes after it is commited, for example by selecting away from the cell.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewClear(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Clear all rows in a dataview.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColAlignment(shapeName,col,alignment) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the alignment for a dataview column.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number.}\par
\f0\pard\sb75{\fs24\b alignment}\par
\f0\pard{\fs20 "Left", "Center" or "Right"}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColumnReadOnly(shapeName,col,readOnly) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a dataview column to be read only.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number.}\par
\f0\pard\sb75{\fs24\b readOnly}\par
\f0\pard{\fs20 Set as read only "True" or "False" (default).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColumnSort(shapeName,col,ascending) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sort dataview entries by a column.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number to sort by.}\par
\f0\pard\sb75{\fs24\b ascending}\par
\f0\pard{\fs20 Sort ascending ("True") or descending ("False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColumnVisible(shapeName,col,visible) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a dataview column to be visible or not.{\line}This may be used for example to hide an id column of a database.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number.}\par
\f0\pard\sb75{\fs24\b visible}\par
\f0\pard{\fs20 Set as visible "True" (default) or "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColumnWidths(shapeName,widths) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the widths of columns.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b widths}\par
\f0\pard{\fs20 An array of widths for the columns, "" to reset to auto sizing.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewDeleteRow(shapeName,row) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delete a row from a dataview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewGetFocus(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the current dataview cell with focus.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 1D array with the row and column number with focus, or "".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewGetRow(shapeName,row) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a row of data from a dataview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of values (one for each column) or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewGetSelected(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of all selected cells in a dataview.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2D array of rows and columns selected.{\line}cells[1][1] = row, cells[1][2] = column.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewGetValue(shapeName,row,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a dataview cell value.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The cell value or "".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewReadFromCSV(shapeName,fileName,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add data from a csv (comma separated values) text file into a dataview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path for the csv file.}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 Append to the dataview "True" or "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewRowColours(shapeName,row,background,foreground) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a row of data background and foreground (pen) colours.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number.  If this is set to 0 then all alternating rows are set.}\par
\f0\pard\sb75{\fs24\b background}\par
\f0\pard{\fs20 The background colour.}\par
\f0\pard\sb75{\fs24\b foreground}\par
\f0\pard{\fs20 The foreground colour.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewRowCount(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the number of rows in a dataview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of rows in the dataview.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSaveAsCSV(shapeName,fileName,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Write an entire dataview to a csv (comma separated values) text file.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path for the csv file.}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 Append to the csv file "True" or "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSelectionChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a dataview selection changes.{\line}This event is not called for dataview button clicks, use DataViewButtonClicked.{\line}This event is not called for dataview checkbox or combobox clicks, use DataViewCellValueChanged.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetColumnButton(shapeName,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Change a dataview column control to be Buttons.{\line}This should be set before data is added, after the dataview is created.{\line}If the dataview is bound to a database, then set this after LDDataBase.EditTable is set.{\line}The data for these cells will be the button title.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetColumnCheckBox(shapeName,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Change a dataview column control to be CheckBoxes.{\line}This should be set before data is added, after the dataview is created.{\line}If the dataview is bound to a database, then set this after LDDataBase.EditTable is set.{\line}The data for these cells should be "True" or "False".}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetColumnComboBox(shapeName,col,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Change a dataview column control to be ComboBoxes with selectable values.{\line}This should be set before data is added, after the dataview is created.{\line}If the dataview is bound to a database, then set this after LDDataBase.EditTable is set.{\line}The values to get and set for the cells are the labels set with the data parameter.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 An array of data selections for the combo boxes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetFocus(shapeName,row,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the focus to a dataview cell.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetRow(shapeName,row,values) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a row of data to a dataview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number.{\line}If the row number is larger than the current number of rows a new row is added, otherwise the row data is over-written.}\par
\f0\pard\sb75{\fs24\b values}\par
\f0\pard{\fs20 An array of values (one for each column).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetValue(shapeName,row,col,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a dataview cell value.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The dataview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to set.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DocumentViewerLoadXPS(shapeName,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Load an XPS file to a document viewer dialog control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The document viewer control.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The XPS file to load and view.}\par
\f0\pard\sb180\shading1000{\fs30\b FileDropped \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a file is dropped on an object set with AllowDrop.}\par
\f0\pard\sb180\shading1000{\fs30\b LastBrowser \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last browser where a page was loaded.}\par
\f0\pard\sb180\shading1000{\fs30\b LastBrowserPage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last browser page loaded (the url).}\par
\f0\pard\sb180\shading1000{\fs30\b LastCheckBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last checkbox that was clicked.}\par
\f0\pard\sb180\shading1000{\fs30\b LastCheckBoxState \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last checkbox checked state ("True" or "False").}\par
\f0\pard\sb180\shading1000{\fs30\b LastComboBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last combobox where a selection changed.}\par
\f0\pard\sb180\shading1000{\fs30\b LastComboBoxIndex \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last combobox selection changed index (row number).}\par
\f0\pard\sb180\shading1000{\fs30\b LastContextControl \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The contol or shape of the last right click context menu item selected.}\par
\f0\pard\sb180\shading1000{\fs30\b LastContextItem \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The index of the last shape or control right click context menu item selected.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDataBaseTable \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last database table for which a dataview selection changed.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDataView \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last dataview where a selection changed.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDataViewButtonClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the cell row, column and value of the last dataview button clicked.{\line}This is a 3 element array.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDataViewCellValueChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the cell row, column and value of a dataview cell whose value has changed.{\line}This is a 3 element array.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDropFiles \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 An array with the last file(s) that were dropped.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDropShape \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last object a file was dropped on.}\par
\f0\pard\sb180\shading1000{\fs30\b LastListBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last listbox where a selection changed.}\par
\f0\pard\sb180\shading1000{\fs30\b LastListBoxIndex \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last listbox selection changed index (row number).}\par
\f0\pard\sb180\shading1000{\fs30\b LastListView \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last listview where a selection changed.}\par
\f0\pard\sb180\shading1000{\fs30\b LastListViewColumn \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last listview selected column number.}\par
\f0\pard\sb180\shading1000{\fs30\b LastListViewRow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last listview selected row number.}\par
\f0\pard\sb180\shading1000{\fs30\b LastMediaPlayer \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last media player for which an event occurred.}\par
\f0\pard\sb180\shading1000{\fs30\b LastMenuControl \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last menu control selected.}\par
\f0\pard\sb180\shading1000{\fs30\b LastMenuItem \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last menu item selected.}\par
\f0\pard\sb180\shading1000{\fs30\b LastPassword \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last password entered.}\par
\f0\pard\sb180\shading1000{\fs30\b LastPasswordBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The password box for which an event occurred.}\par
\f0\pard\sb180\shading1000{\fs30\b LastRadioButton \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last radio button that was selected.}\par
\f0\pard\sb180\shading1000{\fs30\b LastRadioButtonGroup \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The group name for the last radio button selected.}\par
\f0\pard\sb180\shading1000{\fs30\b LastRichTextBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The rich text box for which an event occurred.}\par
\f0\pard\sb180\shading1000{\fs30\b LastSlider \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last slider for which an event occurred.}\par
\f0\pard\sb180\shading1000{\fs30\b LastSliderValue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last slider value.}\par
\f0\pard\sb180\shading1000{\fs30\b LastTreeView \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last treeview where a selection changed.}\par
\f0\pard\sb180\shading1000{\fs30\b LastTreeViewIndex \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last treeview selection changed index (row number).}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxContent(shapeName,list) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Replace a listbox list.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listbox shape name.}\par
\f0\pard\sb75{\fs24\b list}\par
\f0\pard{\fs20 An array containing the listbox data.{\line}{\line}The first index is the row or node number and the value of the array is the display text at the current node.{\line}{\line}list[1] = "Option 1"{\line}list[2] = "Option 2"{\line}list[3] = "Option 3"{\line}list[4] = "Option 4"{\line}{\line}Alternatively, this can be a LDArray or LDList.}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxGetSelected(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a listbox selected node.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listbox to get node.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The listbox selected node number.{\line}If the selection mode is not single (see ListBoxSelectionMode) then an array of nodes is returned.{\line}The return is "" for no selected nodes.}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxItemChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a listbox selection changes or selected item is clicked.}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxSelect(shapeName,node) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Select a node or nodes in a listbox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listbox shape name.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 The node number to select.{\line}This can be an array of nodes if the selection mode is not single (see ListBoxSelectionMode).}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxSelectionMode(shapeName,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the selection mode for listbox control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listbox control name.}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 One of the following:{\line}"Single" - single selection (default).{\line}"Multiple" - multiple selections using control key.{\line}"Extended" - extended selections using control and shift keys.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewClear(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove all rows from a listview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listview control.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewColAlignment(shapeName,col,alignment) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the alignment for a listview column.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listview control.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b alignment}\par
\f0\pard{\fs20 "Left", "Center" or "Right"}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewDeleteRow(shapeName,row) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delete a row of data from a listview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number (indexed from 1).{\line}If the row number is larger than the current number of rows then no action is taken.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewEdit(shapeName,editable) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Change a listview to editable status.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listview shape name.}\par
\f0\pard\sb75{\fs24\b editable}\par
\f0\pard{\fs20 "True" with editable TextBoxes or "False" uneditable TextBlocks.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewGetRow(shapeName,row) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a row of data from a listview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of values (one for each column) or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewRowCount(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the number of rows in a listview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listview control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of rows in the listview.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewSelectionChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a listview selection changes.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewSetRow(shapeName,row,values) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a row of data to a listview control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The listview control.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row number (indexed from 1).{\line}If the row number is larger than the current number of rows a new row is added, otherwise the row data is over-written.}\par
\f0\pard\sb75{\fs24\b values}\par
\f0\pard{\fs20 An array of values (one for each column).}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerEnded \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a media player ends playing current media.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerLoad(shapeName,media) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the media for a media player.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb75{\fs24\b media}\par
\f0\pard{\fs20 The media to load, e.g. an image, music or video file, jp, mp3, mpg, avi, wmv etc.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerOpened \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a media player opens new media.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerPause(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pause a media player playback (using current loaded media).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerPlay(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Start a media player playback (using current loaded media).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerPlayTime(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a media play time (using current loaded media).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The media play time in ms.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerPosition(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a media current position (using current loaded media).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The media current position in ms.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerSeek(shapeName,seek) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Position a media player position (using current loaded media).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb75{\fs24\b seek}\par
\f0\pard{\fs20 The new play position in ms.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerSpeed(shapeName,speed) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the playback speed for a media player.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb75{\fs24\b speed}\par
\f0\pard{\fs20 The speed (0 to 100) default 1 (normal playback).}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerStop(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stop a media player playback (using current loaded media).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerStretch(shapeName,stretch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a visual media stretch - how the visual fills its area.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb75{\fs24\b stretch}\par
\f0\pard{\fs20 The stretch method.  Available stretch options are:{\line}"None" (The content preserves its original size).{\line}"Uniform" (The content is resized to fit in the destination dimensions while it preserves its native aspect ratio - Default).{\line}"Fill" (The content is resized to fill the destination dimensions. The aspect ratio is not preserved).{\line}"UniformToFill" (The content is resized to fill the destination dimensions while it preserves its native aspect ratio, clipping as required).}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerVolume(shapeName,volume) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the volume for a media player.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The media player name.}\par
\f0\pard\sb75{\fs24\b volume}\par
\f0\pard{\fs20 The volume (0 to 1) default 0.5.}\par
\f0\pard\sb180\shading1000{\fs30\b MenuBackground(shapeName,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the background colour for sub menus.  {\line}The main top menu can be coloured separately with LDShapes.BrushColour.{\line}Note that separators are not coloured and it is often best to just colour the top menu.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The menu shape name.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The background colour.}\par
\f0\pard\sb180\shading1000{\fs30\b MenuChecked(shapeName,itemName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the check state of a menu item.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The menu shape name.}\par
\f0\pard\sb75{\fs24\b itemName}\par
\f0\pard{\fs20 The menu item name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b MenuClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a menu item is selected.}\par
\f0\pard\sb180\shading1000{\fs30\b PasswordEntered \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a password is entered (Return key pressed).}\par
\f0\pard\sb180\shading1000{\fs30\b ProgressBarValue(shapeName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set progress bar value (progress).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The progress bar shape name.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The progress value (0 to 100).}\par
\f0\pard\sb180\shading1000{\fs30\b RadioButtonClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a radio button selection changes (it is clicked).}\par
\f0\pard\sb180\shading1000{\fs30\b RadioButtonGet(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a radio button state.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The radio button to get state.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The radio button state.}\par
\f0\pard\sb180\shading1000{\fs30\b RadioButtonSet(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a radio button to selected.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The radio button to set.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxCaseSensitive \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Whether word or phrase highlighting is case sensitive "True" or "False" (default).{\line}Set this before RichTextBoxWord is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxClear(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Clear all text from the RichTextBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The RichTextBox control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxDefault(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a default font style using the current RichTextBox Properties.{\line}Note RichTextBoxFontDecoration not available for this option.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The RichTextBox control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontBackground \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The font background colour.{\line}Set this before RichTextBoxSelection, RichTextBoxWord or RichTextBoxDefault is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontBold \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The font bold style "True" or "False".{\line}Set this before RichTextBoxSelection, RichTextBoxWord or RichTextBoxDefault is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontFamily \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The font family e.g. "Century Gothic".{\line}Set this before RichTextBoxSelection, RichTextBoxWord or RichTextBoxDefault is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontForeground \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The font foreground colour.{\line}Set this before RichTextBoxSelection, RichTextBoxWord or RichTextBoxDefault is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontItalic \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The font italic style "True" or "False".{\line}Set this before RichTextBoxSelection, RichTextBoxWord or RichTextBoxDefault is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontSize \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The font point size.{\line}Set this before RichTextBoxSelection, RichTextBoxWord or RichTextBoxDefault is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontUnderline \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The font underline style "True" or "False".{\line}Set this before RichTextBoxSelection, RichTextBoxWord or RichTextBoxDefault is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxGetText(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get text (unformatted) in a RichTextBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The RichTextBox control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The text.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxIndentToTab \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert first character indents to tabs "True" (default) or "False".{\line}A tab typed as a first character on a line in a RichTextBox creates an indent unless this is set to "True".}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxLoad(shapeName,fileName,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Load text and formatting from a file in rtf format to a RichTextBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The RichTextBox control.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 File to load the text and formatting from.}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 Append to existing text "True" or "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxMargins(left,right,top,bottom) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set margins (in pixels) for RichTextBox paragraphs.{\line}A new paragraph is created for each text appended (or created) using RichTextBoxSetText.}\par
\f0\pard\sb75{\fs24\b left}\par
\f0\pard{\fs20 Left margin (default 0).}\par
\f0\pard\sb75{\fs24\b right}\par
\f0\pard{\fs20 Right margin (default 0).}\par
\f0\pard\sb75{\fs24\b top}\par
\f0\pard{\fs20 Top margin (default 0).}\par
\f0\pard\sb75{\fs24\b bottom}\par
\f0\pard{\fs20 Bottom margin (default 0).}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxReadOnly \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The read only state for the RichTextBox "True" or "False.{\line}Set this before AddRichTextBox is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxSave(shapeName,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save RichTextBox text and formatting to a file in rtf format.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The RichTextBox control.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 File to save the text and formatting to.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxSelection(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a font style of selected RichTextBox text using the current RichTextBox Properties.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The RichTextBox control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxSetText(shapeName,text,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set text (unformatted) in a RichTextBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The RichTextBox control.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Text to load.}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 Append to existing text "True" or "False".{\line}A new paragraph is created if text is appended.  See RichTextBoxMargins to set margins for the paragraph.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxTextAlignment \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The text alignment "Center" "Left" "Right" or "Justify".{\line}Set this before AddRichTextBox is called.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxTextTyped \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when text is typed into a rich text box.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxWord(shapeName,text,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a font style of a word or phrase using the current RichTextBox Properties.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The RichTextBox control.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to change (Case sensitive set by RichTextBoxCaseSensitive parameter).}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 Contol over which instances of the word or phrase to set.{\line}0 - All instances{\line}1 - First instance{\line}2 - Last instance}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetButtonStyle(shapeName,brushUnpressed,brushMouseOver,brushPressed,penUnpressed,penMouseOver,penPressed,radius,shine) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Modify the style of a button.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The button to modify.}\par
\f0\pard\sb75{\fs24\b brushUnpressed}\par
\f0\pard{\fs20 The colour of the unpressed button, may be a gradient brush.}\par
\f0\pard\sb75{\fs24\b brushMouseOver}\par
\f0\pard{\fs20 The colour of the button when the mouse is over it, may be a gradient brush.}\par
\f0\pard\sb75{\fs24\b brushPressed}\par
\f0\pard{\fs20 The colour of the pressed button, may be a gradient brush.}\par
\f0\pard\sb75{\fs24\b penUnpressed}\par
\f0\pard{\fs20 The text font colour of the unpressed button.}\par
\f0\pard\sb75{\fs24\b penMouseOver}\par
\f0\pard{\fs20 The text font colour of the button when the mouse is over it.}\par
\f0\pard\sb75{\fs24\b penPressed}\par
\f0\pard{\fs20 The text font colour of the pressed button.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 The button corner radius (default 9).}\par
\f0\pard\sb75{\fs24\b shine}\par
\f0\pard{\fs20 Apply a 'shine' effect, "True" (default) or "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetCursorPosition(shapeName,position) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the cursor caret to specified position within a textbox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The textbox shape name.}\par
\f0\pard\sb75{\fs24\b position}\par
\f0\pard{\fs20 The cursor character position (0 is before first character or a large value e.g. 1000 will set the cursor to the end).}\par
\f0\pard\sb180\shading1000{\fs30\b SetCursorToEnd(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scroll the cursor caret to the end of a textbox or richtextbox.{\line}This is for multi-line textboxes or richtextboxes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The textbox shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b SetSpellCheck(shapeName,state) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the spell checking for a textbox or richtextbox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The textbox or richtextbox shape name.}\par
\f0\pard\sb75{\fs24\b state}\par
\f0\pard{\fs20 "True" or "False"}\par
\f0\pard\sb180\shading1000{\fs30\b SliderChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a slider is changed.}\par
\f0\pard\sb180\shading1000{\fs30\b SliderGetValue(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get slider value (position).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The slider shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The slider value (0 to 100).}\par
\f0\pard\sb180\shading1000{\fs30\b SliderMaximum \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The maximum slider value, default is 100, the minimum is always 0.{\line}Set this before calling AddSlider.}\par
\f0\pard\sb180\shading1000{\fs30\b SliderValue(shapeName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set slider value (position).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The slider shape name.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The slider value (0 to 100).}\par
\f0\pard\sb180\shading1000{\fs30\b TextBoxReadOnly(shapeName,readOnly) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a textbox readonly state.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The textbox control.}\par
\f0\pard\sb75{\fs24\b readOnly}\par
\f0\pard{\fs20 "True" or "False" (default).}\par
\f0\pard\sb180\shading1000{\fs30\b TextBoxTab(shapeName,acceptsTab) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set whether a TextBox accepts a tab or uses it to locate the next control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The TextBox or RichTextBox name.}\par
\f0\pard\sb75{\fs24\b acceptsTab}\par
\f0\pard{\fs20 "True" or "False" (default).}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewContent(shapeName,tree) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Replace a treeview tree.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The treeview shape name.}\par
\f0\pard\sb75{\fs24\b tree}\par
\f0\pard{\fs20 A 2D array containing the treeview data.{\line}{\line}The first index is the row or node number and the second index is the parent node of the current node (0 for top level).{\line}The value of the array is the display text at the current node.{\line}{\line}tree[1][0] = "Level 1"{\line}tree[2][1] = "Level 1 1"{\line}tree[3][1] = "Level 1 2"{\line}tree[4][0] = "Level 2"}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewEdit(shapeName,node,editable) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Change a treeview node editable status.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The treeview shape name.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 The node to select.}\par
\f0\pard\sb75{\fs24\b editable}\par
\f0\pard{\fs20 "True" an editable TextBox or "False" uneditable.}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewExpand(shapeName,node,expand,recursive) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Expand/collapse nodes in a treeview below input node.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The treeview shape name.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 Node number to expand/collapse, 0 recusively expands/collapses all nodes.}\par
\f0\pard\sb75{\fs24\b expand}\par
\f0\pard{\fs20 Expand or collapse "True" or "False"}\par
\f0\pard\sb75{\fs24\b recursive}\par
\f0\pard{\fs20 Recursively expand/collapse nodes (all children nodes) "True" or "False"}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewGetData(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the data from a treeview tree.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The treeview shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2D array containing the treeview data.{\line}{\line}The first index is the row or node number and the second index is the parent node of the current node (0 for top level).{\line}The value of the array is the display text at the current node.{\line}{\line}tree[1][0] = "Level 1"{\line}tree[2][1] = "Level 1 1"{\line}tree[3][1] = "Level 1 2"{\line}tree[4][0] = "Level 2"}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewGetSelected(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a treeview selected node.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The treeview to get node.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The treeview selected node.}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewItemChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a treeview selection changes or selected item is clicked.}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewSelect(shapeName,node) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Select a node in a treeview.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The treeview shape name.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 The node to select.}\par
\f0\pard\sb300\shading2000{\fs36\b LDCursors}\par
\f0\pard{\fs20 Sets the GraphicsWindow Cursor.}\par

\f0\pard\sb180\shading1000{\fs30\b Arrow() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Arrow Cursor (default).}\par
\f0\pard\sb180\shading1000{\fs30\b ArrowCD() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Arrow with CD Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b CreateCursor(imageName,xHotSpot,yHotSpot) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a cursor that can be set using SetUserCursor or SetShapeCursor.{\line}An ImageList image can be resized with LDImage.Resize.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The file path or ImageList image.}\par
\f0\pard\sb75{\fs24\b xHotSpot}\par
\f0\pard{\fs20 The x pixel to use as the hot spot, indexed from 0.}\par
\f0\pard\sb75{\fs24\b yHotSpot}\par
\f0\pard{\fs20 The y pixel to use as the hot spot, indexed from 0.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b Cross() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Cross Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b Hand() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hand Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b Help() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Help Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b IBeam() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 IBeam Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b Invalid() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Invalid Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b None() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 No Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b Pen() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pen Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b Scroll() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scroll Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b SetShapeCursor(shapeName,cursor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the cursor for a shape or control when the mouse is over the shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b cursor}\par
\f0\pard{\fs20 A cursor created with CreateCursor or{\line}a standard cursor in this object (e.g. "ArrowCD") or {\line}the full path to a *.cur or *.ani file to use as a cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b SetUserCursor(cursor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sets a custom cursor as a pointer in the Graphics Window.}\par
\f0\pard\sb75{\fs24\b cursor}\par
\f0\pard{\fs20 A cursor created with CreateCursor or{\line}a standard cursor in this object (e.g. "ArrowCD") or {\line}the full path to a *.cur or *.ani file to use as a cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b SizeAll() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Size All Cursor (Resizing).}\par
\f0\pard\sb180\shading1000{\fs30\b SizeNESW() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 NESW DoubleArrow Cursor (Resizing).}\par
\f0\pard\sb180\shading1000{\fs30\b SizeNS() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 NS DoubleArrow (Resizing).}\par
\f0\pard\sb180\shading1000{\fs30\b SizeNWSE() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 NWSE DoubleArrow Cursor (Resizing).}\par
\f0\pard\sb180\shading1000{\fs30\b SizeWE() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 WE DoubleArrow (Resizing).}\par
\f0\pard\sb180\shading1000{\fs30\b Starting() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Starting Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b UpArrow() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Up Arrow Cursor (Insertion).}\par
\f0\pard\sb180\shading1000{\fs30\b Wait() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wait Cursor.}\par
\f0\pard\sb300\shading2000{\fs36\b LDDataBase}\par
\f0\pard{\fs20 SQL Database with ListView control.{\line}ConnectSQLite for SQLite databases (see http://zetcode.com/db/sqlite for SQLite commands).{\line}ConnectMySQL for MySQL databases (see http://www.mysql.com for MySQL downloads and setup).{\line}ConnectSqlServer for SqlServer databases (see http://www.microsoft.com/en-us/server-cloud/products/sql-server-editions/sql-server-express.aspx for SqlServer downloads and setup).{\line}ConnectOleDb for Access OleDb databases.{\line}ConnectOdbc for Odbc databases.}\par

\f0\pard\sb180\shading1000{\fs30\b AddListView(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a ListView to view database query results.{\line}This is a read only display of query results.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the ListView.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the ListView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The ListView control.}\par
\f0\pard\sb180\shading1000{\fs30\b Command(database,command) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Perform an SQLite, MySQL, SqlServer. OleDb or Odbc command (not a query) on a database.{\line}If this database is viewed in a dataview then unsaved user changes will be lost when the dataview is updated following this operation. }\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 The existing database label (see ConnectSQLite, ConnectMySQL, ConnectSqlServer, ConnectOleDb or ConnectOdbc).}\par
\f0\pard\sb75{\fs24\b command}\par
\f0\pard{\fs20 The SQL Command.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of rows updated.}\par
\f0\pard\sb180\shading1000{\fs30\b Connection \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Over-ride an SQL database connection string (advanced use only).{\line}Set before connection to database, when this connection string will be used in place of the entered connection parameters.{\line}Default is "" (unused).}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectMySQL(server,user,password,database) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Connect to a MySQL database.{\line}This must be called before any SQL methods.{\line}The MySQL service must be running and database with credentials already created, if in doubt use SQLite.}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 The MySQL server (e.g. "localhost").}\par
\f0\pard\sb75{\fs24\b user}\par
\f0\pard{\fs20 The MySQL user name.}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 The MySQL user password.}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 The MySQL database name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A label to identify the database.}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectOdbc(driver,server,port,user,password,option,database) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Connect to an Odbc driver connected database.{\line}This must be called before any SQL methods.{\line}The Odbc service must be running and database with credentials already created, if in doubt use SQLite.}\par
\f0\pard\sb75{\fs24\b driver}\par
\f0\pard{\fs20 The Odbc driver (e.g. "{MySQL ODBC 3.51 Driver}").}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 The Odbc server (e.g. "localhost").}\par
\f0\pard\sb75{\fs24\b port}\par
\f0\pard{\fs20 The Odbc port number.}\par
\f0\pard\sb75{\fs24\b user}\par
\f0\pard{\fs20 The Odbc user name.}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 The Odbc user password.}\par
\f0\pard\sb75{\fs24\b option}\par
\f0\pard{\fs20 The Odbc option number to control the Odbc connection (e.g. 0 or 3).}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 The Odbc database name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A label to identify the database.}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectOleDb(provider,server,database) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Connect to an Access OleDb database.{\line}This must be called before any SQL methods.{\line}The Access OleDb service must be running and database with credentials already created, if in doubt use SQLite.}\par
\f0\pard\sb75{\fs24\b provider}\par
\f0\pard{\fs20 The OleDb provider (e.g. "SQLOLEDB").}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 The OleDb server (e.g. "localhost").}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 The OleDb database name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A label to identify the database.}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectSQLite(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create or open an SQLite database.{\line}This must be called before any SQL methods.{\line}When a table is created it must have first column as "Id INTEGER PRIMARY KEY".}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to the SQLite database file (usually with extension db).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A label to identify the database.}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectSqlServer(server,database) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Connect to a SqlServer database.{\line}This must be called before any SQL methods.{\line}The SqlServer service must be running and database with credentials already created, if in doubt use SQLite.}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 The SqlServer server (e.g. "(local)\\SQLEXPRESS").}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 The SqlServer database name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A label to identify the database.}\par
\f0\pard\sb180\shading1000{\fs30\b EditTable(database,table,dataview) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Display a database table for editing in a LDControls.DataView control.{\line}Using this method the database is bound to the dataview conrol, reflecting the database.}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 The existing database label (see ConnectSQLite, ConnectMySQL, ConnectSqlServer, ConnectOleDb or ConnectOdbc).}\par
\f0\pard\sb75{\fs24\b table}\par
\f0\pard{\fs20 The table name to view and edit.}\par
\f0\pard\sb75{\fs24\b dataview}\par
\f0\pard{\fs20 A DataView control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetDB() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a read only list of databases for use outside Small Basic.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 IReadOnlyList<DataBase>}\par
\f0\pard\sb180\shading1000{\fs30\b Query(database,query,listview,getRecords) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Perform an SQLite, MySQL, SqlServer, OleDb or Odbc Query (not a command) on a database.}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 The existing database label (see ConnectSQLite, ConnectMySQL, ConnectSqlServer, ConnectOleDb or ConnectOdbc).}\par
\f0\pard\sb75{\fs24\b query}\par
\f0\pard{\fs20 The SQL Query.{\line}Example "SELECT * FROM myTable;".}\par
\f0\pard\sb75{\fs24\b listview}\par
\f0\pard{\fs20 A ListView to populate with the query result or "" for none.}\par
\f0\pard\sb75{\fs24\b getRecords}\par
\f0\pard{\fs20 Optionally return an array of results ("True" or "False").{\line}Remember large multi-dimensional arrays in Small Basic are slow.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Optional array of results or "".}\par
\f0\pard\sb180\shading1000{\fs30\b SaveTable(database,dataview) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Commit any changes made in a LDControls.DataView to the database.}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 The existing database label (see ConnectSQLite, ConnectMySQL, ConnectSqlServer, ConnectOleDb or ConnectOdbc).}\par
\f0\pard\sb75{\fs24\b dataview}\par
\f0\pard{\fs20 A DataView control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDDateTime}\par
\f0\pard{\fs20 Time and Date conversion.{\line}{\line}The date format is "25/01/2012 22:18:52", the time part is optional.{\line}The date part will be dependent on your locale, e.g. in US it will be "01/25/2012 22:18:52".{\line}{\line}An OADate is the number of days (and part days) since 30 December 1899, allowing dates to be added or subtracted.}\par

\f0\pard\sb180\shading1000{\fs30\b Add(date,offset) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate a date from input date and an offset in days.}\par
\f0\pard\sb75{\fs24\b date}\par
\f0\pard{\fs20 The input date.}\par
\f0\pard\sb75{\fs24\b offset}\par
\f0\pard{\fs20 An offset in days.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A date equivalent to the input date + offset.{\line}{\line}The format is "25/01/2012 22:18:52", the time part is optional.{\line}The date part will be dependent on your locale, e.g. in US it will be "01/25/2012 22:18:52".}\par
\f0\pard\sb180\shading1000{\fs30\b FromOADate(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert OADate to date string.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 The OADate to convert.{\line}{\line}The number of days since 30 December 1899 (OADate).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The date string.{\line}{\line}The format is "25/01/2012 22:18:52", the time part is optional.{\line}The date part will be dependent on your locale, e.g. in US it will be "01/25/2012 22:18:52".}\par
\f0\pard\sb180\shading1000{\fs30\b GetDay(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get day of the month from OADate.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 The OADate.{\line}{\line}The number of days since 30 December 1899 (OADate).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The month.}\par
\f0\pard\sb180\shading1000{\fs30\b GetDayName(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get day of the week from OADate.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 The OADate.{\line}{\line}The number of days since 30 December 1899 (OADate).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The day name.}\par
\f0\pard\sb180\shading1000{\fs30\b GetHour(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get hour from OADate.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 The OADate.{\line}{\line}The number of days since 30 December 1899 (OADate).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The hour.}\par
\f0\pard\sb180\shading1000{\fs30\b GetMinute(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get minute from OADate.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 The OADate.{\line}{\line}The number of days since 30 December 1899 (OADate).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The minute.}\par
\f0\pard\sb180\shading1000{\fs30\b GetMonth(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get month from OADate.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 The OADate.{\line}{\line}The number of days since 30 December 1899 (OADate).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The month.}\par
\f0\pard\sb180\shading1000{\fs30\b GetMonthName(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get month name from OADate.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 The OADate.{\line}{\line}The number of days since 30 December 1899 (OADate).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The month name.}\par
\f0\pard\sb180\shading1000{\fs30\b GetSecond(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get second from OADate.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 The OADate.{\line}{\line}The number of days since 30 December 1899 (OADate).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The second.}\par
\f0\pard\sb180\shading1000{\fs30\b GetYear(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get year from OADate.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 The OADate.{\line}{\line}The number of days since 30 December 1899 (OADate).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The year.}\par
\f0\pard\sb180\shading1000{\fs30\b Now() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The current date and time.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The current date and time.{\line}{\line}The format is "25/01/2012 22:18:52", the time part is optional.{\line}The date part will be dependent on your locale, e.g. in US it will be "01/25/2012 22:18:52".}\par
\f0\pard\sb180\shading1000{\fs30\b NowOADate() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The current OADate.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of days (and part days) since 30 December 1899 (OADate).}\par
\f0\pard\sb180\shading1000{\fs30\b OADate(year,month,day,hour,minute,second) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create OADate from date and time values.}\par
\f0\pard\sb75{\fs24\b year}\par
\f0\pard{\fs20 The year.}\par
\f0\pard\sb75{\fs24\b month}\par
\f0\pard{\fs20 The month.}\par
\f0\pard\sb75{\fs24\b day}\par
\f0\pard{\fs20 The day.}\par
\f0\pard\sb75{\fs24\b hour}\par
\f0\pard{\fs20 The hour.}\par
\f0\pard\sb75{\fs24\b minute}\par
\f0\pard{\fs20 The minute.}\par
\f0\pard\sb75{\fs24\b second}\par
\f0\pard{\fs20 The second.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of days (and part days) since 30 December 1899 (OADate).}\par
\f0\pard\sb180\shading1000{\fs30\b Subtract(date1,date2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate a number of days between two dates.}\par
\f0\pard\sb75{\fs24\b date1}\par
\f0\pard{\fs20 The input date1.}\par
\f0\pard\sb75{\fs24\b date2}\par
\f0\pard{\fs20 The input date2.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of days (and part days) between the dates (date1-date2).}\par
\f0\pard\sb180\shading1000{\fs30\b ToOADate(date) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert date string to OADate.}\par
\f0\pard\sb75{\fs24\b date}\par
\f0\pard{\fs20 The date string to convert.{\line}{\line}The format is "25/01/2012 22:18:52", the time part is optional.{\line}The date part will be dependent on your locale, e.g. in US it will be "01/25/2012 22:18:52".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of days (and part days) since 30 December 1899 (OADate).}\par
\f0\pard\sb300\shading2000{\fs36\b LDDebug}\par
\f0\pard{\fs20 Debugging utilities.}\par

\f0\pard\sb180\shading1000{\fs30\b Break(label) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a break point, where the program will pause and variable values can be viewed.}\par
\f0\pard\sb75{\fs24\b label}\par
\f0\pard{\fs20 An identification label for the breakpoint.{\line}A unique label should be chosen for each breakpoint defined.{\line}There are some known limitations with breakpoints inside event subroutines.}\par
\f0\pard\sb180\shading1000{\fs30\b Instrument(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a SmallBasic file (_debug.sb) with break points auto added for each line.{\line}{\line}Just open and run the new instrumented file to debug it.  {\line}When a problem is found, correct it in your original and re-instrument to debug the corrected file.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The Smallbasic file (*.sb) to instrument.}\par
\f0\pard\sb180\shading1000{\fs30\b Start() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Start a debugging session, usually do this as the first line of your program.{\line}{\line}Usually you would either set break points manually in your code before running (LDDebug.Break) or auto add breakpoints (LDDebug.Instrument).}\par
\f0\pard\sb300\shading2000{\fs36\b LDDialogs}\par
\f0\pard{\fs20 Dialogs and popups.}\par

\f0\pard\sb180\shading1000{\fs30\b AddRightClickMenu(items,images) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a right click context menu for the GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b items}\par
\f0\pard{\fs20 An array of context menu item selection texts.}\par
\f0\pard\sb75{\fs24\b images}\par
\f0\pard{\fs20 Optional array of image icons, any or all may be "".{\line}They may be the result of ImageList.LoadImage or local or network image file.}\par
\f0\pard\sb180\shading1000{\fs30\b Calendar(start) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 A popup calendar date chooser - double click a date or press return to select a date.}\par
\f0\pard\sb75{\fs24\b start}\par
\f0\pard{\fs20 The initial date in the control, may be "" for today.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The selected date.}\par
\f0\pard\sb180\shading1000{\fs30\b Colour() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Choose a colour from a dialog.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The chosen colour.}\par
\f0\pard\sb180\shading1000{\fs30\b Confirm(text,title) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 A message dialog with Yes, No and Cancel options.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Text question for the dialog.}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 Title for the dialog.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "Yes", "No" or "Cancel"}\par
\f0\pard\sb180\shading1000{\fs30\b EndWait() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Close the waiting popup window.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Font(font) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Use the font dialog to select a font.}\par
\f0\pard\sb75{\fs24\b font}\par
\f0\pard{\fs20 An array with the initial font selected.{\line}It has the same format as the return array, and can be an empty array "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array with the font properties.{\line}result[1] is Font name{\line}result[2] is Font size{\line}result[3] is Font bold ("True" or "False"){\line}result[4] is Font italic ("True" or "False")}\par
\f0\pard\sb180\shading1000{\fs30\b GetFolder(InitialFolder) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 A Dialog to get a folder (directory).}\par
\f0\pard\sb75{\fs24\b InitialFolder}\par
\f0\pard{\fs20 The initial folder or "" for the last folder selected.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The full path to the selected folder or "" if none is selected.}\par
\f0\pard\sb180\shading1000{\fs30\b LastRightClickMenuItem \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The index of the last right click context menu item selected.}\par
\f0\pard\sb180\shading1000{\fs30\b OpenFile(extension,folder) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Open File Dialogue (get an existing file).}\par
\f0\pard\sb75{\fs24\b extension}\par
\f0\pard{\fs20 The file type extension, e.g. "sb".{\line}This may also be an array of extension types such as "1=png;2=jpg;".{\line}If the extension contains a "|" character then it will be used directly such as "Images|*.bmp;*.jpg;*.gif;*.png|All files (*.*)|*.*".}\par
\f0\pard\sb75{\fs24\b folder}\par
\f0\pard{\fs20 The initial folder to open dialog with, can be "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb180\shading1000{\fs30\b RightClickMenu \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a right click context menu item is selected.}\par
\f0\pard\sb180\shading1000{\fs30\b SaveFile(extension,folder) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save File Dialogue (get a new file).}\par
\f0\pard\sb75{\fs24\b extension}\par
\f0\pard{\fs20 The file type extension, e.g. "sb".{\line}This may also be an array of extension types such as "1=png;2=jpg;".{\line}If the extension contains a "|" character then it will be used directly such as "Images|*.bmp;*.jpg;*.gif;*.png|All files (*.*)|*.*".}\par
\f0\pard\sb75{\fs24\b folder}\par
\f0\pard{\fs20 The initial folder to open dialog with, can be "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb180\shading1000{\fs30\b SetStartupPosition(x,y,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the startup coordinates (top left) for most dialoges.  This should be set before the dialog is called.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The X coordinate.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The X coordinate.}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 The mode which is one of the following{\line}0 : Off (default){\line}1 : The coordinates are relative to the graphics window, equivalent to GraphicsWindow.MouseX/Y.{\line}2 : The coordinates are relative to the display window, equivalent to Desktop.MouseX/Y}\par
\f0\pard\sb180\shading1000{\fs30\b ToolTip(shapeName,tip) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a tooltip popup for common shapes and controls.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control.}\par
\f0\pard\sb75{\fs24\b tip}\par
\f0\pard{\fs20 The text content of the tooltip.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Wait(text,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a waiting popup window with a text message.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to display in the popup window.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour of the popup window border, may be "" for default.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb300\shading2000{\fs36\b LDDictionary}\par
\f0\pard{\fs20 This class provides access to an online Dictionary service.{\line}Alternative for Version 1.0 Dictionary object that fails.}\par

\f0\pard\sb180\shading1000{\fs30\b GetDefinition(word) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the definition of a word, in English.}\par
\f0\pard\sb75{\fs24\b word}\par
\f0\pard{\fs20 The word to define.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The definition(s) of the specified word.}\par
\f0\pard\sb180\shading1000{\fs30\b GetDefinitionInFrench(word) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the definition of a word, in French.}\par
\f0\pard\sb75{\fs24\b word}\par
\f0\pard{\fs20 The word to define.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The definition(s) of the specified word.}\par
\f0\pard\sb180\shading1000{\fs30\b GetDefinitionInSpanish(word) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the definition of a word, in Spanish.}\par
\f0\pard\sb75{\fs24\b word}\par
\f0\pard{\fs20 The word to define.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The definition(s) of the specified word.}\par
\f0\pard\sb300\shading2000{\fs36\b LDEffect}\par
\f0\pard{\fs20 Apply visual effects to any shape or control.}\par

\f0\pard\sb180\shading1000{\fs30\b Bloom(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a bloom effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}BaseIntensity (default 1){\line}BaseSaturation (default 1){\line}BloomIntensity (default 1.25){\line}BloomSaturation (default 1){\line}Threshold (default 0.25)}\par
\f0\pard\sb180\shading1000{\fs30\b Blur(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a blur effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}KernelType (default "Gaussian" or "Box"){\line}Radius (default 5)}\par
\f0\pard\sb180\shading1000{\fs30\b Clear(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Clear effects.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to clear the effects from.}\par
\f0\pard\sb180\shading1000{\fs30\b ColourTone(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a colour tone effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}Desaturation (default 0.5){\line}ToneAmount (default 0.5){\line}LightColor (default "#FFE580"){\line}DarkColor (default "#338000")}\par
\f0\pard\sb180\shading1000{\fs30\b DropShadow(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a drop shadow effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}BlurRadius (default 5){\line}Color (default "Black"){\line}Direction (default 315){\line}Opacity (default 1){\line}ShadowDepth (default 5)}\par
\f0\pard\sb180\shading1000{\fs30\b Embossed(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply an embossed effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}Amount (default 3){\line}Color (default "Gray"){\line}Height (default 0.001)}\par
\f0\pard\sb180\shading1000{\fs30\b Magnify(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a magnify effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}Amount (default 0.5){\line}Center (default "X=0.5;Y=0.5;"){\line}InnerRadius (default 0.2){\line}OuterRadius (default 0.4)}\par
\f0\pard\sb180\shading1000{\fs30\b Monochrome(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a monochrome effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}Color (default "White")}\par
\f0\pard\sb180\shading1000{\fs30\b Pixelate(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a pixelate effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}Pixelation (default 0.75)}\par
\f0\pard\sb180\shading1000{\fs30\b Ripple(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a ripple effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}Center (default "X=0.5;Y=0.5;"){\line}Frequency (default 40){\line}Magnitude (default 0.1){\line}Phase (default 10)}\par
\f0\pard\sb180\shading1000{\fs30\b Sharpen(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a sharpen effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}Amount (default 2){\line}Height (default 0.0005)}\par
\f0\pard\sb180\shading1000{\fs30\b Swirl(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a swirl effect.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to apply the effect to.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of optional ("" for none) properties, indexed by the property name:{\line}AngleFrequency (default 45){\line}Center (default "X=0.5;Y=0.5;"){\line}TwistAmount (default 10)}\par
\f0\pard\sb300\shading2000{\fs36\b LDEmail}\par
\f0\pard{\fs20 Email Methods.}\par

\f0\pard\sb180\shading1000{\fs30\b Attachment \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Attachment file.}\par
\f0\pard\sb180\shading1000{\fs30\b Body \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Email body text.}\par
\f0\pard\sb180\shading1000{\fs30\b From \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 From email address.}\par
\f0\pard\sb180\shading1000{\fs30\b Password \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Email client password.}\par
\f0\pard\sb180\shading1000{\fs30\b Port \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 SMTP port (default 587).}\par
\f0\pard\sb180\shading1000{\fs30\b Recipient \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Recipient email address.}\par
\f0\pard\sb180\shading1000{\fs30\b Send() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Send an email.{\line}The default Smtp client is "smtp.gmail.com" and the default port is 587.  The following and other email clients may also work.{\line}"smtp.live.com" (Hotmail){\line}"smtp.mail.yahoo.com"{\line}{\line}A minimum of the "From, Password and Recipient" properties must be set first.{\line}The "From" and "Password" properties should be your email credentials for the client.{\line}Additionally you should set the "Subject and Body" properties.{\line}The "Attachment" property may be optionally set to a full file path, "" for no attachment.{\line}{\line}No more than 1 email per minute can be sent.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" for success or an error message.}\par
\f0\pard\sb180\shading1000{\fs30\b Server \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 SMTP server (default "smtp.gmail.com").}\par
\f0\pard\sb180\shading1000{\fs30\b Subject \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Subject text.}\par
\f0\pard\sb180\shading1000{\fs30\b UseSSL \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 "True" or "False" (default "True").}\par
\f0\pard\sb300\shading2000{\fs36\b LDEncryption}\par
\f0\pard{\fs20 Encryption and hash methods.}\par

\f0\pard\sb180\shading1000{\fs30\b AESDecrypt(cypher,password) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Decrypt an AES encrypted cypher (previously encrypted) using a password key.}\par
\f0\pard\sb75{\fs24\b cypher}\par
\f0\pard{\fs20 The encrypted text (cypher).}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 The password key for the encryption.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The original unencrypted text or "" if password and cypher don't match.}\par
\f0\pard\sb180\shading1000{\fs30\b AESEncrypt(source,password) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Encrypt some text using AES encryption and a password key.{\line}The encrypted text can be saved to a file.{\line}Note that if you forget the password there is NO WAY to decrypt!}\par
\f0\pard\sb75{\fs24\b source}\par
\f0\pard{\fs20 The text to encrypt.}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 The password key for the encryption.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The encrypted text (cypher).}\par
\f0\pard\sb180\shading1000{\fs30\b MD5Hash(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an MD5 hash of a text input (http://wikipedia.org/wiki/MD5).{\line}This 32 character hash is recommended where a general or shorter hash is required (password or data integrity).}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 A text or password to create a hash.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 32 character hex MD5 Hash.}\par
\f0\pard\sb180\shading1000{\fs30\b MD5HashFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an MD5 hash of a file.{\line}This 32 character hash is for file data integrity checks (e.g. a file contents is unchanged).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to a file to get the hash.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 32 character hex MD5 Hash.}\par
\f0\pard\sb180\shading1000{\fs30\b RSADecrypt(encrypted) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Decrpyt an RSA message.  {\line}Requires a Private key to be set (Only originator can decrypt with private key).{\line}If no key is set then one created for this session is used.}\par
\f0\pard\sb75{\fs24\b encrypted}\par
\f0\pard{\fs20 The encypted message.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The unencrypted message.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAEncrypt(unencrypted) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Encrypt an RSA message.  {\line}Requires a Public key to be set (Anyone can encrypt with public key).{\line}If no key is set then one created for this session is used.}\par
\f0\pard\sb75{\fs24\b unencrypted}\par
\f0\pard{\fs20 The message to encrypt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The encrypted message.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAPrivateKey \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or set a private RSA key.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAPublicKey \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or set a public RSA key.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAReset() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Randomly reset the private and public keys}\par
\f0\pard\sb180\shading1000{\fs30\b RSASign(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sign an RSA message.  {\line}Requires a Private key to be set (Only originator can sign with private key).{\line}If no key is set then one created for this session is used.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 The message to sign.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The signing for the message.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAVerify(data,sign) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verify a signed RSA message.  {\line}Requires a Public key to be set (Anyone can verify with public key).{\line}If no key is set then one created for this session is used.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 The message that was signed.}\par
\f0\pard\sb75{\fs24\b sign}\par
\f0\pard{\fs20 The signing for the message.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b SHA512Hash(password) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a SHA2-512 hash of a text input.{\line}This 128 character hash is recommended for the most secure password encryption.}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 A text to create a hash (often a password).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 128 character hex SHA512 Hash.}\par
\f0\pard\sb180\shading1000{\fs30\b SHA512HashFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an SHA512 hash of a file.{\line}This 128 character hash is for file data integrity checks (e.g. a file contents is unchanged).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to a file to get the hash.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 128 character hex SHA512 Hash.}\par
\f0\pard\sb300\shading2000{\fs36\b LDEvents}\par
\f0\pard{\fs20 Additional Events.}\par

\f0\pard\sb180\shading1000{\fs30\b Error \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a LitDev extension error occurs.{\line}This is in addition to TextWindow warnings, which can be turned off using LDUtilties.ShowErrors, LDUtilties.ShowFileErrors and LDUtilties.ShowNoShapeErrors.}\par
\f0\pard\sb180\shading1000{\fs30\b FileChange \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a file is created, changed or deleted.{\line}{\line}The FilePath and FileFilter should be set before registering this event.}\par
\f0\pard\sb180\shading1000{\fs30\b FileFilter \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 A file filter for FileSystem file change event (default is "*.*").}\par
\f0\pard\sb180\shading1000{\fs30\b FilePath \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The root path to watch for FileSystem file change event (default is "C:").}\par
\f0\pard\sb180\shading1000{\fs30\b LastError \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last error message.}\par
\f0\pard\sb180\shading1000{\fs30\b LastFileChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The full path to the last file changed.}\par
\f0\pard\sb180\shading1000{\fs30\b LastFileChangeType \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last file change type ("Created", "Changed" or "Deleted").}\par
\f0\pard\sb180\shading1000{\fs30\b LastMouseWheelDelta \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last mouse wheel Delta (rotation direction).}\par
\f0\pard\sb180\shading1000{\fs30\b MouseDoubleClick \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when the mouse is double clicked.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseWheel \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when the mouse wheel is rotated.}\par
\f0\pard\sb180\shading1000{\fs30\b Resized \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when the GraphicsWindow is resized.}\par
\f0\pard\sb300\shading2000{\fs36\b LDFastArray}\par
\f0\pard{\fs20 This object provides another faster way of storing values in an Array.{\line}It can handle 1, 2, 3 and higher dimensional arrays and has methods to read and write arrays to files, including in CSV format.{\line}It is also possible for different rows in an array to have different dimensions or numbers of elements (jagged array), just like Small Basic arrays.{\line}Internally it uses lists that allow the sizes to grow so that the array dimension or size doesn't need to be set at the start.{\line}The indexing is by integer starting from 1.{\line}For 1D arrays it is recommended to use LDList since it has additional sort methods.{\line}Elements in arrays with dimension greater than 3 are indexed by a comma separated list of indices or index variable names.}\par

\f0\pard\sb180\shading1000{\fs30\b Add() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new array.{\line}This is a general array that can be used as a 1D, 2D, 3D or higher dimension array, depending on the data set.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb180\shading1000{\fs30\b Collapse(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove all empty "" entries in an array.{\line}Note that indices or even dimensions may change if internal entries are removed.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb180\shading1000{\fs30\b Copy(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy an array.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A copy of the array.}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromIndices(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert a SmallBasic array (up to 3 dimensions) to a FastArray array.{\line}This method creates an array only containing the Small Basic array indices.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 The Small Basic array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A new FastArray or "".}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromValues(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert a SmallBasic array to a FastArray array.{\line}All indices in the Small Basic array are replaced with consecutive integer indices.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 The Small Basic array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A new FastArray or "".}\par
\f0\pard\sb180\shading1000{\fs30\b Dimension(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the dimension of an array.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The array dimension.}\par
\f0\pard\sb180\shading1000{\fs30\b Get(arrayName,indices) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a value.{\line}Get1D, Get2D or Get3D methods are marginally faster for lower dimension arrays.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b indices}\par
\f0\pard{\fs20 A comma (or space) separated list of index values (slower) or index variable names (faster).{\line}e.g. "3,2,6" or "i,j,k"{\line}If this is set to "", then previously set index variables are used.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The array value or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Get1D(arrayName,index1) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a 1D value.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 The first dimension integer index.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The array value or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Get2D(arrayName,index1,index2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a 2D value.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 The first dimension integer index.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 The second dimension integer index.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The array value or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Get3D(arrayName,index1,index2,index3) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a 3D value.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 The first dimension integer index.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 The second dimension integer index.}\par
\f0\pard\sb75{\fs24\b index3}\par
\f0\pard{\fs20 The third dimension integer index.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The array value or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Read(fileName,binary) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new array and initialise it from a file.{\line}If the file is text based and doesn't have the same indexing format as Write, then a 1D array with each line is created.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb75{\fs24\b binary}\par
\f0\pard{\fs20 Binary ("True") or text ("False") formatted file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb180\shading1000{\fs30\b ReadCSV(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read a CSV (comma separated values) file into a 2D FastArray array.{\line}The deliminator may be changed from a comma using Utilities.CSVDeliminator}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the CSV file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2D FastArray with CSV file imported or "".}\par
\f0\pard\sb180\shading1000{\fs30\b Remove(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delete an array.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb180\shading1000{\fs30\b Set(arrayName,indices,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a value.{\line}Set1D, Set2D or Set3D methods are marginally faster for lower dimension arrays.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b indices}\par
\f0\pard{\fs20 A comma (or space) separated list of index values (slower) or index variable names (faster).{\line}e.g. "3,2,6" or "i,j,k"{\line}If this is set to "", then previously set index variables are used.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to set.}\par
\f0\pard\sb180\shading1000{\fs30\b Set1D(arrayName,index1,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a 1D value.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 The first dimension integer index.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to set.}\par
\f0\pard\sb180\shading1000{\fs30\b Set2D(arrayName,index1,index2,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a 2D value.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 The first dimension integer index.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 The second dimension integer index.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to set.}\par
\f0\pard\sb180\shading1000{\fs30\b Set3D(arrayName,index1,index2,index3,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a 3D value.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 The first dimension integer index.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 The second dimension integer index.}\par
\f0\pard\sb75{\fs24\b index3}\par
\f0\pard{\fs20 The third dimension integer index.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to set.}\par
\f0\pard\sb180\shading1000{\fs30\b Size(arrayName,indices) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the current size of a dimension.{\line}Size1, Size2 or Size3 methods are marginally faster for lower dimension arrays.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b indices}\par
\f0\pard{\fs20 A comma (or space) separated list of indices.{\line}e.g. "" for first dimension or "3" for second dimension of 3rd element in first dimension.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The dimension size.}\par
\f0\pard\sb180\shading1000{\fs30\b Size1(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the current size of the first dimension.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The dimension size.}\par
\f0\pard\sb180\shading1000{\fs30\b Size2(arrayName,index1) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the current size of the second dimension.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 The first index to get the size of, may be 1 if all rows have the same size.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The dimension size.}\par
\f0\pard\sb180\shading1000{\fs30\b Size3(arrayName,index1,index2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the current size of the third dimension.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 The first index to get the size of, may be 1 if all rows have the same size.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 The second index to get the size of, may be 1 if all rows have the same size.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The dimension size.}\par
\f0\pard\sb180\shading1000{\fs30\b ToArray(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert a FastArray array to a Small Basic array.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A Small Basic array or "".}\par
\f0\pard\sb180\shading1000{\fs30\b Write(arrayName,fileName,binary) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save an array to a file.{\line}If the array is 1D and written as a text, then each entry is just written to a line with no indexing.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The array name.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb75{\fs24\b binary}\par
\f0\pard{\fs20 Binary ("True") or text ("False") formatted file.}\par
\f0\pard\sb180\shading1000{\fs30\b WriteCSV(arrayName,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Write a 2D FastArray array to a CSV (comma separated values) file.{\line}The deliminator may be changed from a comma using Utilities.CSVDeliminator}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 The 2D array name.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the CSV file.}\par
\f0\pard\sb300\shading2000{\fs36\b LDFastShapes}\par
\f0\pard{\fs20 Shape methods which are faster than standard Small Basic Shape operations.{\line}This is primarily for shape movement when there are a large number of shapes updated in a game loop.{\line}Only the main Shapes commands are supported since these are the ones that are commonly repeated many times.{\line}The shape must first be created, then registered (ShapeIndex) and the returned integer index used with the other methods.{\line}The visual update of the changes made does not happen until (Update) is called when all changes are processed together.{\line}Performance improvements come from both integer indexing and batch update.}\par

\f0\pard\sb180\shading1000{\fs30\b GetLeft(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the left co-ordinate of the specified shape.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index (returned by ShapeIndex) of the shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The left co-ordinate of the shape.}\par
\f0\pard\sb180\shading1000{\fs30\b GetOpacity(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the opacity of a shape.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index (returned by ShapeIndex) of the shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The opacity of the object as a value between 0 and 100.  0 is completely transparent and 100 is completely opaque.}\par
\f0\pard\sb180\shading1000{\fs30\b GetTop(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the top co-ordinate of the specified shape.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index (returned by ShapeIndex) of the shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The top co-ordinate of the shape.}\par
\f0\pard\sb180\shading1000{\fs30\b HideShape(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hides an already added shape.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index (returned by ShapeIndex) of the shape.}\par
\f0\pard\sb180\shading1000{\fs30\b Move(index,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Moves the shape with the specified name to a new position.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index (returned by ShapeIndex) of the shape to move.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x co-ordinate of the new position.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y co-ordinate of the new position.}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(index,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotates the shape with the specified name to the specified angle.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index (returned by ShapeIndex) of the shape.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle to rotate the shape.}\par
\f0\pard\sb180\shading1000{\fs30\b SetOpacity(index,level) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sets how opaque a shape should render.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index (returned by ShapeIndex) of the shape.}\par
\f0\pard\sb75{\fs24\b level}\par
\f0\pard{\fs20 The opacity level ranging from 0 to 100.  0 is completely transparent and 100 is completely opaque.}\par
\f0\pard\sb180\shading1000{\fs30\b ShapeIndex(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Register a shape for use with this object.{\line}This command is potentially slow, so should be called before time critical visual updates occur.{\line}i.e. Create and register all shapes before motion is simulated.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The name of the created shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An index to use in the other methods in this object.{\line}The index is an integer starting at 1, incremented for each shape registered.{\line}-1 for an error.}\par
\f0\pard\sb180\shading1000{\fs30\b ShowShape(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Shows a previously hidden shape.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index (returned by ShapeIndex) of the shape.}\par
\f0\pard\sb180\shading1000{\fs30\b Update() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Update all of the properties of shapes set by this object that have been modifed since the last update.{\line}The shapes are not visually updated until this method is called.}\par
\f0\pard\sb180\shading1000{\fs30\b Zoom(index,scaleX,scaleY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scales the shape using the specified zoom levels.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index (returned by ShapeIndex) of the shape.}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 The x-axis zoom level.}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 The y-axis zoom level.}\par
\f0\pard\sb300\shading2000{\fs36\b LDFigures}\par
\f0\pard{\fs20 Some additional shapes like callouts, arcs and arrows.}\par

\f0\pard\sb180\shading1000{\fs30\b AddArc(width,height,startAngle,endAngle,thickness) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an arc shape.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the shape.}\par
\f0\pard\sb75{\fs24\b startAngle}\par
\f0\pard{\fs20 The starting angle in degrees.}\par
\f0\pard\sb75{\fs24\b endAngle}\par
\f0\pard{\fs20 The ending angle in degrees.}\par
\f0\pard\sb75{\fs24\b thickness}\par
\f0\pard{\fs20 The thickness of the arc in pixels.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddBlockArrow(width,height,thickness,arrowAngle,direction) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an block arrow shape.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the shape.}\par
\f0\pard\sb75{\fs24\b thickness}\par
\f0\pard{\fs20 The relative thickness of the arrow shaft, e.g. 0.25.}\par
\f0\pard\sb75{\fs24\b arrowAngle}\par
\f0\pard{\fs20 The arrow head angle in degrees.}\par
\f0\pard\sb75{\fs24\b direction}\par
\f0\pard{\fs20 The direction of the arrow: "Up", "Down", "Left" or "Right".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddCallout(width,height,text,style,anchor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a callout shape.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the shape.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The callout text.}\par
\f0\pard\sb75{\fs24\b style}\par
\f0\pard{\fs20 The callout style: "Cloud", "Oval", "Rectangle" or "RoundedRectangle".}\par
\f0\pard\sb75{\fs24\b anchor}\par
\f0\pard{\fs20 Position of callout anchor relative to the callout size (e.g. "X=0;Y=1.25;")}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddLineArrow(width,height,size,bend,startArrow,endArrow,startCorner) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a line arrow shape.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the shape.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 The size of the arrow head in pixels.}\par
\f0\pard\sb75{\fs24\b bend}\par
\f0\pard{\fs20 The arrow bend amount (e.g. 0 is straight, 0.5 is smoothly bending).}\par
\f0\pard\sb75{\fs24\b startArrow}\par
\f0\pard{\fs20 The start arrow type: "None", "Arrow", "Open", "Oval" or "Stealth".}\par
\f0\pard\sb75{\fs24\b endArrow}\par
\f0\pard{\fs20 The end arrow type: "None", "Arrow", "Open", "Oval" or "Stealth".}\par
\f0\pard\sb75{\fs24\b startCorner}\par
\f0\pard{\fs20 The start corner position: "BottomLeft", "BottomRight", "TopLeft" or "TopRight".  The arrow will terminate in the opposite corner.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRegularPolygon(width,height,corners,radius) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a regular polygon shape.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the shape.}\par
\f0\pard\sb75{\fs24\b corners}\par
\f0\pard{\fs20 The number of corners.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 A relative radius for star shapes (e.g. 1 for pentagon, 0.5 for 5 pointed star).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb300\shading2000{\fs36\b LDFile}\par
\f0\pard{\fs20 File utilities.}\par

\f0\pard\sb180\shading1000{\fs30\b AccessTime(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the last time a file was accessed.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The last access time of the file or directory ("" on failure).}\par
\f0\pard\sb180\shading1000{\fs30\b ANSItoUTF8(fileName,BOM) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert an ANSI encoded text file to UTF8.{\line}It should also work for any other encoding.{\line}UTF8 is the default text file encoding used by Small Basic.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file path to convert.}\par
\f0\pard\sb75{\fs24\b BOM}\par
\f0\pard{\fs20 Include Byte Order Mark (BOM) in UTF8 file ("True" or "False", no BOM is usual).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The converted file path (-UTF8.txt) or "" for failure (the encoding may not have been detected correctly).}\par
\f0\pard\sb180\shading1000{\fs30\b AppDataFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the ApplicationData folder path.}\par
\f0\pard\sb180\shading1000{\fs30\b CopyDirectory(directoryFrom,directoryTo) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Recursively copy a directory and all contents including sub-directories.}\par
\f0\pard\sb75{\fs24\b directoryFrom}\par
\f0\pard{\fs20 The full path to the directory to copy from.}\par
\f0\pard\sb75{\fs24\b directoryTo}\par
\f0\pard{\fs20 The full path to the directory to copy to.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CreationTime(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the creation time of a file.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The creation time of the file or directory ("" on failure).}\par
\f0\pard\sb180\shading1000{\fs30\b CSVplaceholder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Character to use in place of empty values in the imported array when reading CSV files.{\line}A SmallBasic array cannot hold an empty value i.e. "".{\line}{\line}Default is the empty string "" (no array entries created for empty values in the CSV file).}\par
\f0\pard\sb180\shading1000{\fs30\b DocumentsFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the Documents folder path.}\par
\f0\pard\sb180\shading1000{\fs30\b Exists(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Check if a file path is an existing file or directory.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file or directory.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllDirectories(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Recursively get all sub-directories in directory.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 The full path to the root dircetory.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of all sub-directories or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetExtension(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the file extension for a file.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file name with extension (may include folder path or not).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The extension of the file (without the '.') or "" if no extension.}\par
\f0\pard\sb180\shading1000{\fs30\b GetFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the file for a full file path.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of a file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The file name part of the file path (without the folder or the extension).}\par
\f0\pard\sb180\shading1000{\fs30\b GetFolder(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the folder for a full file path.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of a file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The folder part of the file path.}\par
\f0\pard\sb180\shading1000{\fs30\b Length(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the number of lines in a text file.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of lines in the file (-1 on failure).}\par
\f0\pard\sb180\shading1000{\fs30\b LoadAllVariables(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Restore the values of all variables that were previously stored using SaveAllVariables.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to a file with stored variable values.}\par
\f0\pard\sb180\shading1000{\fs30\b ModifiedTime(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the last time a file was modified.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The last modified time of the file or directory ("" on failure).}\par
\f0\pard\sb180\shading1000{\fs30\b MusicFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the Music folder path.}\par
\f0\pard\sb180\shading1000{\fs30\b PicturesFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the Pictures folder path.}\par
\f0\pard\sb180\shading1000{\fs30\b PrintFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Print a file.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file to print.}\par
\f0\pard\sb180\shading1000{\fs30\b PublicFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the Public folder path.}\par
\f0\pard\sb180\shading1000{\fs30\b ReadANSI(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read an ANSI encoded text file.{\line}It should also work for any other encoding including UTF8.{\line}UTF8 is the default text file encoding used by Small Basic.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file path to read.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The contents of the file or "" for failure (the encoding may not have been detected correctly).}\par
\f0\pard\sb180\shading1000{\fs30\b ReadANSIToArray(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reads a text file with ANSI encoding into an array with one element for each line in the file.{\line}It should also work for any other encoding including UTF8.{\line}Blank lines are included as an element in the array with one blank space.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array with one element for each line in the file or "" for failure (the encoding may not have been detected correctly).}\par
\f0\pard\sb180\shading1000{\fs30\b ReadByteArray(filePath,hexMode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read a file into an array of bytes [0,255].}\par
\f0\pard\sb75{\fs24\b filePath}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb75{\fs24\b hexMode}\par
\f0\pard{\fs20 If this varaible is set to "True", then a single comma deliminated variable of hex values is returned in place of an anrray..}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of byte values indexed from 1, or single string variable of hex values, or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ReadCSV(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read a CSV (comma separated values) file into an array.{\line}The deliminator may be changed from a comma using Utilities.CSVDeliminator}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the CSV file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2D array with CSV file imported.}\par
\f0\pard\sb180\shading1000{\fs30\b ReadCSVTransposed(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read a CSV (comma separated values) file into an array. and transpose (swap rows and columns).{\line}The deliminator may be changed from a comma using Utilities.CSVDeliminator}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the CSV file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 2D array with transposed CSV file imported.}\par
\f0\pard\sb180\shading1000{\fs30\b ReadToArray(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reads a text file into an array with one element for each line in the file.{\line}{\line}Blank lines are included as an element in the array with one blank space.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array with one element for each line in the file.}\par
\f0\pard\sb180\shading1000{\fs30\b RenameDirectory(directoryFrom,directoryTo) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rename or move a directory.}\par
\f0\pard\sb75{\fs24\b directoryFrom}\par
\f0\pard{\fs20 The full path to the directory to rename.}\par
\f0\pard\sb75{\fs24\b directoryTo}\par
\f0\pard{\fs20 The full path to the new name for the directory.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b RenameFile(fileFrom,fileTo) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rename or move a file.}\par
\f0\pard\sb75{\fs24\b fileFrom}\par
\f0\pard{\fs20 The full path to the file to rename.}\par
\f0\pard\sb75{\fs24\b fileTo}\par
\f0\pard{\fs20 The full path to the new name for the file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SaveAllVariables(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save all of the current variables to a file.{\line}This is the complete current state of your program.{\line}May be useful to store a game state, or for debugging.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to store the variables and their values.{\line}This file will be over-written.}\par
\f0\pard\sb180\shading1000{\fs30\b Size(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the size of a file in bytes.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to the file to get the size of.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of bytes in the file or -1 on error.}\par
\f0\pard\sb180\shading1000{\fs30\b TempFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the Temp folder path.}\par
\f0\pard\sb180\shading1000{\fs30\b UserName \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the current user name.}\par
\f0\pard\sb180\shading1000{\fs30\b WriteByteArray(filePath,byteArray,startPos) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Writes an Array of bytes to an (existing) file.}\par
\f0\pard\sb75{\fs24\b filePath}\par
\f0\pard{\fs20 The full path of the file. A non existing file will be created.}\par
\f0\pard\sb75{\fs24\b byteArray}\par
\f0\pard{\fs20 The 1D Array (from 1, continously) with byte values [0,255].{\line}A single comma or sapce separated variable may also be used using hex notation, eg 3D,1F,00.}\par
\f0\pard\sb75{\fs24\b startPos}\par
\f0\pard{\fs20 The byte position (incl., from 1) in an existing file to start writing (ignored for non existing file, will be written from beginning).{\line}<=1, from file start{\line}>file length, append after file end}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of written bytes on success, else "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 '(over)writes from file start{\line}WriteByteArray(path, arr, 1){\line}'SB? after 4th byte{\line}WriteByteArray(path, "1=83;2=66;3=169;",5)}\par
\f0\pard\sb180\shading1000{\fs30\b WriteCSV(fileName,array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Write a 2D array to a CSV (comma separated values) file.{\line}The deliminator may be changed from a comma using Utilities.CSVDeliminator}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the CSV file.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to export.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb300\shading2000{\fs36\b LDFocus}\par
\f0\pard{\fs20 TextBoxFocus utility to control focus (textbox currently active for input).}\par

\f0\pard\sb180\shading1000{\fs30\b GetFocus() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the shape that has current focus.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The shape name (usually a textbox) or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b IsFocus(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Checks if the named shape has the focus.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name (usually a textbox).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b SetFocus(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sets the named shape to have focus.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name (usually a textbox).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False" depending on success or failure.}\par
\f0\pard\sb300\shading2000{\fs36\b LDftp}\par
\f0\pard{\fs20 ftp Methods.}\par

\f0\pard\sb180\shading1000{\fs30\b Delete(remoteFile,ftpServerIP,ftpUserID,ftpPassword) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delete a file by ftp.}\par
\f0\pard\sb75{\fs24\b remoteFile}\par
\f0\pard{\fs20 The full path (on server) to the remote file to delete.}\par
\f0\pard\sb75{\fs24\b ftpServerIP}\par
\f0\pard{\fs20 The ftp server address (or IP).}\par
\f0\pard\sb75{\fs24\b ftpUserID}\par
\f0\pard{\fs20 The user ID.}\par
\f0\pard\sb75{\fs24\b ftpPassword}\par
\f0\pard{\fs20 The user password.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" or "PENDING" for async.}\par
\f0\pard\sb180\shading1000{\fs30\b DoAssync \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set or get whether ftp transfers are performed asynchronously ("True" or "False" default).{\line}An asynchronous ftp transfer will return immediately and complete in the background.{\line}The event FTPComplete will be called when the tranfer is finished.}\par
\f0\pard\sb180\shading1000{\fs30\b Download(localFile,remoteFile,ftpServerIP,ftpUserID,ftpPassword) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Download a file by ftp.}\par
\f0\pard\sb75{\fs24\b localFile}\par
\f0\pard{\fs20 The full path to the local file to download.}\par
\f0\pard\sb75{\fs24\b remoteFile}\par
\f0\pard{\fs20 The full path (on server) to the remote file to download.}\par
\f0\pard\sb75{\fs24\b ftpServerIP}\par
\f0\pard{\fs20 The ftp server address (or IP).}\par
\f0\pard\sb75{\fs24\b ftpUserID}\par
\f0\pard{\fs20 The user ID.}\par
\f0\pard\sb75{\fs24\b ftpPassword}\par
\f0\pard{\fs20 The user password.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" or "PENDING" for async.}\par
\f0\pard\sb180\shading1000{\fs30\b FTPComplete \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when an asynchronous ftp transfer completes.}\par
\f0\pard\sb180\shading1000{\fs30\b LastFTPFile \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last asynchronous FTP file transfered.}\par
\f0\pard\sb180\shading1000{\fs30\b LastFTPStatus \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last asynchronous FTP file status ("SUCCESS" or "FAILED")}\par
\f0\pard\sb180\shading1000{\fs30\b ListFiles(remoteFolder,ftpServerIP,ftpUserID,ftpPassword) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a remote folder listing by ftp (non async only).}\par
\f0\pard\sb75{\fs24\b remoteFolder}\par
\f0\pard{\fs20 The full path (on server) to the remote folder to list.}\par
\f0\pard\sb75{\fs24\b ftpServerIP}\par
\f0\pard{\fs20 The ftp server address (or IP).}\par
\f0\pard\sb75{\fs24\b ftpUserID}\par
\f0\pard{\fs20 The user ID.}\par
\f0\pard\sb75{\fs24\b ftpPassword}\par
\f0\pard{\fs20 The user password.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of file and folder names or "FAILED".  The array is indexed by the file name and the value contains additional information.}\par
\f0\pard\sb180\shading1000{\fs30\b Upload(localFile,remoteFile,ftpServerIP,ftpUserID,ftpPassword) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Upload a file by ftp.}\par
\f0\pard\sb75{\fs24\b localFile}\par
\f0\pard{\fs20 The full path to the local file to upload.}\par
\f0\pard\sb75{\fs24\b remoteFile}\par
\f0\pard{\fs20 The full path (on server) to the remote file to upload.}\par
\f0\pard\sb75{\fs24\b ftpServerIP}\par
\f0\pard{\fs20 The ftp server address (or IP).}\par
\f0\pard\sb75{\fs24\b ftpUserID}\par
\f0\pard{\fs20 The user ID.}\par
\f0\pard\sb75{\fs24\b ftpPassword}\par
\f0\pard{\fs20 The user password.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" or "PENDING" for async.}\par
\f0\pard\sb180\shading1000{\fs30\b UseBinary \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set or get whether ftp transfers use binary (default) or ascii. ("True" or "False").}\par
\f0\pard\sb300\shading2000{\fs36\b LDGraph}\par
\f0\pard{\fs20 Graphing utility.}\par

\f0\pard\sb180\shading1000{\fs30\b AddGraph(xpos,ypos,width,height,title,labelX,labelY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a graph.}\par
\f0\pard\sb75{\fs24\b xpos}\par
\f0\pard{\fs20 The graph left position.}\par
\f0\pard\sb75{\fs24\b ypos}\par
\f0\pard{\fs20 The graph right position.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The graph width.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The graph height.}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 The graph title.}\par
\f0\pard\sb75{\fs24\b labelX}\par
\f0\pard{\fs20 The X axis label.}\par
\f0\pard\sb75{\fs24\b labelY}\par
\f0\pard{\fs20 The Y axis label.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The graph name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddSeriesHistogram(graphName,seriesLabel,data,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a new data series to an existing graph as a histogram.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 The graph name.}\par
\f0\pard\sb75{\fs24\b seriesLabel}\par
\f0\pard{\fs20 The series label.{\line}If a series with this label already exists then it is replaced with this series.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 An array holding the X and Y coordinate data.{\line}{\line}For example, a line with points (0,1) and (2,3) would have{\line}data[0] = 1{\line}data[2] = 3{\line}{\line}More generally data[x] = y.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour of the series data.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b AddSeriesLine(graphName,seriesLabel,data,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a new data series to an existing graph as a line graph.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 The graph name.}\par
\f0\pard\sb75{\fs24\b seriesLabel}\par
\f0\pard{\fs20 The series label.{\line}If a series with this label already exists then it is replaced with this series.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 An array holding the X and Y coordinate data.{\line}{\line}For example, a line with points (0,1) and (2,3) would have{\line}data[0] = 1{\line}data[2] = 3{\line}{\line}More generally data[x] = y.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour of the series data.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b AddSeriesPoints(graphName,seriesLabel,data,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a new data series to an existing graph as points.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 The graph name.}\par
\f0\pard\sb75{\fs24\b seriesLabel}\par
\f0\pard{\fs20 The series label.{\line}If a series with this label already exists then it is replaced with this series.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 An array holding the X and Y coordinate data.{\line}{\line}For example, a line with points (0,1) and (2,3) would have{\line}data[0] = 1{\line}data[2] = 3{\line}{\line}More generally data[x] = y.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour of the series data.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b AutoScale \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 AutoScale axes "True" (default) or "False".{\line}When set to "False" early version scaling is used.}\par
\f0\pard\sb180\shading1000{\fs30\b AxesColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The boundary axes and tick mark colour.}\par
\f0\pard\sb180\shading1000{\fs30\b AxesResolution \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The axes (min and max value) significant figures (default 2).}\par
\f0\pard\sb180\shading1000{\fs30\b BorderColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The border colour.}\par
\f0\pard\sb180\shading1000{\fs30\b CreateTrend(data,order) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a trend from data.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 An array holding the X and Y coordinate data.{\line}{\line}For example, a line with points (0,1) and (2,3) would have{\line}data[0] = 1{\line}data[2] = 3{\line}{\line}More generally data[x] = y.}\par
\f0\pard\sb75{\fs24\b order}\par
\f0\pard{\fs20 The polynomial order for the trend line.{\line}1 is linear.{\line}2 is quadratic.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A data array holding a trend that may be plotted.}\par
\f0\pard\sb180\shading1000{\fs30\b DeleteSeries(graphName,seriesLabel) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delete an existing series on existing graph.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 The graph name.}\par
\f0\pard\sb75{\fs24\b seriesLabel}\par
\f0\pard{\fs20 The series label name to delete.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b ExportCSV(data,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Export data series directly to CSV file (no graphing).}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 An array holding the X and Y coordinate data.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The CSV output file name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b GridColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The internal scale grid lines colour.}\par
\f0\pard\sb180\shading1000{\fs30\b GridLinesX \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The number of X axes tick marks and grid lines (default 10)}\par
\f0\pard\sb180\shading1000{\fs30\b GridLinesY \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The number of Y axes tick marks and grid lines (default 10)}\par
\f0\pard\sb180\shading1000{\fs30\b Help() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 This function is just to display this help.{\line}{\line}Graphs of data can be plotted as lines, points or histograms.{\line}{\line}Each series of data is a SmallBasic array with the array index reprenting the (unique) X value and the array value representing the Y value.{\line}{\line}For example:{\line}data[1] = 5{\line}data[2] = 8{\line}data[3] = 3{\line}{\line}First create a graph object with AddGraph, then add series with AddSeriesLine, AddSeriesHistogram or AddSeriesPoints.{\line}{\line}Once a graph is created and plotted, the axes can be grabbed and scrolled where the hand cursor appears.  The legend can also be moved.{\line}{\line}The graph can be rescaled by using the left mouse button to select a region to zoom, or the mouse wheel can be used to zoom the display.  A double click will reset the scaling to the original default.{\line}{\line}A right click will bring up a menu with other features like export of image or data, displaying the cursor coordinates, hiding the legend etc.{\line}{\line}Finally the various parmeters for this method give further control of the plotting colours and behaviour.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b InteriorColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The interior colour.}\par
\f0\pard\sb180\shading1000{\fs30\b RestartEvents() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Restart all the graph left click mouse events.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b ScaleAxisX(graphName,min,interval,max) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the X axis scaling.{\line}This over-rides any automatic methods.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 The graph name.}\par
\f0\pard\sb75{\fs24\b min}\par
\f0\pard{\fs20 The X axis minimum value.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 The grid spacing interval.{\line}If this value is 0 then the interval is calculated from the data.}\par
\f0\pard\sb75{\fs24\b max}\par
\f0\pard{\fs20 The X axis maximum value.{\line}If this value is equal to min, then the maximum is calculated from the data.{\line}If this value is less than min, then both the minimum and maximum are calculated from the data.}\par
\f0\pard\sb180\shading1000{\fs30\b ScaleAxisY(graphName,min,interval,max) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the Y axis scaling.{\line}This over-rides any automatic methods.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 The graph name.}\par
\f0\pard\sb75{\fs24\b min}\par
\f0\pard{\fs20 The Y axis minimum value.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 The grid spacing interval.{\line}If this value is 0 then the interval is calculated from the data.}\par
\f0\pard\sb75{\fs24\b max}\par
\f0\pard{\fs20 The Y axis maximum value.{\line}If this value is equal to min, then the maximum is calculated from the data.{\line}If this value is less than min, then both the minimum and maximum are calculated from the data.}\par
\f0\pard\sb180\shading1000{\fs30\b StopEvents() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stop all the graph left click mouse events.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b TextColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The text colour.}\par
\f0\pard\sb180\shading1000{\fs30\b TrendCoef() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the polynomial trend line coefficients for the last calculated trend using CreateTrend.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array 'coef' of the polynomial coefficients for the trend line.{\line}The number of coefficients in the array is one larger than the order used to create the trend (order+1) and is indexed from 0.{\line}y = coef[0] + coef[1]x + coef[2]x^2 ...}\par
\f0\pard\sb180\shading1000{\fs30\b TrendPointCount \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set or get the number of points created for a trend line using CreateTrend.{\line}Default 50.}\par
\f0\pard\sb300\shading2000{\fs36\b LDGraphicsWindow}\par
\f0\pard{\fs20 GraphicsWindow utilities.}\par

\f0\pard\sb180\shading1000{\fs30\b Animate(scaleX,scaleY,panX,panY,angle,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scale and move all Shapes and Controls within the GraphicsWindow, by smooth animation.{\line}This is the same as the Reposition method except that the movement is animated.}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 The X direction scaling of the view.}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 The Y direction scaling of the view.}\par
\f0\pard\sb75{\fs24\b panX}\par
\f0\pard{\fs20 Pan the view in the X direction in the view scaling, 0 is centered in the GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b panY}\par
\f0\pard{\fs20 Pan the view in the Y direction in the view scaling, 0 is centered in the GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 An angle to rotate the view.}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 The time for the animation, in milliseconds.}\par
\f0\pard\sb180\shading1000{\fs30\b BackgroundBrush(brush) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the background as a gradient of colours.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 A previously created gradient or image brush (LDShapes.BrushGradient LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b BackgroundImage(imageName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the background as an image.{\line}The backgound is auto rescaled to fill whatever size the GraphicsWindow is.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The image to load as the background.{\line}Value returned from ImageList.LoadImage or local or network image file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b CancelClose \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Cancel the next GraphicsWindow Close operation "True" or "False" (default).{\line}Requires ExitOnClose to be set to "False".{\line}This should usually be set inside Closing event, possibly using LDDialogs.Confirm.{\line}It will be reset to "False" after a closure is prevented.}\par
\f0\pard\sb180\shading1000{\fs30\b Capture(fileName,border) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save the GraphicsWindow as an image file (png, jpg, bmp, gif, tiff or ico).{\line}{\line}The window must be visible and a short delay may be required after updating the window before calling.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file to save the image to (*.png, *.jpg, *.bmp, *.gif, *.tiff or *.ico).{\line}If this is set to "", then the image is created internally as an ImageList.}\par
\f0\pard\sb75{\fs24\b border}\par
\f0\pard{\fs20 Include the window border ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The ImageList image if fileName is "", otherwise if output to a file, then "" is returned.}\par
\f0\pard\sb180\shading1000{\fs30\b Closing \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a GraphicsWindow is closed.{\line}ExitOnClose must be set to "False" to use this event.{\line}If CancelClose is set to true, then the closure will be cancelled.}\par
\f0\pard\sb180\shading1000{\fs30\b ExitButtonMode(window,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the mode of the close button for a window.}\par
\f0\pard\sb75{\fs24\b window}\par
\f0\pard{\fs20 The window title, e.g. TextWindow.Title or GraphicsWindow.Title.}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 The mode "Enabled", "Disabled")}\par
\f0\pard\sb180\shading1000{\fs30\b ExitOnClose \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set whether the SmallBasic program is ended when a GraphicsWindow is closed "True" (default) or "False".{\line}If set to false, the program must still have something running to continue.}\par
\f0\pard\sb180\shading1000{\fs30\b FloodFill(x,y,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Fill a region surrounding a specified pixel.{\line}All neighbour pixels of the same colour are changed.{\line}This only applies to the drawing layer of the GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x co-ordinate of the pixel to start the fill.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y co-ordinate of the pixel to start the fill.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to fill with.}\par
\f0\pard\sb180\shading1000{\fs30\b FloodFillTolerance \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 A tolerance for FloodFill method (0 to 100).{\line}0 is default and only pixels of exactly the same colour are changed, 100 changes all pixels apart from new fill colour.}\par
\f0\pard\sb180\shading1000{\fs30\b GetPixel(x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the color of the pixel at the specified x and y co-ordinates.{\line}This method works for background, drawing and shape layers.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x co-ordinate of the pixel.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y co-ordinate of the pixel.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The color of the pixel.}\par
\f0\pard\sb180\shading1000{\fs30\b Height \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set or get the GraphicsWindow height if using LDScrollBars}\par
\f0\pard\sb180\shading1000{\fs30\b Icon \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the GraphicsWindow Icon, "SB" sets to Small Basic icon.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseX \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move the mouse to GraphicsWindow X coordinate.{\line}Set as well as get.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseXOffset \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scaling of GraphicsWindow to Desktop coordinates.{\line}Mouse.X = MouseXOffset + MouseXScale * GraphicsWindow.MouseX.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseXScale \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scaling of GraphicsWindow to Desktop coordinates.{\line}Mouse.X = MouseXOffset + MouseXScale * GraphicsWindow.MouseX.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseY \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move the mouse to GraphicsWindow Y coordinate.{\line}Set as well as get.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseYOffset \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scaling of GraphicsWindow to Desktop coordinates.{\line}Mouse.Y = MouseYOffset + MouseYScale * GraphicsWindow.MouseY.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseYScale \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scaling of GraphicsWindow to Desktop coordinates.{\line}Mouse.Y = MouseYOffset + MouseYScale * GraphicsWindow.MouseY.}\par
\f0\pard\sb180\shading1000{\fs30\b PauseUpdates() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pause GraphicsWindow Updates.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Print(border) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Print the GraphicsWindow contents.{\line}{\line}The window must be visible and a short delay may be required after updating the window before calling.}\par
\f0\pard\sb75{\fs24\b border}\par
\f0\pard{\fs20 Include the window border ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Reposition(scaleX,scaleY,panX,panY,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scale and move all Shapes and Controls within the GraphicsWindow.{\line}This method resizes and moves the view rather than the shapes, so their positions and other properties remain unchanged but appear scaled within the repositioned region.{\line}For example Shapes.GetLeft remains unchanged although the view has been repositioned and GraphicsWindow.MouseX reports the coordinates relative to the repositioned view.{\line}Imagine the entire view is repositioned as if it were a shape inside the GrapicsWindow.{\line}The transformation between view coordinates (vX,vY) and GraphicsWindow coordinates (gwX,gwY) is:{\line}gwX = (vX+panX)*scaleX + gw*(1-scaleX)/2{\line}gwY = (vY+panY)*scaleY + gh*(1-scaleY)/2{\line}All drawing remains within the original GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 The X direction scaling of the view.}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 The Y direction scaling of the view.}\par
\f0\pard\sb75{\fs24\b panX}\par
\f0\pard{\fs20 Pan the view in the X direction in the view scaling, 0 is centered in the GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b panY}\par
\f0\pard{\fs20 Pan the view in the Y direction in the view scaling, 0 is centered in the GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 An angle to rotate the view.}\par
\f0\pard\sb180\shading1000{\fs30\b RepositionedMouseX \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The mouse X GraphicsWindow coordinate in a repositioned view (see Reposition).}\par
\f0\pard\sb180\shading1000{\fs30\b RepositionedMouseY \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The mouse GraphicsWindow Y coordinate in a repositioned view (see Reposition).}\par
\f0\pard\sb180\shading1000{\fs30\b RepositionPoint(x,y,toGW) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get coordinates transformed between GraphicsWindow and a repositioned View (See Reposition).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x coordinate to transform.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The x coordinate to transform.}\par
\f0\pard\sb75{\fs24\b toGW}\par
\f0\pard{\fs20 Transfer from View to GraphicsWindow ("True") or from GraphicsWindow to View ("False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2D array of transformed coordinates indexed by 1 and 2.}\par
\f0\pard\sb180\shading1000{\fs30\b Resize \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The GraphicsWindow resize mode (CanMinimize 0, CanResize 1, CanResizeWithGrip 2, NoResize 3).}\par
\f0\pard\sb180\shading1000{\fs30\b ResumeUpdates() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Resume GraphicsWindow Updates.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b ScreenCapture \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Use screen capture for GraphicsWindow image creation.{\line}This only applies to Print and Capture methods when the border option is set to "False"{\line}If this option is set to "True" then the current visable GraphicsWindow is used to create a bitmap.{\line}If this option is set to "False" then the visuals in the GraphicsWindow will be re-rendered to a bitmap.{\line}Default "False"}\par
\f0\pard\sb180\shading1000{\fs30\b SetActive() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the GraphicsWindow as active (has focus).}\par
\f0\pard\sb180\shading1000{\fs30\b SetFontFromFile(fontFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set font in GraphicsWindow from a local TTF font file.}\par
\f0\pard\sb75{\fs24\b fontFile}\par
\f0\pard{\fs20 Full path to font file to set.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The font name on success, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ShowInTaskbar \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Show or hide GraphicsWindow in taskbar ("True" or "False")}\par
\f0\pard\sb180\shading1000{\fs30\b State \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The GraphicsWindow state (Normal 0, Minimised 1, Maximised 2).}\par
\f0\pard\sb180\shading1000{\fs30\b Style \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The GraphicsWindow style (None 0, SingleBorder 1, 3DBorder 2, ToolWindow 3).}\par
\f0\pard\sb180\shading1000{\fs30\b TopMost \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the GraphicsWindow as the top most window.{\line}The window will remain above other windows even when other windows are in focus.{\line}"True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b TransparentGW() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a transparent GraphicsWindow.{\line}This must be the called before any other GraphicsWindow, Controls or Shapes methods that create a window.{\line}To see anything you must add something to the transparent GraphicsWindow.{\line}For example, create a non-rectangular window using a transparent border png with LDShapes.BackgroundImage.{\line}The transparency can be altered with GraphicsWindow.BackgroundColor.{\line}Sometimes less than 100% transparency can be required (e.g. to register mouse movements).}\par
\f0\pard\sb180\shading1000{\fs30\b Width \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set or get the GraphicsWindow width if using LDScrollBars}\par
\f0\pard\sb300\shading2000{\fs36\b LDHID}\par
\f0\pard{\fs20 USB control for HID (Human Interface Devices).{\line}The VID and PID (4 character hex codes) for the device are required.{\line}Only HIDs will work using these methods.{\line}Hopefully this includes most game controllers, simple robotic devices and sensors.}\par

\f0\pard\sb180\shading1000{\fs30\b AddDevice(VID,PID,name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a HID connected device from its VID and PID.{\line}The VID and PID are 4 character (hex) values, and can be found from:{\line}Device Manager->Properties->Details->Hardware ids{\line}For example: HID\\VID_046D PID_C215 REV_0204 has VID "046D" and PID "C215".{\line}Only add a device once.}\par
\f0\pard\sb75{\fs24\b VID}\par
\f0\pard{\fs20 The device VID.}\par
\f0\pard\sb75{\fs24\b PID}\par
\f0\pard{\fs20 The device PID.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 A name for the device.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False" for success or failure}\par
\f0\pard\sb180\shading1000{\fs30\b FindDevices() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 List all found HID (Human Interface Devices).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2D array of all found devices.{\line}The first dimension is the found device indexed from 1.{\line}The second dimension is "VID", "PID" and "Description" holding the hex values of VID, PID and a device description.}\par
\f0\pard\sb180\shading1000{\fs30\b GetBits(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an 8 element array of 1s and 0s indicating which bit of a byte are set.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 A byte number (0 to 255).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An 8 element bit array (small bit first) or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Input \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when the HID input changes.}\par
\f0\pard\sb180\shading1000{\fs30\b InputLength(name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the input record length for a HID device.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The device name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of bytes in the input record.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDevice \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last HID device that had input.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The last device name.}\par
\f0\pard\sb180\shading1000{\fs30\b LastInput \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 An array of the last HID input data.{\line}This a set of values from 0 to 255 (bytes).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of input data or "" for none.}\par
\f0\pard\sb180\shading1000{\fs30\b Output(name,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Send data to the HID device.{\line}This must be an array of bytes (0 to 255).{\line}The array must be indexed from 1 and have size OutputLength.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The HID device name.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 The data to send.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False" for data consistency.}\par
\f0\pard\sb180\shading1000{\fs30\b OutputLength(name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the output record length for a HID device.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The HID device name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of bytes in the output record.}\par
\f0\pard\sb180\shading1000{\fs30\b Removed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when the HID device is removed.}\par
\f0\pard\sb180\shading1000{\fs30\b SetBits(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a byte from an 8 element array of 1s and 0s indicating which bit of a byte are set.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 An 8 element array of 1s and 0s (small bit first).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A byte number (0 to 255) or -1 on failure.}\par
\f0\pard\sb300\shading2000{\fs36\b LDIcon}\par
\f0\pard{\fs20 Create an icon (*.ico) or cursor (*.cur) file from an image.}\par

\f0\pard\sb180\shading1000{\fs30\b AddImages(Left,Right) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and adds}\par
\f0\pard\sb75{\fs24\b Left}\par
\f0\pard{\fs20 Image}\par
\f0\pard\sb75{\fs24\b Right}\par
\f0\pard{\fs20 Image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Product of addition}\par
\f0\pard\sb180\shading1000{\fs30\b Blurring(OriginalImage,X,Y,r) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image bluring}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b X}\par
\f0\pard{\fs20 Horizontal coordinate}\par
\f0\pard\sb75{\fs24\b Y}\par
\f0\pard{\fs20 Vertical coordinate}\par
\f0\pard\sb75{\fs24\b r}\par
\f0\pard{\fs20 Sharp region radius}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Blurred image}\par
\f0\pard\sb180\shading1000{\fs30\b BMatrix(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Separates blue color layer}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Blue color layer}\par
\f0\pard\sb180\shading1000{\fs30\b Cartoon(OriginalImage,R,Level,InverseThreshold,EdgeFilter) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Cartoon effect received by combining oil paint algorithm and edge detecting}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b R}\par
\f0\pard{\fs20 Radius of oil paint algorithm}\par
\f0\pard\sb75{\fs24\b Level}\par
\f0\pard{\fs20 Available levels of intensity}\par
\f0\pard\sb75{\fs24\b InverseThreshold}\par
\f0\pard{\fs20 Inverse threshold}\par
\f0\pard\sb75{\fs24\b EdgeFilter}\par
\f0\pard{\fs20 Edge detecting mask}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Cartoon effect result}\par
\f0\pard\sb180\shading1000{\fs30\b Cartoon(OriginalImage,R,Level,InverseThreshold) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Cartoon effect received by combining oil paint algorithm and Sobel edge detecting}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b R}\par
\f0\pard{\fs20 Radius of oil paint algorithm}\par
\f0\pard\sb75{\fs24\b Level}\par
\f0\pard{\fs20 Available levels of intensity}\par
\f0\pard\sb75{\fs24\b InverseThreshold}\par
\f0\pard{\fs20 Inverse threshold}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Cartoon effect result}\par
\f0\pard\sb180\shading1000{\fs30\b cmyk2rgb(cmyk) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Transforms CMYK color model to RGB}\par
\f0\pard\sb75{\fs24\b cmyk}\par
\f0\pard{\fs20 CMYK values [C, M, Y, K]}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 RGB color}\par
\f0\pard\sb180\shading1000{\fs30\b CMYKLayers(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Creates CMYK layesr from RGB image}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 CMYK layers as RGB bitmaps}\par
\f0\pard\sb180\shading1000{\fs30\b color2greyscale(pixel) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts RGB pixel to greyscale using luminance method}\par
\f0\pard\sb75{\fs24\b pixel}\par
\f0\pard{\fs20 RGB pixel}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Greyscale pixel}\par
\f0\pard\sb180\shading1000{\fs30\b ColorAccent(OriginalImage,h,range) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Color accent filtration}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b h}\par
\f0\pard{\fs20 Hue of accented color}\par
\f0\pard\sb75{\fs24\b range}\par
\f0\pard{\fs20 Range of acceptance}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Color accent filtration}\par
\f0\pard\sb180\shading1000{\fs30\b ColorFiltration(OriginalImage,color) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image color filtration with defined color filter}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b color}\par
\f0\pard{\fs20 Color filter. Available color filters are: Magenta, Yellow, Cyan, Magenta-Yellow, Cyan-Magenta, Yellow-Cyan}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Result of color filtration}\par
\f0\pard\sb180\shading1000{\fs30\b ContrastStretching(OriginalImage,RMinSet,RMaxSet) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and brighten using contrast stretching method.{\line}Brightness minimum and maximum available values are by default 0 and 255.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b RMinSet}\par
\f0\pard{\fs20 Minimum available brightness value}\par
\f0\pard\sb75{\fs24\b RMaxSet}\par
\f0\pard{\fs20 Maximum available brightness value}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Brigthen greyscaled image}\par
\f0\pard\sb180\shading1000{\fs30\b ContrastStretching(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 onverts ARGB images to greyscale using luminance method and brighten using contrast stretching method.{\line}Brightness minimum and maximum available values are by default 0 and 255.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Brigthen greyscaled image}\par
\f0\pard\sb180\shading1000{\fs30\b CreateCursor(imageName,cursorPath,size,xHotSpot,yHotSpot) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a cursor file.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The file path or ImageList image to create cursor from.  Best results will be obtained from a square image.}\par
\f0\pard\sb75{\fs24\b cursorPath}\par
\f0\pard{\fs20 The full path to save the cursor file (using extension *.cur).}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 The pixel size of cursor.}\par
\f0\pard\sb75{\fs24\b xHotSpot}\par
\f0\pard{\fs20 Pixel from left of cursor hot spot, indexed from 0.{\line}For images where the aspect ratio is maintained, the xHotSpot is also scaled.}\par
\f0\pard\sb75{\fs24\b yHotSpot}\par
\f0\pard{\fs20 Pixel from top of cursor hot spot, indexed from 0.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b CreateIcon(imageName,iconPath) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an icon file with 16*16, 24*24, 32*32, 64*64, 128*128 and 256*256 embedded images.{\line}To change these defaults use SetSizes method.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The file path or ImageList image to create icon from.  Best results will be obtained from a square image.}\par
\f0\pard\sb75{\fs24\b iconPath}\par
\f0\pard{\fs20 The full path to save the icon file (using extension *.ico).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED"}\par
\f0\pard\sb180\shading1000{\fs30\b DFT(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Discrete Fourier Transform of image}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Image spectrum}\par
\f0\pard\sb180\shading1000{\fs30\b DFT(Data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Discrete Fourier Transform of two-dimensional signal}\par
\f0\pard\sb75{\fs24\b Data}\par
\f0\pard{\fs20 Two-dimensional signal}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Spectrum}\par
\f0\pard\sb180\shading1000{\fs30\b GammaCorrection(OriginalImage,Gamma) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts image to greyscale and perform gamma correction}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b Gamma}\par
\f0\pard{\fs20 Gamma correction coefficient}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Gamma corrected image}\par
\f0\pard\sb180\shading1000{\fs30\b GammaCorrectionGS(OriginalImage,Gamma) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gamma correction}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b Gamma}\par
\f0\pard{\fs20 Gamma correction coefficient}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Gamma corrected image}\par
\f0\pard\sb180\shading1000{\fs30\b GF1() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gausian filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Gausian filter}\par
\f0\pard\sb180\shading1000{\fs30\b GF2() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gausian filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Gausian filter}\par
\f0\pard\sb180\shading1000{\fs30\b GF3() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gausian filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Gausian filter}\par
\f0\pard\sb180\shading1000{\fs30\b GMatrix(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Separates green color layer}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Green color layer}\par
\f0\pard\sb180\shading1000{\fs30\b Histogram(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and returns histogram}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Image histogram (each list position corresponds to brightness level)}\par
\f0\pard\sb180\shading1000{\fs30\b HistogramShift(OriginalImage,offset) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and shifts its histogram with respect to given offset.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b offset}\par
\f0\pard{\fs20 Shift offset}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Shifted greyscaled image}\par
\f0\pard\sb180\shading1000{\fs30\b HistoramEqualization(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and enhances contrast using equalization method.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Greyscaled contrast-enhances image}\par
\f0\pard\sb180\shading1000{\fs30\b HPF1() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 High pass filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 High pass filter}\par
\f0\pard\sb180\shading1000{\fs30\b HPF2() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 High pass filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 High pass filter}\par
\f0\pard\sb180\shading1000{\fs30\b HPF3() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 High pass filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 High pass filter}\par
\f0\pard\sb180\shading1000{\fs30\b HPF4() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 High pass filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 High pass filter}\par
\f0\pard\sb180\shading1000{\fs30\b hsv2rgb(hsv) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Transforms HSV color model to RGB}\par
\f0\pard\sb75{\fs24\b hsv}\par
\f0\pard{\fs20 HSV values [H, S, V]}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 RGB color}\par
\f0\pard\sb180\shading1000{\fs30\b iDFT(Spectrum) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Inverse Discrete Fourier Transform}\par
\f0\pard\sb75{\fs24\b Spectrum}\par
\f0\pard{\fs20 Image spectrum}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Image}\par
\f0\pard\sb180\shading1000{\fs30\b iDFT2(Spectrum) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Inverse Discrete Fourier Transform}\par
\f0\pard\sb75{\fs24\b Spectrum}\par
\f0\pard{\fs20 Signal spectrum}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Signal}\par
\f0\pard\sb180\shading1000{\fs30\b ImageCloseGS(OriginalImage,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image to greyscale convertion and opening with element of given size}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Opening element size}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Result of opening operation}\par
\f0\pard\sb180\shading1000{\fs30\b ImageCloseGS(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image to greyscale convertion and closing with 3x3 element}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Result of closing operation}\par
\f0\pard\sb180\shading1000{\fs30\b ImageDilatationFilterGS(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image filtartion with dilatation mask of 3 x 3 dimension.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageDilatationFilterGS(OriginalImage,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image filtartion with dilatation mask of given size.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Dilatation mask dimension}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageErosionFilterGS(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image filtartion with erosion mask of 3 x 3 dimension.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageErosionFilterGS(OriginalImage,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image filtartion with erosion mask of given size.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Erosion mask dimension}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageFilterColor(OriginalImage,Filter,Coef) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculates image convolution with given filter mask.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b Filter}\par
\f0\pard{\fs20 Filter mask}\par
\f0\pard\sb75{\fs24\b Coef}\par
\f0\pard{\fs20 Normalization coefficient}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageFilterColor(OriginalImage,Filter) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculates image convolution with given filter mask.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b Filter}\par
\f0\pard{\fs20 Filter mask}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageFilterColor(OriginalImage,Filter) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculates image convolution with given filter mask.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b Filter}\par
\f0\pard{\fs20 Filter mask}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageFilterGS(OriginalImage,Filter) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image convolution with given filter mask.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b Filter}\par
\f0\pard{\fs20 Filter mask}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered greyscaled image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageFilterGS(OriginalImage,Filter,Coef) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image convolution with given filter mask.{\line}Normalization using given coefficient.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b Filter}\par
\f0\pard{\fs20 Filter mask}\par
\f0\pard\sb75{\fs24\b Coef}\par
\f0\pard{\fs20 Normalization coefficient}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered greyscaled image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageFilterGS(OriginalImage,Filter) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image convolution with given filter mask.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b Filter}\par
\f0\pard{\fs20 Filter mask}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered greyscaled image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageKuwaharaFilterColor(OriginalImage,FilterSize) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kuwahara filtration}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b FilterSize}\par
\f0\pard{\fs20 Kuwahara filter size}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtred image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageKuwaharaFilterGS(OriginalImage,FilterSize) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image to greyscale convertion and kuwahara filtration}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b FilterSize}\par
\f0\pard{\fs20 Kuwahara filter size}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtred image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageMedianFilterColor(OriginalImage,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculates image filtartion with median mask of given size.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Median mask dimension}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageMedianFilterGS(OriginalImage,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image filtartion with median mask of given size.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Median mask dimension}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageOpenGS(OriginalImage,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image to greyscale convertion and opening with element of given size}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Opening element size}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Result of opening operation}\par
\f0\pard\sb180\shading1000{\fs30\b ImageOpenGS(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image to greyscale convertion and opening with 3x3 element}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Result of opening operation}\par
\f0\pard\sb180\shading1000{\fs30\b ImagePrewittFilterColor(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculates module of image convolution with Prewitt operators (horizontal and vertical axis)}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImagePrewittFilterGS(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates module of image convolution with Prewitt operators (horizontal and vertical axis)}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageSDROMFilterColor(OriginalImage,size,thresholds) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculates image filtartion with SD-ROM mask of given size.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 SD-ROM mask size}\par
\f0\pard\sb75{\fs24\b thresholds}\par
\f0\pard{\fs20 Array of thresholds}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtred image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageSDROMFilterColor(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ccalculates image filtartion with SD-ROM mask of size 3.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtred image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageSDROMFilterGS(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image filtartion with SD-ROM mask of size 3.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtred image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageSDROMFilterGS(OriginalImage,size,thresholds) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates image filtartion with SD-ROM mask of given size.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Orignal ARGB image}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 SD-ROM mask size}\par
\f0\pard\sb75{\fs24\b thresholds}\par
\f0\pard{\fs20 Array of thresholds}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtred image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageSobelFilterColor(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculates module of image convolution with Sobel operators (horizontal and vertical axis)}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b ImageSobelFilterGS(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and calculates module of image convolution with Sobel operators (horizontal and vertical axis)}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Filtered image}\par
\f0\pard\sb180\shading1000{\fs30\b InverseImage(OriginalImage,threshold) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB image to greyscale using luminance method and inverses it with respect to given threshold}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b threshold}\par
\f0\pard{\fs20 Inverse threshold}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Inversed image}\par
\f0\pard\sb180\shading1000{\fs30\b iSDFT(Spectrum) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Inverse shifted Discrete Fourier Transform}\par
\f0\pard\sb75{\fs24\b Spectrum}\par
\f0\pard{\fs20 Image spectrum}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Image}\par
\f0\pard\sb180\shading1000{\fs30\b iSDFT2(Spectrum) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Inverse shifted Discrete Fourier Transform}\par
\f0\pard\sb75{\fs24\b Spectrum}\par
\f0\pard{\fs20 Signal spectrum}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Signal}\par
\f0\pard\sb180\shading1000{\fs30\b LaplaceF1() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Laplace filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Laplace filter}\par
\f0\pard\sb180\shading1000{\fs30\b LaplaceF2() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Laplace filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Laplace filter}\par
\f0\pard\sb180\shading1000{\fs30\b LaplaceF3() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Laplace filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Laplace filter}\par
\f0\pard\sb180\shading1000{\fs30\b LaplaceF4() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Laplace filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Laplace filter}\par
\f0\pard\sb180\shading1000{\fs30\b LogaritmicScaling(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image histogram normalization using 10-base logarithm scaling}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original AGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Normalized image}\par
\f0\pard\sb180\shading1000{\fs30\b LPF1() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Low pass filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Low pass filter}\par
\f0\pard\sb180\shading1000{\fs30\b LPF2() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Low pass filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Low pass filter}\par
\f0\pard\sb180\shading1000{\fs30\b LPF3() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Low pass filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Low pass filter}\par
\f0\pard\sb180\shading1000{\fs30\b LPF4() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Low pass filter}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Low pass filter}\par
\f0\pard\sb180\shading1000{\fs30\b Magnitude(Spectrum) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculates array of magnitudes from array of complex elements}\par
\f0\pard\sb75{\fs24\b Spectrum}\par
\f0\pard{\fs20 Complex values array}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Magnitudes values array}\par
\f0\pard\sb180\shading1000{\fs30\b Matrix2Image(Matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts array elements into pixel values (without normalization)}\par
\f0\pard\sb75{\fs24\b Matrix}\par
\f0\pard{\fs20 Array}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Greyscale image}\par
\f0\pard\sb180\shading1000{\fs30\b Matrix2Image(Matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts array elements into pixel values (without normalization)}\par
\f0\pard\sb75{\fs24\b Matrix}\par
\f0\pard{\fs20 Array}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Greyscale image}\par
\f0\pard\sb180\shading1000{\fs30\b Matrix2ImageLog(Matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts array elements into pixel values (values normalized using 10-base logarithm)}\par
\f0\pard\sb75{\fs24\b Matrix}\par
\f0\pard{\fs20 Array}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Greyscale image}\par
\f0\pard\sb180\shading1000{\fs30\b Matrix2ImageMax(Matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts array elements into pixel values (values normalized using maximum element)}\par
\f0\pard\sb75{\fs24\b Matrix}\par
\f0\pard{\fs20 Array}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Greyscale image}\par
\f0\pard\sb180\shading1000{\fs30\b MaxBrightness(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Returns image maximum brightness level}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Maximum brightness level in given image}\par
\f0\pard\sb180\shading1000{\fs30\b MinBrightness(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Returns image minimum brightness level}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Minimum brightness level in given image}\par
\f0\pard\sb180\shading1000{\fs30\b NegativeImageColor(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate image negative}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Negative}\par
\f0\pard\sb180\shading1000{\fs30\b NegativeImageGS(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB image to greyscale using luminance method and calculates its negative}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Negative}\par
\f0\pard\sb180\shading1000{\fs30\b OilPaint(OriginalImage,R,Level) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Oil paint filtration}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 original ARGB image}\par
\f0\pard\sb75{\fs24\b R}\par
\f0\pard{\fs20 Radius of oil paint algorithm}\par
\f0\pard\sb75{\fs24\b Level}\par
\f0\pard{\fs20 Available levels of intensity}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Oil paint filtred image}\par
\f0\pard\sb180\shading1000{\fs30\b Phase(Spectrum) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculates array of phases from array of complex elements}\par
\f0\pard\sb75{\fs24\b Spectrum}\par
\f0\pard{\fs20 Complex values array}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Phases values array}\par
\f0\pard\sb180\shading1000{\fs30\b Resize(OriginalImage,Width,Height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image resize using nearest neighbour method}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original image}\par
\f0\pard\sb75{\fs24\b Width}\par
\f0\pard{\fs20 Output width}\par
\f0\pard\sb75{\fs24\b Height}\par
\f0\pard{\fs20 Output height}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Resized image}\par
\f0\pard\sb180\shading1000{\fs30\b Resize2(OriginalImage,Width,Height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image resize using bilinear interpolation method}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original image}\par
\f0\pard\sb75{\fs24\b Width}\par
\f0\pard{\fs20 Output width}\par
\f0\pard\sb75{\fs24\b Height}\par
\f0\pard{\fs20 Output height}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Resized image}\par
\f0\pard\sb180\shading1000{\fs30\b rgb2cmyk(pixel) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Transforms RGB color model to CMYK}\par
\f0\pard\sb75{\fs24\b pixel}\par
\f0\pard{\fs20 RGB color}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 CMYK values [C, M, Y, K]}\par
\f0\pard\sb180\shading1000{\fs30\b rgb2hsv(pixel) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Transforms RGB color model to HSV}\par
\f0\pard\sb75{\fs24\b pixel}\par
\f0\pard{\fs20 RGB color}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 HSV values [H, S, V]}\par
\f0\pard\sb180\shading1000{\fs30\b RGBHistogram(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Returns color image histogram}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Image histogram (dimension 0 corresponds to color code (0 ->Red, 1 -> Green, 2 -> Blue), dimension 1 - each position corresponds to brightness level)}\par
\f0\pard\sb180\shading1000{\fs30\b RGBLayers(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Seperates values of each RGB layer}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 [Red, Green, Blue] image layers as Bitmaps}\par
\f0\pard\sb180\shading1000{\fs30\b RGBMatrix(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Seperates values of each RGB layer}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 [Red, Green, Blue] image layers}\par
\f0\pard\sb180\shading1000{\fs30\b RMatrix(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Separates red color layer}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Red color layer}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(OriginalImage,Angle,xCenter,yCenter) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image rotation}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original image}\par
\f0\pard\sb75{\fs24\b Angle}\par
\f0\pard{\fs20 Rotate angle in degrees}\par
\f0\pard\sb75{\fs24\b xCenter}\par
\f0\pard{\fs20 X Center}\par
\f0\pard\sb75{\fs24\b yCenter}\par
\f0\pard{\fs20 Y Center}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Rotated image}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(OriginalImage,Angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Image rotation}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original image}\par
\f0\pard\sb75{\fs24\b Angle}\par
\f0\pard{\fs20 Rotate angle in degrees}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Rotated image}\par
\f0\pard\sb180\shading1000{\fs30\b SDFT(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Shifted Discrete Fourier Transform of image.}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Shifted image spectrum}\par
\f0\pard\sb180\shading1000{\fs30\b SDFT(Data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Shifted Discrete Fourier Transform of two-dimensional signal}\par
\f0\pard\sb75{\fs24\b Data}\par
\f0\pard{\fs20 Two-dimensional signal}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Shifted spectrum}\par
\f0\pard\sb180\shading1000{\fs30\b Sepia(OriginalImage,Coef) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sepia filtration}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b Coef}\par
\f0\pard{\fs20 Sepia level}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Sepia image}\par
\f0\pard\sb180\shading1000{\fs30\b SetSizes(sizes) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the default icon sizes.  This should be called before CreateIcon.}\par
\f0\pard\sb75{\fs24\b sizes}\par
\f0\pard{\fs20 A space separated list of integer icon sizes, default is "16 24 32 64 128 256".{\line}An array of integer icon sizes may also be used.{\line}The maximum size is 256.}\par
\f0\pard\sb180\shading1000{\fs30\b Shift(Data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Shifts array components}\par
\f0\pard\sb75{\fs24\b Data}\par
\f0\pard{\fs20 Original array}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Shifted array}\par
\f0\pard\sb180\shading1000{\fs30\b Shift(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Transforms image into to shifted array of doubles }\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Shifted array}\par
\f0\pard\sb180\shading1000{\fs30\b Sketch(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pen sketch effect received by combining laplace edge detecting, black and white transformation with inversion on point 35 and SDROM filter to eliminate smaller artefacts}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Sketch effect image}\par
\f0\pard\sb180\shading1000{\fs30\b SketchCharcoal(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Charcoal sketch effect received by combining median filtration with mask size of 5, Sobel edge detecting, image inversion on point 80}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Sketch effect image}\par
\f0\pard\sb180\shading1000{\fs30\b SquareImage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scale images to keep the aspect ratio of images square (width = height), "True" (default) or "False".{\line}If set to "False" then the width of the icon or cursor will be scaled to maintain the image aspect ratio, while maintaining the set height.}\par
\f0\pard\sb180\shading1000{\fs30\b SubtractImages(Left,Right) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB images to greyscale using luminance method and subtracts}\par
\f0\pard\sb75{\fs24\b Left}\par
\f0\pard{\fs20 Minuend image}\par
\f0\pard\sb75{\fs24\b Right}\par
\f0\pard{\fs20 Subtrahend image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Product of subtraction}\par
\f0\pard\sb180\shading1000{\fs30\b TiltShift(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Tilt shift filtration}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Tilt shifted image}\par
\f0\pard\sb180\shading1000{\fs30\b ToBlackwhite(OriginalImage,threshold) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB image to black and white and inverses it with respect to given threshold}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b threshold}\par
\f0\pard{\fs20 Threshold}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Balck and white image}\par
\f0\pard\sb180\shading1000{\fs30\b ToBlackwhiteInverse(OriginalImage,threshold) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB image to black and white and inverses it with respect to given threshold}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b threshold}\par
\f0\pard{\fs20 Threshold}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Balck and white image}\par
\f0\pard\sb180\shading1000{\fs30\b ToGreyscale(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB image to greyscale using luminance method}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Greyscaled image}\par
\f0\pard\sb180\shading1000{\fs30\b ToGreyscaleAVG(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB image to greyscale using average method}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Greyscaled image}\par
\f0\pard\sb180\shading1000{\fs30\b ToGreyscaleLightness(OriginalImage) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts ARGB image to greyscale using lightness method}\par
\f0\pard\sb75{\fs24\b OriginalImage}\par
\f0\pard{\fs20 Original ARGB image}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Greyscaled image}\par
\f0\pard\sb300\shading2000{\fs36\b LDImage}\par
\f0\pard{\fs20 Provides methods to modify and image process images stored in ImageList.{\line}Any effect parameter can be defaulted to "".}\par

\f0\pard\sb180\shading1000{\fs30\b Add(image,red,green,blue) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add colour values to image.{\line}An image has pixels with R,G,B in the range 0 to 255.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b red}\par
\f0\pard{\fs20 Red value to add.}\par
\f0\pard\sb75{\fs24\b green}\par
\f0\pard{\fs20 Geen value to add.}\par
\f0\pard\sb75{\fs24\b blue}\par
\f0\pard{\fs20 Blue value to add.}\par
\f0\pard\sb180\shading1000{\fs30\b AddImages(image1,image2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add 2 images together.{\line}An image has pixels with R,G,B in the range 0 to 255.{\line}Both images must be the same dimension.}\par
\f0\pard\sb75{\fs24\b image1}\par
\f0\pard{\fs20 The first ImageList image to add.}\par
\f0\pard\sb75{\fs24\b image2}\par
\f0\pard{\fs20 The second ImageList image to add.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A new ImageList image with the result or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b AddText(imageName,text,x,y,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Annotate an image with text, using current GraphicsWindow font.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 An existing ImageList image.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to add}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The left position of the text.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The Top position of the text.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The text colour.}\par
\f0\pard\sb180\shading1000{\fs30\b CloseWorkingImage(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Close and reset the image from a temporary working image.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The working image, previously opened with OpenWorkingImage.}\par
\f0\pard\sb180\shading1000{\fs30\b ColorMatrix(image,matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Performs a colour matrix transformation on an image.{\line}This can be used for all sorts of colour transformations.{\line}See http://msdn.microsoft.com/en-us/library/a7xw19wh%28v=vs.110%29.aspx.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 A 5*5 2D matrix.{\line}Sepia Example:{\line}matrix[1] = "1=0.393;2=0.349;3=0.272;4=0;5=0"{\line}matrix[2] = "1=0.769;2=0.686;3=0.534;4=0;5=0"{\line}matrix[3] = "1=0.189;2=0.168;3=0.131;4=0;5=0"{\line}matrix[4] = "1=0;2=0;3=0;4=1;5=0"{\line}matrix[5] = "1=0;2=0;3=0;4=0;5=1"}\par
\f0\pard\sb180\shading1000{\fs30\b Copy(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy an image from the ImageList.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to copy.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A new ImageList image or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Crop(image,x,y,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Crop an image from the ImageList.{\line}The crop region must be entirely within the target image.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to crop.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The left position of the cropped image in pixels (indexed from 0).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The top position of the cropped image in pixels (indexed from 0).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the cropped image in pixels.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the cropped image in pixels.}\par
\f0\pard\sb180\shading1000{\fs30\b DifferenceImages(image1,image2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Difference 2 images.{\line}An image has pixels with R,G,B in the range 0 to 255.{\line}Both images must be the same dimension.}\par
\f0\pard\sb75{\fs24\b image1}\par
\f0\pard{\fs20 The first ImageList image to difference.}\par
\f0\pard\sb75{\fs24\b image2}\par
\f0\pard{\fs20 The second ImageList image to difference.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A new ImageList image with the result or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectAccent(image,hue,range) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to colour accent effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b hue}\par
\f0\pard{\fs20 Accent Hue (0 o 360, default 0 (red)).}\par
\f0\pard\sb75{\fs24\b range}\par
\f0\pard{\fs20 Accent range (default 40).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBlocks(image,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to block effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Blocking size factor (default 5).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBlue(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to blue colour.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBulge(image,factor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to bulge effect (similar to FishEye).}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b factor}\par
\f0\pard{\fs20 Bulge factor, may be less than 1 for pinch effect (default 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectCartoon(image,radius,levels,inverse) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to cartoon effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Cartoon radius (odd number, default 7).}\par
\f0\pard\sb75{\fs24\b levels}\par
\f0\pard{\fs20 Cartoon levels (default 10).}\par
\f0\pard\sb75{\fs24\b inverse}\par
\f0\pard{\fs20 Cartoon inverse threshold (default 40).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectCharcoal(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to charcoal effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectContrast(image,contrast) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to high contrast effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b contrast}\par
\f0\pard{\fs20 Contrast factor (default 2), less than 1 reduces contrast.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectCyan(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to cyan colour.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectDefaults \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or set an array of default effect parameters.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectEdge(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to Prewitt edge effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectFishEye(image,factor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to fisheye effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b factor}\par
\f0\pard{\fs20 FishEye factor, should be greater than 1 (default 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectFuzzy(image,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to fuzzy effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Pixel region to make fuzzy (default 4).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectGamma(image,gamma) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to gamma effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b gamma}\par
\f0\pard{\fs20 Gamma factor, values less than 1 lighten and greater than 1 darken (default 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectGray(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to gray scale.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectGreen(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to green colour.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectHue(image,hue) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to modify Hue.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b hue}\par
\f0\pard{\fs20 Hue shift (0 to 360, default 180).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectInverse(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to inverse colour.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectJagged(image,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to jagged effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Pixel region size to make jagged (default 4).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectLightness(image,lightness) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to modify Lightness.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b lightness}\par
\f0\pard{\fs20 Lightness multiplier (default 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectMagenta(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to magenta colour.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectNoiseRemoval(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to noise removal effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectOilPaint(image,radius,levels) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to oil paint effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Oil paint radius (odd number, default 7).}\par
\f0\pard\sb75{\fs24\b levels}\par
\f0\pard{\fs20 Oil paint levels (default 20).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectPixelate(image,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to pixelate effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Pixelating size factor (default 16).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectPosterise(image,level) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to posterise effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b level}\par
\f0\pard{\fs20 Posterise level (default 50).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectRed(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to red colour.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectReflect(image,flip) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to X or Y reflection effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b flip}\par
\f0\pard{\fs20 0 to flip X and 1 to flip Y (default 0).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectRotate(image,rotation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to 90 degree rotation effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b rotation}\par
\f0\pard{\fs20 0 for +90, 1 for 180 and 2 for 270(-90) degree rotation (default 0).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSaturation(image,saturation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to modify Saturation.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b saturation}\par
\f0\pard{\fs20 Saturation multiplier (default 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSepia(image,threshold) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to sepia effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b threshold}\par
\f0\pard{\fs20 Sepia threshold (default 30).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSketch(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to pen sketch effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSnow(image,level) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to snow effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b level}\par
\f0\pard{\fs20 1 in level pixels are randomly snow (default 25).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSolarise(image,power) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to solarise effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b power}\par
\f0\pard{\fs20 Solarise power (default 2, quadratic).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSwirl(image,factor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to swirl effect.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b factor}\par
\f0\pard{\fs20 Swirl factor (default 1).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectYellow(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts to yellow colour.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb180\shading1000{\fs30\b GetEffects() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of the available image and webcam effects.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of effects, indexed by the effect number.}\par
\f0\pard\sb180\shading1000{\fs30\b GetImagePixels(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a 2D array filled with all the pixels in an image.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of hex based image pixel colours indexed by [x][y].}\par
\f0\pard\sb180\shading1000{\fs30\b GetPixel(image,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a pixel colour.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x pixel (indexed from 1).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y pixel (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The pixel colour.}\par
\f0\pard\sb180\shading1000{\fs30\b GetWorkingImagePixel(image,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the colour of a pixel from a temporary working image.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The working image, previously opened with OpenWorkingImage.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x pixel coordinate (indexed from 1).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y pixel coordinate (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The pixel colour or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b GetWorkingImagePixelARGB(image,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the colour of a pixel from a temporary working image.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The working image, previously opened with OpenWorkingImage.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x pixel coordinate (indexed from 1).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y pixel coordinate (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The pixel colour, an array of A,R,G,B components indexed by "A", "R", "G", "B" or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b HeightMap2NormalMap(image,scale) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a normal map image from a height map.  The height is given by the brightness of each pixel.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The height map ImageList image.}\par
\f0\pard\sb75{\fs24\b scale}\par
\f0\pard{\fs20 A scale factor for the elevation (default 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A new ImageList image with the resulting normal map.}\par
\f0\pard\sb180\shading1000{\fs30\b Histogram(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get histograms of colour pixel values.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of colour histograms, indexed by 1,2,3 for R,G,B and 0 to 255.}\par
\f0\pard\sb180\shading1000{\fs30\b LoadSVG(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Load an SVG file as an ImageList image.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The SVG file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb180\shading1000{\fs30\b MakeTransparent(image,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Modify an ImageList image to make a selected colour transparent.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to make transparent.}\par
\f0\pard\sb180\shading1000{\fs30\b MetaData(imageFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of image metadata.}\par
\f0\pard\sb75{\fs24\b imageFile}\par
\f0\pard{\fs20 The image file (not an ImageList image).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of metadata values indexed by hex id (Use quotes for indices with a to f in the hex values).{\line}See https://msdn.microsoft.com/en-us/library/System.Drawing.Imaging.propertyitem.id%28v=vs.110%29.aspx for a list of ids.}\par
\f0\pard\sb180\shading1000{\fs30\b Multiply(image,red,green,blue) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Multiply colour values of image.{\line}An image has pixels with R,G,B in the range 0 to 255.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b red}\par
\f0\pard{\fs20 Red value to multiply by.}\par
\f0\pard\sb75{\fs24\b green}\par
\f0\pard{\fs20 Geen value to multiply by.}\par
\f0\pard\sb75{\fs24\b blue}\par
\f0\pard{\fs20 Blue value to multiply by.}\par
\f0\pard\sb180\shading1000{\fs30\b NewImage(width,height,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new single colored 32bitARGB image in ImageList.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the new image.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the new image.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour of the new image.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The Name of the new created ImageList image on success, else "".}\par
\f0\pard\sb180\shading1000{\fs30\b NormalMap(shapeName,sourceX,sourceY,sourceZ,texture,ambient,intensity) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Modify an image to show a gray scale (or modified image if texture is set) shadow effect based on a normal map image.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 An image shape normal map (R,G,B colours represent normal vecors of a 3D image).{\line}This is an image shape created using Shapes.AddImage containing the normal map image.}\par
\f0\pard\sb75{\fs24\b sourceX}\par
\f0\pard{\fs20 The x position of a light source relative to the image.}\par
\f0\pard\sb75{\fs24\b sourceY}\par
\f0\pard{\fs20 The y position of a light source relative to the image.}\par
\f0\pard\sb75{\fs24\b sourceZ}\par
\f0\pard{\fs20 The z position of a light source relative to the image, this is the height abouve the image.{\line}This can be used to alter the effective contrast of the shadow effect.}\par
\f0\pard\sb75{\fs24\b texture}\par
\f0\pard{\fs20 An optional ImageList image or "" with texture (colour) to modify, it should be the same dimensions as the normal map image.{\line}The texture image may be changed on subsequent calls.}\par
\f0\pard\sb75{\fs24\b ambient}\par
\f0\pard{\fs20 Optional ambient light intensity if texture is set (default 0.3).}\par
\f0\pard\sb75{\fs24\b intensity}\par
\f0\pard{\fs20 Optional light intensity if texture is set (default 2).}\par
\f0\pard\sb180\shading1000{\fs30\b OpenWorkingImage(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Open a temporary working image for fast pixel level manipulation.{\line}After the temporary working image is finished with it should be set to the image using CloseWorkingImage.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to open as a temporary working image.}\par
\f0\pard\sb180\shading1000{\fs30\b Remove(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove an image from the ImageList.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to delete.}\par
\f0\pard\sb180\shading1000{\fs30\b ReplaceColour(image,colourFrom,colourTo,tolerance) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Replace one colour in an ImageList image with another.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb75{\fs24\b colourFrom}\par
\f0\pard{\fs20 The colour to replace.}\par
\f0\pard\sb75{\fs24\b colourTo}\par
\f0\pard{\fs20 The replacement colour to apply.}\par
\f0\pard\sb75{\fs24\b tolerance}\par
\f0\pard{\fs20 A tolerance for the colour to match (default 0 - exact match).{\line}ARGB pixel values all within the tolerance will be replaced.}\par
\f0\pard\sb180\shading1000{\fs30\b Resize(image,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Resize an image from the ImageList.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to resize.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width in pixels.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height in pixels.}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(image,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotate an image.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to modify.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle to rotate the image clockwise by in degrees.}\par
\f0\pard\sb180\shading1000{\fs30\b Save(image,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save an image from the ImageList as a jpg.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to save.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file to save the image as.}\par
\f0\pard\sb180\shading1000{\fs30\b SaveAs(image,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save an image from the ImageList in different formats set by the file extension.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image to save.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file to save the image as.{\line}Accepted file type extensions include *.bmp, *.gif, *.jpg, *.png, *.tiff or *.ico.}\par
\f0\pard\sb180\shading1000{\fs30\b SetImagePixels(pixels) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new image from a 2D array of pixel colour values - see GetImagePixels for format of pixels.}\par
\f0\pard\sb75{\fs24\b pixels}\par
\f0\pard{\fs20 An array of hex based image pixel colours indexed by [x][y].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An ImageList image created from the pixels.}\par
\f0\pard\sb180\shading1000{\fs30\b SetPixel(image,x,y,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a pixel colour.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x pixel (indexed from 1).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y pixel (indexed from 1).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to set the pixel.}\par
\f0\pard\sb180\shading1000{\fs30\b SetWorkingImagePixel(image,x,y,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the colour of a pixel in a temporary working image.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The working image, previously opened with OpenWorkingImage.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x pixel coordinate (indexed from 1).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y pixel coordinate (indexed from 1).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The colour to set the pixel to.}\par
\f0\pard\sb180\shading1000{\fs30\b SplitImage(imageName,countX,countY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Creates an array of subdivided images from an input image.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The image file (local or network) to load.{\line}Can also be an ImageList image.}\par
\f0\pard\sb75{\fs24\b countX}\par
\f0\pard{\fs20 The number of sub-images in the X direction.}\par
\f0\pard\sb75{\fs24\b countY}\par
\f0\pard{\fs20 The number of sub-images in the Y direction.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2D array of resulting images saved in ImageList.}\par
\f0\pard\sb180\shading1000{\fs30\b Statistics(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the minimum, maximum, mean and STD for colour pixel values.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of statistics values (0 to 255), indexed by "Min", "Max", "Mean", "STD" and 1,2,3 for R,G,B.}\par
\f0\pard\sb180\shading1000{\fs30\b To32bitARGB(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Converts an ImageList image to Format ARGB (Alphachannel with 32bit/Pxl) if needed.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The ImageList image.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b UseFastPixelMethods \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Use a fast pixel manipulation method (default "True").{\line}This method can be turned off using this property.}\par
\f0\pard\sb300\shading2000{\fs36\b LDInline}\par
\f0\pard{\fs20 Include C#, VB or JScript code to use at runtime.  {\line}If multiple namespaces or classes are used, then all method, property or event names should be unique.{\line}Alternatively a fully qualified namespace.type.name may be used.{\line}Can be used to compile extensions.{\line}May also be used with other .Net dlls compiled externally.{\line}Method, property, event, class and used references can be obtained (public static only).{\line}{\line}The current application assemblies are auto referenced.{\line}Depending on .Net methods used additional assemblies may be required.{\line}Additional assemblies are referenced by full dll path.{\line}Assembly dlls are often found in the following or similar locations:{\line}C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727{\line}C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.0{\line}{\line}The TextWindow should be visible prior to using these methods if later use of the TextWindow is required.}\par

\f0\pard\sb180\shading1000{\fs30\b Call(method,args) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Call a previously included method.}\par
\f0\pard\sb75{\fs24\b method}\par
\f0\pard{\fs20 The method name.}\par
\f0\pard\sb75{\fs24\b args}\par
\f0\pard{\fs20 The method arguments, "" for none, a single value or an array for more than 1 value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Any results from the call or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Event(Event,callBack) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a callback subroutine for a previously included event.}\par
\f0\pard\sb75{\fs24\b Event}\par
\f0\pard{\fs20 The event name.}\par
\f0\pard\sb75{\fs24\b callBack}\par
\f0\pard{\fs20 The callback subroutine.}\par
\f0\pard\sb180\shading1000{\fs30\b Get(property) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a previously included property.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 The property name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The property value or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAssemblies(fullName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of inline assemblies used.{\line}These are the referenced assemblies that are actually used.}\par
\f0\pard\sb75{\fs24\b fullName}\par
\f0\pard{\fs20 Get the fully qualified name (with version, culture and PublicKeyToken) "True" or the basic name "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Array of assembly names and dll locations.}\par
\f0\pard\sb180\shading1000{\fs30\b GetEvents() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of inline events loaded.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Array of event names and handler type.}\par
\f0\pard\sb180\shading1000{\fs30\b GetMethodParameters(method) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of inline method loaded parameters (arguments).}\par
\f0\pard\sb75{\fs24\b method}\par
\f0\pard{\fs20 The method name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Array of parameter names and type.}\par
\f0\pard\sb180\shading1000{\fs30\b GetMethods(fullName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of inline methods loaded.}\par
\f0\pard\sb75{\fs24\b fullName}\par
\f0\pard{\fs20 Get the full name (namespace.type.method) "True" or just the method name "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Array of method names and return type.}\par
\f0\pard\sb180\shading1000{\fs30\b GetProperties() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of inline properties loaded.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Array of property names and type.}\par
\f0\pard\sb180\shading1000{\fs30\b GetReferences(fullName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of inline references added.{\line}These are the referenced added, they may or may not be used.}\par
\f0\pard\sb75{\fs24\b fullName}\par
\f0\pard{\fs20 Get the fully qualified name (with version, culture and PublicKeyToken) "True" or the basic name "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Array of reference names and dll locations.}\par
\f0\pard\sb180\shading1000{\fs30\b GetTypes() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of inline class types loaded.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Array of class types and namespace.}\par
\f0\pard\sb180\shading1000{\fs30\b IncludeCS(source,assemblies,dllName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Include and compile a C# Class(es).  Can be the contents of a file read with File.ReadContents().}\par
\f0\pard\sb75{\fs24\b source}\par
\f0\pard{\fs20 The C# source.}\par
\f0\pard\sb75{\fs24\b assemblies}\par
\f0\pard{\fs20 An array of any additional assemblies required.}\par
\f0\pard\sb75{\fs24\b dllName}\par
\f0\pard{\fs20 An optional path to create a dll (+xml) output, use "" to perform in-memory.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "SUCCESS"}\par
\f0\pard\sb180\shading1000{\fs30\b IncludeJScript(source,assemblies,dllName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Include and compile a JScript Module(s).  Can be the contents of a file read with File.ReadContents().}\par
\f0\pard\sb75{\fs24\b source}\par
\f0\pard{\fs20 The JScript source.}\par
\f0\pard\sb75{\fs24\b assemblies}\par
\f0\pard{\fs20 An array of any additional assemblies required.}\par
\f0\pard\sb75{\fs24\b dllName}\par
\f0\pard{\fs20 An optional path to create a dll output, use "" to perform in-memory.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "SUCCESS"}\par
\f0\pard\sb180\shading1000{\fs30\b IncludeVB(source,assemblies,dllName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Include and compile a VB Module(s).  Can be the contents of a file read with File.ReadContents().}\par
\f0\pard\sb75{\fs24\b source}\par
\f0\pard{\fs20 The VB source.}\par
\f0\pard\sb75{\fs24\b assemblies}\par
\f0\pard{\fs20 An array of any additional assemblies required.}\par
\f0\pard\sb75{\fs24\b dllName}\par
\f0\pard{\fs20 An optional path to create a dll (+xml) output, use "" to perform in-memory.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "SUCCESS"}\par
\f0\pard\sb180\shading1000{\fs30\b LoadDLL(dllName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Use a previously compiled and saved dll.}\par
\f0\pard\sb75{\fs24\b dllName}\par
\f0\pard{\fs20 The dll path.}\par
\f0\pard\sb180\shading1000{\fs30\b Set(property,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a previously included property.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 The property name.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The property value.}\par
\f0\pard\sb300\shading2000{\fs36\b LDIOWarrior}\par
\f0\pard{\fs20 Access IO-Warrior devices.{\line}See http://www.codemercs.com/io-warrior/?L=1}\par

\f0\pard\sb180\shading1000{\fs30\b Detatch() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Disconnect all IO-Warrior devices.}\par
\f0\pard\sb180\shading1000{\fs30\b GetName(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the device name.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 The device number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The device name or "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetPID(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the device PID.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 The device number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The device PID (hex) or 0.}\par
\f0\pard\sb180\shading1000{\fs30\b GetReportSize(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the report size.{\line}Number of bytes in a Read/Write.{\line}This the report size for channel 0.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 The device number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The report size or 0.}\par
\f0\pard\sb180\shading1000{\fs30\b GetSerialNumber(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the device serial number.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 The device number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The device serial number or "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetSpecialReportSize(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the special report size.{\line}Number of bytes in a special Read/Write.{\line}This the report size for channel 1.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 The device number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The special report size or 0.}\par
\f0\pard\sb180\shading1000{\fs30\b GetVersion(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the device firmware version.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 The device number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The device firmware version or 0.}\par
\f0\pard\sb180\shading1000{\fs30\b GetVID() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the device VID (Common to all IOWarrior types).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The device VID (hex) or 0.}\par
\f0\pard\sb180\shading1000{\fs30\b Initialise() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Initialise IO-Warrior devices.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of devices.}\par
\f0\pard\sb180\shading1000{\fs30\b LastError() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the last system error message.{\line}"" for no error (probably only useful for detailed error analysis of underlying system calls).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Last error number.}\par
\f0\pard\sb180\shading1000{\fs30\b LCDWrite(id,text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Write text to the LCD (untested).}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 The device number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to write.}\par
\f0\pard\sb180\shading1000{\fs30\b Read(id,channel,blocking,count) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read from the IO-Warrior device.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 The device number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b channel}\par
\f0\pard{\fs20 The channel to read (indexed from 0).}\par
\f0\pard\sb75{\fs24\b blocking}\par
\f0\pard{\fs20 "True" (return after the state changes) or "False" (return with current state).}\par
\f0\pard\sb75{\fs24\b count}\par
\f0\pard{\fs20 The number of bytes to read (if zero, then the ReportSize is used if channel is 0 or SpecialReportSize if channel is 1).{\line}See GetReportSize and GetSpecialReportSize.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of read bytes [0 to 255].}\par
\f0\pard\sb180\shading1000{\fs30\b Timeout \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The timeout for read and writes in ms.{\line}Default 1000.}\par
\f0\pard\sb180\shading1000{\fs30\b Write(id,channel,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Write to the IO-Warrior device.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 The device number (indexed from 1).}\par
\f0\pard\sb75{\fs24\b channel}\par
\f0\pard{\fs20 The channel to write to (indexed from 0).}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 An array of bytes to send [0 to 255].{\line}The array size should be ReportSize for channel 0 and SpecialReportSize for channel 1.{\line}See GetReportSize and GetSpecialReportSize.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of bytes successfully written.}\par
\f0\pard\sb300\shading2000{\fs36\b LDList}\par
\f0\pard{\fs20 This object provides a way of storing values like an array that reorders itself as items are added or removed.{\line}A list is an efficient array store (much faster than SmallBasic arrays) that can be indexed by integers and perform various other operations.{\line}The indexing is automatically updated (indexed from 1) as the list changes.}\par

\f0\pard\sb180\shading1000{\fs30\b Add(listName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Adds a value to the end of a specified list.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to add.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Append(listName1,listName2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Appends a second list to the end of a first list.}\par
\f0\pard\sb75{\fs24\b listName1}\par
\f0\pard{\fs20 The name of the first list.}\par
\f0\pard\sb75{\fs24\b listName2}\par
\f0\pard{\fs20 The name of the second list to append to listName1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Clear(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove all values from a specified list.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Contains(listName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Check if a value is present within the specified list.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to check.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Copy(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy a list.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A copy of the list.}\par
\f0\pard\sb180\shading1000{\fs30\b Count(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the count of items in the specified list.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromIndices(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy a SmallBasic array indices to a list.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 The SmallBasic array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The created list.}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromValues(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy a SmallBasic array to a list.{\line}The array indices are ignored by the list.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 The SmallBasic array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The created list.}\par
\f0\pard\sb180\shading1000{\fs30\b Distinct(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a sub list of unique values from the specified list.{\line}The text comparison is case insensitive.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The sub list.}\par
\f0\pard\sb180\shading1000{\fs30\b Except(listName1,listName2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a sub list of non-shared values between two specified lists.{\line}The text comparison is case insensitive.}\par
\f0\pard\sb75{\fs24\b listName1}\par
\f0\pard{\fs20 The name of the first list.}\par
\f0\pard\sb75{\fs24\b listName2}\par
\f0\pard{\fs20 The name of the second list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The except list.}\par
\f0\pard\sb180\shading1000{\fs30\b Find(listName,match,exact) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a sub list from the specified list where a text match is found.{\line}The text match is case insensitive.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b match}\par
\f0\pard{\fs20 The match text.}\par
\f0\pard\sb75{\fs24\b exact}\par
\f0\pard{\fs20 An exact match (case insensitive) "True" or the match text is contained in the list "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The sub list.}\par
\f0\pard\sb180\shading1000{\fs30\b FindIndices(listName,match,exact) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a sub list of indices from the specified list where a text match is found.{\line}The text match is case insensitive.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b match}\par
\f0\pard{\fs20 The match text.}\par
\f0\pard\sb75{\fs24\b exact}\par
\f0\pard{\fs20 An exact match (case insensitive) "True" or the match text is contained in the list "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The sub list of indices in the list where a match is found.}\par
\f0\pard\sb180\shading1000{\fs30\b GetAt(listName,index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a value from a specified list by index (starting from 1).}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The value index to get.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The list value.}\par
\f0\pard\sb180\shading1000{\fs30\b IndexOf(listName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the index (starting from 1) of the first occurance of a value from the specified list.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to get index of (0 for not found).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The value index or 0.}\par
\f0\pard\sb180\shading1000{\fs30\b InsertAt(listName,index,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Insert a value in a specified list by index (starting from 1).}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index to insert at.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to insert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Intersect(listName1,listName2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a sub list of shared values between two specified lists.{\line}The text comparison is case insensitive.}\par
\f0\pard\sb75{\fs24\b listName1}\par
\f0\pard{\fs20 The name of the first list.}\par
\f0\pard\sb75{\fs24\b listName2}\par
\f0\pard{\fs20 The name of the second list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The intersection list.}\par
\f0\pard\sb180\shading1000{\fs30\b Print(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Print a list to the TextWindow.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Read(filePath) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read a list from a file.}\par
\f0\pard\sb75{\fs24\b filePath}\par
\f0\pard{\fs20 The full path to read the list from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The list if the operation was successful, otherwise "".}\par
\f0\pard\sb180\shading1000{\fs30\b Remove(listName,match,exact) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove all occurances from the specified list where a text match is found.{\line}The text match is case insensitive.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b match}\par
\f0\pard{\fs20 The match text.}\par
\f0\pard\sb75{\fs24\b exact}\par
\f0\pard{\fs20 An exact match (case insensitive) "True" or the match text is contained in the list "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveAt(listName,index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove a value from a specified list by index (starting from 1).}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The value index to remove.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Reverse(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reverse the order of values in the specified list.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b SetAt(listName,index,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set (replace) a value in a specified list by index (starting from 1).}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The index to set.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to set.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b SortByNumber(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sort a specified list with values treated as numbers.{\line}All values must be numbers.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b SortByText(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sort a specified list with values treated as text strings (lexical sort).{\line}The sort is case insensitive.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b SubList(listName,start,length) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a sub list from the specified list.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b start}\par
\f0\pard{\fs20 The first index of the sub list.}\par
\f0\pard\sb75{\fs24\b length}\par
\f0\pard{\fs20 The length of the sub list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The sub list.}\par
\f0\pard\sb180\shading1000{\fs30\b ToArray(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert a list to a SmallBasic array.{\line}Not advised for large lists.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The Small Basic array.}\par
\f0\pard\sb180\shading1000{\fs30\b Union(listName1,listName2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a sub list of combined values (duplicates single counted) between two specified lists.{\line}The text comparison is case insensitive.}\par
\f0\pard\sb75{\fs24\b listName1}\par
\f0\pard{\fs20 The name of the first list.}\par
\f0\pard\sb75{\fs24\b listName2}\par
\f0\pard{\fs20 The name of the second list.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The union list.}\par
\f0\pard\sb180\shading1000{\fs30\b Write(listName,filePath,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save a list to file.{\line}One line per list value is used.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The name of the list.}\par
\f0\pard\sb75{\fs24\b filePath}\par
\f0\pard{\fs20 The full path to save the list to.}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 Append to end of existing file "True" or create a new file "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the list or -1 on failure.}\par
\f0\pard\sb300\shading2000{\fs36\b LDLogic}\par
\f0\pard{\fs20 Logic operations.{\line}To evaluate an expression for use with these options, use LDMath.Evaluate3.{\line}Example:{\line}input = 3.1{\line}result = LDLogic.Switch(LDMath.Evaluate3(input+"<5"),"OK","New input required")}\par

\f0\pard\sb180\shading1000{\fs30\b And_(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The And operator.  The trailing underscore is to keep SB parser happy not using reserved keyword AND.{\line}And_("True","True") = "True"{\line}And_("False","False") = "False"{\line}And_("True","False") = "False"{\line}And_("False","True") = "False"}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The first value ("True" or "False").}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The second value ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b CaseSensitive \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set if string comparisons are case sensitive ("True", default) or not ("False").}\par
\f0\pard\sb180\shading1000{\fs30\b EQ(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The equality operator.{\line}Checks if value1 is equal to value2.{\line}It also works for strings, where a lexical comparison is made.}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The first value.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The second value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b GE(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The greater than or equal operator.{\line}Checks if value1 is greater than or equal to value2.{\line}It also works for strings, where a lexical comparison is made.}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The first value.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The second value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b GT(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The greater than operator.{\line}Checks if value1 is greater than value2.{\line}It also works for strings, where a lexical comparison is made.}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The first value.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The second value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b LE(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The less than or equal operator.{\line}Checks if value1 is less than or equal to value2.{\line}It also works for strings, where a lexical comparison is made.}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The first value.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The second value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b LT(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The less than operator.{\line}Checks if value1 is less than value2.{\line}It also works for strings, where a lexical comparison is made.}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The first value.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The second value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b NE(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The inequality operator.{\line}Checks if value1 is not equal to value2.{\line}It also works for strings, where a lexical comparison is made.}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The first value.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The second value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Not(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The Not operator.{\line}Not("True") = "False"{\line}Not("False") = "True"}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to operate on ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Or_(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The Or operator.  The trailing underscore is to keep SB parser happy not using reserved keyword OR.{\line}Or_("True","True") = "True"{\line}Or_("False","False") = "False"{\line}Or_("True","False") = "True"{\line}Or_("False","True") = "True"}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The first value ("True" or "False").}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The second value ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Switch(condition,value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 A sorthand conditional statement.}\par
\f0\pard\sb75{\fs24\b condition}\par
\f0\pard{\fs20 A condition or variable that evaluates to "True" or "False".}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The value to return if condition is "True".}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The value to return if condition is "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 value1 or value2.}\par
\f0\pard\sb180\shading1000{\fs30\b XOr(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The XOr (exclusive or) operator.{\line}XOr("True","True") = "False"{\line}XOr("False","False") = "False"{\line}XOr("True","False") = "True"{\line}XOr("False","True") = "True"}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 The first value ("True" or "False").}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 The second value ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb300\shading2000{\fs36\b LDMath}\par
\f0\pard{\fs20 Trig functions with degrees.{\line}Other assorted maths functions and calculations.}\par

\f0\pard\sb180\shading1000{\fs30\b ArcCos(cos) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ArcCos in degrees.}\par
\f0\pard\sb75{\fs24\b cos}\par
\f0\pard{\fs20 The Cos of the angle.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The angle in degrees.}\par
\f0\pard\sb180\shading1000{\fs30\b ArcSin(sin) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ArcSin in degrees.}\par
\f0\pard\sb75{\fs24\b sin}\par
\f0\pard{\fs20 The Sin of the angle.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The angle in degrees.}\par
\f0\pard\sb180\shading1000{\fs30\b ArcTan(tan) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ArcTan in degrees.}\par
\f0\pard\sb75{\fs24\b tan}\par
\f0\pard{\fs20 The Tan of the angle.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The angle in degrees.}\par
\f0\pard\sb180\shading1000{\fs30\b Base2Decimal(number,Base) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert a base number to a decimal integer.}\par
\f0\pard\sb75{\fs24\b number}\par
\f0\pard{\fs20 The base number to convert (non negative).}\par
\f0\pard\sb75{\fs24\b Base}\par
\f0\pard{\fs20 The base to convert from (2 binary) (8 octal) (16 hex) or other bases up to 36.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number as a decimal integer or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Convert2Cartesian(x1,y1,dist,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate the coordinates of a point 2, from point 1 and the distance and angle to point 2.}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 The X coordinate of point 1.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 The Y coordinate of point 1.}\par
\f0\pard\sb75{\fs24\b dist}\par
\f0\pard{\fs20 The distance to point 2.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle to point 2 in degrees.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2 element array with the coordinates of point 2.}\par
\f0\pard\sb180\shading1000{\fs30\b Convert2Radial(x1,y1,x2,y2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate the distance and angle between two points.}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 The X coordinate of point 1.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 The Y coordinate of point 1.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 The X coordinate of point 2.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 The Y coordinate of point 2.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2 element array with the distance and the angle in degrees from point 1 to point 2.}\par
\f0\pard\sb180\shading1000{\fs30\b Cos(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Cos of an angle in degrees.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle in degrees.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The Cos of the angle.}\par
\f0\pard\sb180\shading1000{\fs30\b Cosh(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hyperbolic cosine.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Angle in radians.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Hyperbolic cosine.}\par
\f0\pard\sb180\shading1000{\fs30\b Decimal2Base(number,Base) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert a decimal integer to another base.}\par
\f0\pard\sb75{\fs24\b number}\par
\f0\pard{\fs20 The decimal integer to convert (non negative).}\par
\f0\pard\sb75{\fs24\b Base}\par
\f0\pard{\fs20 The base to convert to (2 binary) (8 octal) (16 hex) or other bases to 36.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number in the requested base or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b E \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Natural logarithm base.}\par
\f0\pard\sb180\shading1000{\fs30\b Evaluate(expression) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Evaluate a string expression to a number or boolean (if possible).{\line}The JScript command 'eval' is used and may therefore allow more complex JScript manipulations (also see LDInline).{\line}The TextWindow should be visible prior to using this method if later use of the TextWindow is required.}\par
\f0\pard\sb75{\fs24\b expression}\par
\f0\pard{\fs20 The expression to evaluate, e.g. "(9/6) + 3" or "2.1 > 1.5".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The evaluated result.}\par
\f0\pard\sb180\shading1000{\fs30\b Evaluate2(expression) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Evaluate a string expression to a number (if possible).{\line}An alternative to Evaluate that behaves nicely with the TextWindow.}\par
\f0\pard\sb75{\fs24\b expression}\par
\f0\pard{\fs20 The expression to evaluate, e.g. "1e6 + 6/4".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The evaluated result.}\par
\f0\pard\sb180\shading1000{\fs30\b Evaluate3(expression) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Evaluate a string expression to a boolean "True" or "False" (if possible).{\line}An alternative to Evaluate that behaves nicely with the TextWindow.}\par
\f0\pard\sb75{\fs24\b expression}\par
\f0\pard{\fs20 The expression to evaluate to a boolean, e.g. "21.3 > 16".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The evaluated result ("True" or "False").}\par
\f0\pard\sb180\shading1000{\fs30\b Exp(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Exponential of a number e^x.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to raise e to the power of.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 e^x}\par
\f0\pard\sb180\shading1000{\fs30\b FixDecimal(number,digits) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Round a number to a fixed number of decimal places.  Additional training decimal 0s are added if required.}\par
\f0\pard\sb75{\fs24\b number}\par
\f0\pard{\fs20 The number to change.}\par
\f0\pard\sb75{\fs24\b digits}\par
\f0\pard{\fs20 The number of decimal places.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The modified number.}\par
\f0\pard\sb180\shading1000{\fs30\b FixSigFig(number,digits) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Round a number to a fixed number of significant figures.}\par
\f0\pard\sb75{\fs24\b number}\par
\f0\pard{\fs20 The number to change.}\par
\f0\pard\sb75{\fs24\b digits}\par
\f0\pard{\fs20 The number of significant figures.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The modified number.}\par
\f0\pard\sb180\shading1000{\fs30\b MaxNumber \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The maximum number that Small Basic can handle.}\par
\f0\pard\sb180\shading1000{\fs30\b MinNumber \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The minimum number that Small Basic can handle.}\par
\f0\pard\sb180\shading1000{\fs30\b RandomNumberSeed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the seed for random numbers.  The seed should be an integer number and be set before Math.GetRandomNumber is called.{\line}The random number sequence will be initialised by the seed and can be used for testing when a repeatable sequence of random numbers is required.}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(x1,y1,x2,y2,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotate point 2 clockwise about point 1.}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 The X coordinate of point 1.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 The Y coordinate of point 1.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 The X coordinate of point 2.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 The Y coordinate of point 2.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle to rotate point 2 around point 1 in degrees.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2 element array with the coordinates of the rotated point 2.}\par
\f0\pard\sb180\shading1000{\fs30\b Sin(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sin of an angle in degrees.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle in degrees.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The Sin of the angle.}\par
\f0\pard\sb180\shading1000{\fs30\b Sinh(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hyperbolic sine.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Angle in radians.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Hyperbolic sine.}\par
\f0\pard\sb180\shading1000{\fs30\b Tan(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Tan of an angle in degrees.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle in degrees.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The Tan of the angle.}\par
\f0\pard\sb180\shading1000{\fs30\b Tanh(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hyperbolic tangent.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Angle in radians.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Hyperbolic tangent.}\par
\f0\pard\sb180\shading1000{\fs30\b Truncate(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the integral part of a number.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The number to truncate.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The integral part of the number (removing decimal fraction).}\par
\f0\pard\sb300\shading2000{\fs36\b LDMathX}\par
\f0\pard{\fs20 Extended maths methods.}\par

\f0\pard\sb180\shading1000{\fs30\b FFTComplex(real,imaginary) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an array of complex values from arrays of real and imaginary parts.}\par
\f0\pard\sb75{\fs24\b real}\par
\f0\pard{\fs20 An array of real data.}\par
\f0\pard\sb75{\fs24\b imaginary}\par
\f0\pard{\fs20 An array of imaginary data.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of complex data (real amplitude and imaginary phase), "MISMATCH" or "FAILED".{\line}For each complex pair the index is the real part and the value is the imaginary part.}\par
\f0\pard\sb180\shading1000{\fs30\b FFTForward(real) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Compute a FFT (Fast Fourier Transform).}\par
\f0\pard\sb75{\fs24\b real}\par
\f0\pard{\fs20 An array of real values to calculate the FFT from.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of complex data (real amplitude and imaginary phase) or "FAILED".{\line}For each complex pair the index is the real part and the value is the imaginary part.}\par
\f0\pard\sb180\shading1000{\fs30\b FFTImaginary(complex) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the imaginary part of an array of complex data.}\par
\f0\pard\sb75{\fs24\b complex}\par
\f0\pard{\fs20 An array of complex data (real amplitude and imaginary phase).{\line}For each complex pair the index is the real part and the value is the imaginary part.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of the imaginary part of the data or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b FFTInverse(complex) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The inverse of a FFT (Fast Fourier Transform).}\par
\f0\pard\sb75{\fs24\b complex}\par
\f0\pard{\fs20 An array of complex data (real amplitude and imaginary phase).{\line}For each complex pair the index is the real part and the value is the imaginary part.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of inverse FFT values or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b FFTReal(complex) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the real part of an array of complex data.}\par
\f0\pard\sb75{\fs24\b complex}\par
\f0\pard{\fs20 An array of complex data (real amplitude and imaginary phase).{\line}For each complex pair the index is the real part and the value is the imaginary part.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of the real part of the data or "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDMatrix}\par
\f0\pard{\fs20 A 2-Dimensional matrix structure that can be used to solve linear equations or other methods.{\line}An error will result in a return value "FAILED";}\par

\f0\pard\sb180\shading1000{\fs30\b Add(matrix1,matrix2,result) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add two matrices, the number of rows and columns of the 3 matrices given must be the same.{\line}Alternatively, if the second matrix is a scalar number then it is added to each element of the first matrix.}\par
\f0\pard\sb75{\fs24\b matrix1}\par
\f0\pard{\fs20 The first matrix.}\par
\f0\pard\sb75{\fs24\b matrix2}\par
\f0\pard{\fs20 The second matrix (or scalar value).}\par
\f0\pard\sb75{\fs24\b result}\par
\f0\pard{\fs20 The result matrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b Copy(matrix1,matrix2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy one matrix to an existing matrix.{\line}The dimensions of the 2 matrices must be the same.}\par
\f0\pard\sb75{\fs24\b matrix1}\par
\f0\pard{\fs20 The matrix to copy from.}\par
\f0\pard\sb75{\fs24\b matrix2}\par
\f0\pard{\fs20 The matrix to copy to.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b CopyNew(matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy one matrix to a new matrix.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 The matrix to copy.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A copy of the matrix or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CopyToSBArray(matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Copy LDMatrix type to SmallBasic array type.{\line}{\line}The reverse operation (SmallBasic to LDMatrix) isn't possible becuase the SmallBasic indexes are not necessarily contiguous integers.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 The matrix name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The SmallBasic array or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Create(rows,cols) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a matrix object.{\line}Row and column matrices can be defined with rows = 1 or cols = 1 respectively.}\par
\f0\pard\sb75{\fs24\b rows}\par
\f0\pard{\fs20 The number of rows.}\par
\f0\pard\sb75{\fs24\b cols}\par
\f0\pard{\fs20 The number of columns.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The matrix or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Delete(matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delete an existing matrix (not generally required, but can save memory if lots of matrices are created).}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 The matrix name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b GetValue(matrix,row,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get value in matrix.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 The matrix name.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row at which to get the value (indexed starting from 1).}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column at which to get the value (indexed starting from 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The value or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Inverse(matrix,inverse) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate the inverse of a matrix (using Gaussian Elimination).{\line}The number of rows and columns of the matrix and inverse must be the same (square matrices).{\line}A singular matrix returns "SINGULAR" and the inverse matrix will be incorrect.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 The matrix to invert (unmodified by inversion).}\par
\f0\pard\sb75{\fs24\b inverse}\par
\f0\pard{\fs20 The inverse matrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "SINGULAR" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b Multiply(matrix1,matrix2,result) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Multiply two matrices, the number of columns of the first and rows of the second matrix must be the same.{\line}The number of rows and columns of the result matrix must be the rows of the first and columns of the second.{\line}Alternatively, if the second matrix is a scalar number then it is multiplied by each element of the first matrix and the dimensions of the first and result must be the same.}\par
\f0\pard\sb75{\fs24\b matrix1}\par
\f0\pard{\fs20 The first matrix.}\par
\f0\pard\sb75{\fs24\b matrix2}\par
\f0\pard{\fs20 The second matrix (or scalar value).}\par
\f0\pard\sb75{\fs24\b result}\par
\f0\pard{\fs20 The result matrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b SetValue(matrix,row,col,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set value in matrix.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 The matrix name.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 The row at which to add the value (indexed starting from 1).}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 The column at which to add the value (indexed starting from 1).}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b Transpose(matrix,transpose) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate the transpose of a matrix.{\line}The number of rows and columns of the matrix and transpose must be reversed (cols = rows and vice versa).}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 The matrix to transpose.}\par
\f0\pard\sb75{\fs24\b transpose}\par
\f0\pard{\fs20 The resulting transposed matrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "FAILED" or "" for success.}\par
\f0\pard\sb180\shading1000{\fs30\b View(matrix,modal) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 View a matrix for dubugging purposes.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 The matrix to display.}\par
\f0\pard\sb75{\fs24\b modal}\par
\f0\pard{\fs20 The matrix display will pause all other actions until it is closed. ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb300\shading2000{\fs36\b LDMusic}\par
\f0\pard{\fs20 Extends the Sound.PlayMusic method to include a variety of instrument sounds.{\line}Also, multi-channel music can be created.{\line}Due to the large number of instrument names, it is easy to miss the following properties:{\line}Instrument, Velocity, Volume, Pan and Channel.}\par

\f0\pard\sb180\shading1000{\fs30\b Channel \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the MIDI channel (1 to 16, default 1).{\line}Used by PlayMusic, Instrument, Velocity, Volume and Pan.}\par
\f0\pard\sb180\shading1000{\fs30\b EndNote(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stop a note being played.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The note to stop (this is the value returned by PlayNote when the note was started).}\par
\f0\pard\sb180\shading1000{\fs30\b Instrument \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the musical instrument (1 to 128).{\line}1	Acoustic_Grand_Piano{\line}2	Bright_Acoustic_Piano{\line}3	Electric_Grand_Piano{\line}4	Honky_tonk_Piano{\line}5	Electric_Piano_1{\line}6	Electric_Piano_2{\line}7	Harpsichord{\line}8	Clavi{\line}9	Celesta{\line}10	Glockenspiel{\line}11	Music_Box{\line}12	Vibraphone{\line}13	Marimba{\line}14	Xylophone{\line}15	Tubular_Bells{\line}16	Dulcimer{\line}17	Drawbar_Organ{\line}18	Percussive_Organ{\line}19	Rock_Organ{\line}20	Church_Organ{\line}21	Reed_Organ{\line}22	Accordion{\line}23	Harmonica{\line}24	Tango_Accordion{\line}25	Acoustic_Guitar_nylon{\line}26	Acoustic_Guitar_steel{\line}27	Electric_Guitar_jazz{\line}28	Electric_Guitar_clean{\line}29	Electric_Guitar_muted{\line}30	Overdriven_Guitar{\line}31	Distortion_Guitar{\line}32	Guitar_harmonics{\line}33	Acoustic_Bass{\line}34	Electric_Bass_finger{\line}35	Electric_Bass_pick{\line}36	Fretless_Bass{\line}37	Slap_Bass_1{\line}38	Slap_Bass_2{\line}39	Synth_Bass_1{\line}40	Synth_Bass_2{\line}41	Violin{\line}42	Viola{\line}43	Cello{\line}44	Contrabass{\line}45	Tremolo_Strings{\line}46	Pizzicato_Strings{\line}47	Orchestral_Harp{\line}48	Timpani{\line}49	String_Ensemble_1{\line}50	String_Ensemble_2{\line}51	SynthStrings_1{\line}52	SynthStrings_2{\line}53	Choir_Aahs{\line}54	Voice_Oohs{\line}55	Synth_Voice{\line}56	Orchestra_Hit{\line}57	Trumpet{\line}58	Trombone{\line}59	Tuba{\line}60	Muted_Trumpet{\line}61	French_Horn{\line}62	Brass_Section{\line}63	SynthBrass_1{\line}64	SynthBrass_2{\line}65	Soprano_Sax{\line}66	Alto_Sax{\line}67	Tenor_Sax{\line}68	Baritone_Sax{\line}69	Oboe{\line}70	English_Horn{\line}71	Bassoon{\line}72	Clarinet{\line}73	Piccolo{\line}74	Flute{\line}75	Recorder{\line}76	Pan_Flute{\line}77	Blown_Bottle{\line}78	Shakuhachi{\line}79	Whistle{\line}80	Ocarina{\line}81	Lead_1_square{\line}82	Lead_2_sawtooth{\line}83	Lead_3_calliope{\line}84	Lead_4_chiff{\line}85	Lead_5_charang{\line}86	Lead_6_voice{\line}87	Lead_7_fifths{\line}88	Lead_8_bass_lead{\line}89	Pad_1_new_age{\line}90	Pad_2_warm{\line}91	Pad_3_polysynth{\line}92	Pad_4_choir{\line}93	Pad_5_bowed{\line}94	Pad_6_metallic{\line}95	Pad_7_halo{\line}96	Pad_8_sweep{\line}97	FX_1_rain{\line}98	FX_2_soundtrack{\line}99	FX_3_crystal{\line}100	FX_4_atmosphere{\line}101	FX_5_brightness{\line}102	FX_6_goblins{\line}103	FX_7_echoes{\line}104	FX_8_sci_fi{\line}105	Sitar{\line}106	Banjo{\line}107	Shamisen{\line}108	Koto{\line}109	Kalimba{\line}110	Bag_pipe{\line}111	Fiddle{\line}112	Shanai{\line}113	Tinkle_Bell{\line}114	Agogo{\line}115	Steel_Drums{\line}116	Woodblock{\line}117	Taiko_Drum{\line}118	Melodic_Tom{\line}119	Synth_Drum{\line}120	Reverse_Cymbal{\line}121	Guitar_Fret_Noise{\line}122	Breath_Noise{\line}123	Seashore{\line}124	Bird_Tweet{\line}125	Telephone_Ring{\line}126	Helicopter{\line}127	Applause{\line}128	Gunshot}\par
\f0\pard\sb180\shading1000{\fs30\b InstrumentName(instrument) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an instrument name from its number.}\par
\f0\pard\sb75{\fs24\b instrument}\par
\f0\pard{\fs20 The instrument number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b Pan \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the key pan balance left (-100) or right (100) (default 0).}\par
\f0\pard\sb180\shading1000{\fs30\b PlayMusic(notes) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Plays musical notes.}\par
\f0\pard\sb75{\fs24\b notes}\par
\f0\pard{\fs20 A set of musical notes to play.  The format is a subset of the Music Markup Language supported by QBasic.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 }\par
\f0\pard\sb75{\fs24\b code}\par
\f0\pard{\fs20 LDMusic.Instrument = LDMusic.Xylophone{\line}LDMusic.PlayMusic("O5 C8 C8 G8 G8 A8 A8 G4 F8 F8 E8 E8 D8 D8 C2")}\par
\f0\pard\sb180\shading1000{\fs30\b PlayMusic2(notes,instrument,velocity,volume,pan,channel) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Plays musical notes with specified instrument and MDI channel.{\line}Also set volume, pan (balance) and velocity (key hit speed).}\par
\f0\pard\sb75{\fs24\b notes}\par
\f0\pard{\fs20 A set of musical notes to play.  The format is a subset of the Music Markup Language supported by QBasic.}\par
\f0\pard\sb75{\fs24\b instrument}\par
\f0\pard{\fs20  The instrument number.}\par
\f0\pard\sb75{\fs24\b velocity}\par
\f0\pard{\fs20  The key velocity (1 to 128, default 100).}\par
\f0\pard\sb75{\fs24\b volume}\par
\f0\pard{\fs20  Volume (0 to 100, default 50).}\par
\f0\pard\sb75{\fs24\b pan}\par
\f0\pard{\fs20  Pan left (-100) or right (100) (default 0).}\par
\f0\pard\sb75{\fs24\b channel}\par
\f0\pard{\fs20 The MIDI channel (1 to 16).}\par
\f0\pard\sb180\shading1000{\fs30\b PlayNote(octave,note,channel) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play an individual note (allows multi-channel instruments).}\par
\f0\pard\sb75{\fs24\b octave}\par
\f0\pard{\fs20 The octave (0 to 8).}\par
\f0\pard\sb75{\fs24\b note}\par
\f0\pard{\fs20 The note ("A","F#","B-" etc).}\par
\f0\pard\sb75{\fs24\b channel}\par
\f0\pard{\fs20 The MIDI channel (1 to 16).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The note value being played.}\par
\f0\pard\sb180\shading1000{\fs30\b Reset() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset (stop all music on all channels).}\par
\f0\pard\sb180\shading1000{\fs30\b Velocity \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the key velocity (1 to 128).{\line}This is how hard a key was pressed (default 100).}\par
\f0\pard\sb180\shading1000{\fs30\b Volume \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the key volume (0 to 100, default 50).}\par
\f0\pard\sb300\shading2000{\fs36\b LDNetwork}\par
\f0\pard{\fs20 Network or web methods.}\par

\f0\pard\sb180\shading1000{\fs30\b DownloadFile(localFile,remoteFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Similar To Network.DownloadFile, except the download file is input and handles larger files better.}\par
\f0\pard\sb75{\fs24\b localFile}\par
\f0\pard{\fs20 The local file name to save the downloaded file.}\par
\f0\pard\sb75{\fs24\b remoteFile}\par
\f0\pard{\fs20 The remote network file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The size of the file in bytes or -1 for failue.}\par
\f0\pard\sb180\shading1000{\fs30\b GetGameData(game) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Download some data (previously saved) for a game.}\par
\f0\pard\sb75{\fs24\b game}\par
\f0\pard{\fs20 The game name (a unique case sensitive name for each game or version is required).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The stored data on success.}\par
\f0\pard\sb180\shading1000{\fs30\b HighScore(game,user,score) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Upload a potential high score to the web.{\line}All values are case sensitive and the score should be an integer number.}\par
\f0\pard\sb75{\fs24\b game}\par
\f0\pard{\fs20 The game name (a unique name for each game or version is required).}\par
\f0\pard\sb75{\fs24\b user}\par
\f0\pard{\fs20 The user name.}\par
\f0\pard\sb75{\fs24\b score}\par
\f0\pard{\fs20 The score.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array with the current high score user name and their score.}\par
\f0\pard\sb180\shading1000{\fs30\b LAN(timeout) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of the devices and their addresses connected to your local area network (LAN, home network, 192.168.1.xx).}\par
\f0\pard\sb75{\fs24\b timeout}\par
\f0\pard{\fs20 A timeout in ms, e.g. 1000.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of IP address and device names with ping time, indexed by IP address.}\par
\f0\pard\sb180\shading1000{\fs30\b Ping(IP,timeout) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ping an IP address and return the roundtrip time.}\par
\f0\pard\sb75{\fs24\b IP}\par
\f0\pard{\fs20 The IP address (or url) to ping.}\par
\f0\pard\sb75{\fs24\b timeout}\par
\f0\pard{\fs20 A timeout in ms, e.g. 1000.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The roundtrip time on success (ms) or -1 on failure}\par
\f0\pard\sb180\shading1000{\fs30\b SetGameData(game,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Upload some data for a game.}\par
\f0\pard\sb75{\fs24\b game}\par
\f0\pard{\fs20 The game name (a unique case sensitive name for each game or version is required).}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 The data to store, may be an array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The stored data on success.}\par
\f0\pard\sb300\shading2000{\fs36\b LDPhysics}\par
\f0\pard{\fs20 Physics extension using Box2D engine.}\par

\f0\pard\sb180\shading1000{\fs30\b AddChain(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a chain between two existing shapes.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 First shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Second shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The chain name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddExplosion(posX,posY,power,damping,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Make an explosion, which consists of 50x20kg particles blast apart over 500ms.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 The X coordinate of the explosion.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 The Y coordinate of the explosion.}\par
\f0\pard\sb75{\fs24\b power}\par
\f0\pard{\fs20 The explosion force, this is the initial velocity of the blast particles.}\par
\f0\pard\sb75{\fs24\b damping}\par
\f0\pard{\fs20 A damping for the blast, the smaller this value the larger the blast range (default 10).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 An optional colour of the explosion particles ("" for none).}\par
\f0\pard\sb180\shading1000{\fs30\b AddFixedAnchor(posX,posY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a new small, transparent shape to be used as a fixed anchor point.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 The X coordinate of the anchor.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 The Y coordinate of the anchor.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The anchor shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddFixedShape(shapeName,friction,restitution) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an existing SmallBasic shape to the physics engine as a fixed (non-dynamic) shape with friction and restitution that affects shapes that hit it.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The name of the shape.}\par
\f0\pard\sb75{\fs24\b friction}\par
\f0\pard{\fs20 The shape friction (usually 0 to 1).}\par
\f0\pard\sb75{\fs24\b restitution}\par
\f0\pard{\fs20 The shape restitution or bounciness (usually 0 to 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b AddInactiveShape(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an existing SmallBasic shape to the physics engine as an inactive (non-dynamic and non-interacting) shape which only moves with the PanView method.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The name of the shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b AddMovingAnchor(posX,posY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a new small, transparent and high density shape to be used as a moving anchor point.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 The X coordinate of the anchor.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 The Y coordinate of the anchor.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The anchor shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddMovingShape(shapeName,friction,restitution,density) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add an existing SmallBasic shape to the physics engine as a moving (dynamic) shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The name of the shape.}\par
\f0\pard\sb75{\fs24\b friction}\par
\f0\pard{\fs20 The shape friction (usually 0 to 1).}\par
\f0\pard\sb75{\fs24\b restitution}\par
\f0\pard{\fs20 The shape restitution or bounciness (usually 0 to 1).{\line}If a negative value is set for restitution, then the shape will be added with a very small size which may be used to add an inactive image that can be grouped within an irregular compound shape that matches the image boundary.}\par
\f0\pard\sb75{\fs24\b density}\par
\f0\pard{\fs20 The shape density (default 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRope(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a rope between two existing shapes.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 First shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Second shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The rope name.}\par
\f0\pard\sb180\shading1000{\fs30\b AttachShapes(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Connect two shapes to move together as one.  The shapes are connected with a distance joint and may wobble a bit if they are hit.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 The first shape name.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 The second shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b AttachShapesWithJoint(shape1,shape2,type,collide,parameters) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20  Connect two shapes to move together as one with one of several joint types.{\line} These can be advanced and require reference to Box2D manual.{\line} In many cases it is best to prevent shape rotation for the joints to behave as desired.{\line} Multiple joints may also be applied to shapes.{\line} The methods use the initial shape positions, so set these first.{\line} }\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 The first shape name.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 The second shape name.}\par
\f0\pard\sb75{\fs24\b type}\par
\f0\pard{\fs20 One of the following joint types.{\line} {\line} "Distance" - maintain a fixed distance between the shapes.{\line} "Gear" - link Prismatic or Revolute joints (previously created) of 2 shapes.{\line} "Line" - move the shapes along a line initially connecting the shapes.{\line} "Mouse" - move the shape to follow the mouse (both shape names should be the same).{\line} "Prismatic_H" - move shapes vertically along a line between the two shapes.{\line} "Prismatic_V" - move shapes horizontally along a line between the two shapes.{\line} "Pulley" - a pulley system, one shape moves up as the other moves down - position the shapes initially at the extreme points of the pulley motion.{\line} "Revolute" - the shapes can rotate about each other.{\line} }\par
\f0\pard\sb75{\fs24\b collide}\par
\f0\pard{\fs20 The connected shapes can interact with each other "True" or "False" (default).{\line} }\par
\f0\pard\sb75{\fs24\b parameters}\par
\f0\pard{\fs20 Optional parameters (default ""), multiple parameters are in an array.{\line}{\line} "Distance" - damping ratio (default 0){\line} "Gear" - gear ratio, first joint, second joint (default 1, auto detect joints){\line} "Line" - X direction, Y direction, lower translation, upper translation (default line connecting shapes, no limits){\line} "Mouse" - max acceleration, damping ratio (default 10000, 0.7){\line} "Prismatic_H" - X direction, Y direction, lower translation, upper translation (default 1,0, no limits){\line} "Prismatic_V" - X direction, Y direction, lower translation, upper translation  (default 0,1, no limits){\line} "Pulley" - pulley ratio (block and tackle) (default 1){\line} "Revolute" - lower angle, upper angle (default no limits){\line} }\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20  The joint name.{\line} }\par
\f0\pard\sb180\shading1000{\fs30\b AttachShapesWithRotation(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Connect two shapes to move together as one, but allow the shapes to rotate about each other.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 The first shape name.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 The second shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b BoxShape(shapeName,x1,y1,x2,y2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a shape to remain within a box within the view.{\line}This is similar to PanView, except that the view pans automatically to keep the specified shape within a box region of the GraphicsWindow.{\line}Only one shape can be boxed.  To unset shape box, set the shapeName to "".}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to box or "".}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 The left x coordinate of the box.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 The top y coordinate of the box.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 The right x coordinate of the box.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 The bottom y coordinate of the box.}\par
\f0\pard\sb180\shading1000{\fs30\b BrakeTire(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply a brake to a tire shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The tire shape to brake.}\par
\f0\pard\sb180\shading1000{\fs30\b ChainColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The colour to be used for chains.}\par
\f0\pard\sb180\shading1000{\fs30\b DetachJoint(jointName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Disconnect two shapes that were previously joined with a joint.}\par
\f0\pard\sb75{\fs24\b jointName}\par
\f0\pard{\fs20 The joint name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b DetachShapes(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Disconnect two shapes that were previously attached.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 The first shape name.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 The second shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b DisconnectShape(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Disconnect shape from the physics engine without deleting the shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b DoTimestep() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Perform a time-step update.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b FollowShapeX(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a shape to remain stationary at X position in the view.{\line}This is similar to PanView, except that the view pans automatically to keep the specified shape at a constant visual X location.{\line}Only one shape can be followed in X direction.  To unset shape following, set the shapeName to "".}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to follow or "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b FollowShapeY(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a shape to remain stationary at Y position in the view.{\line}This is similar to PanView, except that the view pans automatically to keep the specified shape at a constant visual Y location.{\line}Only one shape can be followed in Y direction.  To unset shape following, set the shapeName to "".}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to follow or "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllShapesAt(posX,posY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of all the physics engine shapes (if any) at the input coordinates.{\line}The coordinates for this method are the physics engine coordinates if panning is present.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 The X coordinate.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 The Y coordinate.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of shape names or "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAngle(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the angle of rotation for the shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The angle of rotation in degrees.}\par
\f0\pard\sb180\shading1000{\fs30\b GetCollisions(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of all the shapes that the specified shape collided with during the last DoTimestep().}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to check for collisions.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of all the shapes collided with (may be empty "" or "Wall" for a static obstacle).}\par
\f0\pard\sb180\shading1000{\fs30\b GetContacts(posX,posY,distance) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of shapes that collided within a distance of a specified contact point.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 The X coordinate of a contact position to check.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 The Y coordinate of a contact position to check.}\par
\f0\pard\sb75{\fs24\b distance}\par
\f0\pard{\fs20 A maximum distance from the contact point for the contact.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of contacts, with each contact being an array of 2 shape names.}\par
\f0\pard\sb180\shading1000{\fs30\b GetInertia(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the moment of inertia of a shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The inertia of the shape.}\par
\f0\pard\sb180\shading1000{\fs30\b GetMass(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the mass of a shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The mass of the shape.}\par
\f0\pard\sb180\shading1000{\fs30\b GetPan() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the current pan offset, see PanView, FollowShapeX(Y) and BoxShape.{\line}World coordinates = screen coordinates + pan offset.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2 element array with the current pan offset.}\par
\f0\pard\sb180\shading1000{\fs30\b GetPosition(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the centre of the shape coordinates.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2 element array with the shape centre position.}\par
\f0\pard\sb180\shading1000{\fs30\b GetRotation(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the shape rotation speed.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The angular rotation speed degrees/s.}\par
\f0\pard\sb180\shading1000{\fs30\b GetShapeAt(posX,posY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the shape (if any) at the input coordinates.{\line}The coordinates for this method are the screen coordinates if panning is present.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 The X coordinate.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 The Y coordinate.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The shape name at the input position or "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetTireInformation(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get tire information, it includes:{\line}{\line}Skid (if this value exceeds the property AntiSkid, then the tire is skidding){\line}Crash (the value is the speed of the impact)}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The tire shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of information, indexed by the information name, e.g. "Skid".}\par
\f0\pard\sb180\shading1000{\fs30\b GetTireProperties(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get tire properties, they include:{\line}{\line}AntiSkid (higher value reduces skid){\line}Drag (higher value increases forward/backward drag){\line}Brake (higher value increases braking power){\line}Straighten (higher value restores steering more quickly){\line}BrakeStraighten (higher value restores steering more quickly while braking)}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The tire shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of properties, indexed by the property name, e.g. "AntiSkid".}\par
\f0\pard\sb180\shading1000{\fs30\b GetVelocity(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the velocity of the shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 2 element array with the shape velocity.}\par
\f0\pard\sb180\shading1000{\fs30\b GroupShapes(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Solidly group two shapes to move together as one.  Shape1 is added to shape2 to act as one shape.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 The first shape name.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 The second shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Help() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 This function is just to display this help.{\line}{\line}The extension uses Box2D (http://box2d.org) as an engine and provides an interface between it and the graphics capabilities of SmallBasic.{\line}{\line}Only shapes that are connected to the physics engine take part in the motion physics, for example you may add normal shapes (e.g. a gun and not connect it to the physics engine).  Once a shape is connected to the engine, it is best to only interact with it through the methods provided by the extension.  All positions are in the SmallBasic GraphicsWindow pixels and refer to shape centres.{\line}{\line}Image and text shapes are treated as rectangles, and ellipses as circles; there is also triangle and convex polygon support, but not lines.  Images may be treated as circles by setting the property LoadImagesAsCircles to "True".{\line}{\line}One issue that Box2D has difficulty with is small fast moving objects that can 'tunnel' through other shapes without being deflected (see the SetBullet option).{\line}{\line}Another problem is shapes of very different size and hence mass, especially large shapes when they are connected together.  It may be necessary to modify the density for these (the Anchor options are an attempt to automate this a bit), otherwise the default density of 1 is good.  Resist the temptation to connect too many shapes together.{\line}{\line}It may be possible to improve the stability of some 'difficult' models using the TimestepControl settings, but the defaults look good for most cases.{\line}{\line}Do not call the physics methods inside SmallBasic event subroutines directly, rather set flags that can be processed in a main game loop.{\line}{\line}There are sample SmallBasic programs and a Getting Started Guide that comes with the extension dll - this is the best place to start.{\line}{\line}Report bugs and problems to the SmallBasic forum (http://social.msdn.microsoft.com/Forums/en-US/smallbasic/threads), but first simplify your SmallBasic code to isolate the issue before providing a short 'runnable' code sample.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b LoadImagesAsCircles \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Toggle whether image shapes will be loaded as circles - "True" or "False" (default is "False").}\par
\f0\pard\sb180\shading1000{\fs30\b MaxPolygonVertices \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The physics engine maximum number of vertices on convex polygons (default 8).}\par
\f0\pard\sb180\shading1000{\fs30\b MaxProxies \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The physics engine maximum number of objects 'proxies' (default 1024).}\par
\f0\pard\sb180\shading1000{\fs30\b MoveTire(shapeName,force) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move a tire shape, apply a forward or backward force.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The tire shape to move.}\par
\f0\pard\sb75{\fs24\b force}\par
\f0\pard{\fs20 The force to apply, positive is forward, negative is backward.}\par
\f0\pard\sb180\shading1000{\fs30\b PanView(panHorizontal,panVertical) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pan the camera view, including window boundaries.}\par
\f0\pard\sb75{\fs24\b panHorizontal}\par
\f0\pard{\fs20 Pan in the horizontal direction (negative is left).}\par
\f0\pard\sb75{\fs24\b panVertical}\par
\f0\pard{\fs20 Pan in the vertical direction (negative is up).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b PositionIterations \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The physics engine position iterations (default 2).}\par
\f0\pard\sb180\shading1000{\fs30\b RayCast(shapeName,angle,distance) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Cast an invisible ray to detect the proximity of shapes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to cast the ray from.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle in degrees to check, this can also be an array of angles.}\par
\f0\pard\sb75{\fs24\b distance}\par
\f0\pard{\fs20 A maximum distance to check.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of results, indexed by the shape name ("Wall" for a static obstacle) with a value equal to its distance.{\line}The shapes are sorted to list them nearest first.{\line}If an array of input angles is used, then only the nearest shape for each angle is returned and the value is the angle, not the distance.}\par
\f0\pard\sb180\shading1000{\fs30\b ReadJson(fileName,scale,reverseY,stationary,offsetX,offsetY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read in a json script compatible with R.U.B.E. and create a LDPhysics model.{\line}See https://www.iforce2d.net/rube for more details.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to the json file to read.}\par
\f0\pard\sb75{\fs24\b scale}\par
\f0\pard{\fs20 Scale all shapes, default 1 (no scaling).}\par
\f0\pard\sb75{\fs24\b reverseY}\par
\f0\pard{\fs20 Reverse the Y direction up to down ("True" or "False").}\par
\f0\pard\sb75{\fs24\b stationary}\par
\f0\pard{\fs20 Set all shapes to be initially at rest, joint motors are still enabled ("True" or "False").}\par
\f0\pard\sb75{\fs24\b offsetX}\par
\f0\pard{\fs20 Add an x coordinate offset to all shapes.}\par
\f0\pard\sb75{\fs24\b offsetY}\par
\f0\pard{\fs20 Add a y coordinate offset to all shapes, especially useful when reverseY is set.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A text array containing the LDPhysics commands used to create the model.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveChain(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove a chain.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The chain name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveFrozen() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Removes all frozen shapes - outside the AABB for the engine.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveRope(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove a rope.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The rope name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveShape(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove a shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The name of the shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Reset() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset (delete all physics engine attached shapes).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RopeColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The colour to be used for ropes.}\par
\f0\pard\sb180\shading1000{\fs30\b Scaling \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The physics engine scaling (pixel/m, default 10).  It is not recommended to change this.}\par
\f0\pard\sb180\shading1000{\fs30\b SetAABB(minX,maxX,minY,maxY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The physics engine AABB (axis-aligned bounding box). The units are the engine units of m.  A Reset is required after setting.  It is not recommended to change this.}\par
\f0\pard\sb75{\fs24\b minX}\par
\f0\pard{\fs20 The left coordinate of the universe (default -100).}\par
\f0\pard\sb75{\fs24\b maxX}\par
\f0\pard{\fs20 The right coordinate of the universe (default 200).}\par
\f0\pard\sb75{\fs24\b minY}\par
\f0\pard{\fs20 The top coordinate of the universe (default -100).}\par
\f0\pard\sb75{\fs24\b maxY}\par
\f0\pard{\fs20 The bottom coordinate of the universe (default 200).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetAngle(shapeName,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset the angle of rotation for a shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle of rotation in degrees.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetBoundaries(left,right,top,bottom) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set solid boundaries (positioning a boundary outside the GraphicsWindow removes it).}\par
\f0\pard\sb75{\fs24\b left}\par
\f0\pard{\fs20 The left boundary X value.}\par
\f0\pard\sb75{\fs24\b right}\par
\f0\pard{\fs20 The right boundary X value.}\par
\f0\pard\sb75{\fs24\b top}\par
\f0\pard{\fs20 The top boundary Y value.}\par
\f0\pard\sb75{\fs24\b bottom}\par
\f0\pard{\fs20 The bottom (ground) boundary Y value.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetBullet(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a shape as a bullet.  This prevents 'tunnelling' of fast moving small objects at the expense of performance.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetDamping(shapeName,linear,angular) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a damping factor for a shape (default 0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to modify.}\par
\f0\pard\sb75{\fs24\b linear}\par
\f0\pard{\fs20 Linear damping factor.}\par
\f0\pard\sb75{\fs24\b angular}\par
\f0\pard{\fs20 Angular damping factor.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetForce(shapeName,forceX,forceY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a force to apply to a shape (Remember F = ma).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to modify.}\par
\f0\pard\sb75{\fs24\b forceX}\par
\f0\pard{\fs20 X component of the force.}\par
\f0\pard\sb75{\fs24\b forceY}\par
\f0\pard{\fs20 Y component of the force.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetGravity(gravX,gravY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the gravity direction and magnitude (default 0,100).}\par
\f0\pard\sb75{\fs24\b gravX}\par
\f0\pard{\fs20 The X component of gravity.}\par
\f0\pard\sb75{\fs24\b gravY}\par
\f0\pard{\fs20 The Y component of gravity.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetGroup(shapeName,group,mask) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Control which sprites interact (collide) with other shapes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to modify.}\par
\f0\pard\sb75{\fs24\b group}\par
\f0\pard{\fs20 The group that the current shape belongs to (default 0).  This should be an integer between 0 and 15.}\par
\f0\pard\sb75{\fs24\b mask}\par
\f0\pard{\fs20 An array of groups that this shape will collide with (default all groups 0,1,2,..,14,15).{\line}To allow the shape to only interact with groups 0, 1 and 4 would be "1=0;2=1;3=4;".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetImpulse(shapeName,impulseX,impulseY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set an impulse to a shape (a kick).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to modify.}\par
\f0\pard\sb75{\fs24\b impulseX}\par
\f0\pard{\fs20 X component of the impulse.}\par
\f0\pard\sb75{\fs24\b impulseY}\par
\f0\pard{\fs20 Y component of the impulse.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetJointMotor(jointName,speed,maxForce) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a motor for selected joints (Line, Prismatic_H, Prismatic_V and Revolute).}\par
\f0\pard\sb75{\fs24\b jointName}\par
\f0\pard{\fs20 The joint name.}\par
\f0\pard\sb75{\fs24\b speed}\par
\f0\pard{\fs20 The desired motor speed.}\par
\f0\pard\sb75{\fs24\b maxForce}\par
\f0\pard{\fs20 The maximum motor force (torque for Revolute).{\line}A zero value turns motor off.}\par
\f0\pard\sb180\shading1000{\fs30\b SetPosition(shapeName,posX,posY,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset shape position.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to modify.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 X component shape centre.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 Y component shape centre.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle of rotation in degrees.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetRotation(shapeName,rotation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set shape rotation speed.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to modify.}\par
\f0\pard\sb75{\fs24\b rotation}\par
\f0\pard{\fs20 The angular rotation speed degrees/s.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetShapeGravity(shapeName,gravX,gravY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the gravity direction and magnitude for an individual shape (default 0,100).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to modify.}\par
\f0\pard\sb75{\fs24\b gravX}\par
\f0\pard{\fs20 The X component of gravity.}\par
\f0\pard\sb75{\fs24\b gravY}\par
\f0\pard{\fs20 The Y component of gravity.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetTire(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set an object to act as a drivable tire for a top down game.{\line}Usually gravity will be 0 and the shape should already be added to the engine.{\line}The object should be initially positioned facing forward up on the display.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to make a tire.}\par
\f0\pard\sb180\shading1000{\fs30\b SetTireProperties(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set tire properties, they include:{\line}{\line}AntiSkid (higher value reduces skid){\line}Drag (higher value increases forward/backward drag){\line}Brake (higher value increases braking power){\line}Straighten (higher value restores stearing more quickly){\line}BrakeStraighten (higher value restores stearing more quickly while braking)}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The tire shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 An array of one or more properties to set.{\line}The index is one of the properties (case sensitive) and the value is the property value.}\par
\f0\pard\sb180\shading1000{\fs30\b SetTorque(shapeName,torque) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a torque to a shape (a rotational kick).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to modify.}\par
\f0\pard\sb75{\fs24\b torque}\par
\f0\pard{\fs20 The torque to apply.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetVelocity(shapeName,velX,velY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the velocity of a shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape to modify.}\par
\f0\pard\sb75{\fs24\b velX}\par
\f0\pard{\fs20 X component of the velocity.}\par
\f0\pard\sb75{\fs24\b velY}\par
\f0\pard{\fs20 Y component of the velocity.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b TimeStep \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The physics engine timestep size (default 0.025).}\par
\f0\pard\sb180\shading1000{\fs30\b TimestepControl(timestep,velocityIterations,positionIterations) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Modify default timestep control parameters - also can be set using individual parameters.}\par
\f0\pard\sb75{\fs24\b timestep}\par
\f0\pard{\fs20 Time-step (default 0.025).}\par
\f0\pard\sb75{\fs24\b velocityIterations}\par
\f0\pard{\fs20 Velocity iterations (default 6).}\par
\f0\pard\sb75{\fs24\b positionIterations}\par
\f0\pard{\fs20 Position iterations (default 2).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b ToggleMoving(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Toggle a moving shape to be fixed and vice-versa.{\line}This method also sets the rotation to be on or off to match if it is moving or fixed.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b ToggleRotation(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Toggle a shape to not rotate and vice-versa.{\line}This method toggles the rotation property for fixed and moving shapes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b ToggleSensor(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Toggle a shape to act as a sensor and vice-versa.{\line}A sensor shape does not interact with other shapes, but still provides collision data.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b TurnTire(shapeName,torque) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Turn a tire shape, steer left or right.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The tire shape to turn.}\par
\f0\pard\sb75{\fs24\b torque}\par
\f0\pard{\fs20 The torque, rotation force to apply, positive is turn right, negative is turn left.}\par
\f0\pard\sb180\shading1000{\fs30\b UngroupShapes(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove shape group pairing.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 The first shape name.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 The second shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b UnsetBullet(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Unset a shape as a bullet.  This reverts the shape to normal collision detection.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b VelocityIterations \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The physics engine velocity iterations (default 6).}\par
\f0\pard\sb180\shading1000{\fs30\b VelocityThreshold \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The physics engine velocity threshold for inelastic collisions 'sticky walls' (default 1).}\par
\f0\pard\sb180\shading1000{\fs30\b WakeAll() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wake all sleeping shapes - shapes sleep due to no applied forces or contacts.  They wake automatically on any contact or applied force, so this action is rarely required.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b WriteJson(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Write out a json script compatible with R.U.B.E. from current LDPhysics model.{\line}See https://www.iforce2d.net/rube for more details.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to the json file to create.}\par
\f0\pard\sb300\shading2000{\fs36\b LDProcess}\par
\f0\pard{\fs20 Control an external application.}\par

\f0\pard\sb180\shading1000{\fs30\b GetProcesses() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of system processes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of all the system process names, indexed by the process ID.}\par
\f0\pard\sb180\shading1000{\fs30\b Start(application,arguments) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Start an external application.}\par
\f0\pard\sb75{\fs24\b application}\par
\f0\pard{\fs20 The full path of the application to start e.g. "C:\\Program Files (x86)\\Microsoft\\Small Basic\\SB.exe".}\par
\f0\pard\sb75{\fs24\b arguments}\par
\f0\pard{\fs20 Arguments to give to the command or "" if none.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Process ID of started application, -1 if failed or -2 if attached to existing process.}\par
\f0\pard\sb180\shading1000{\fs30\b Stop(ID) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stop an external process.}\par
\f0\pard\sb75{\fs24\b ID}\par
\f0\pard{\fs20 The process ID to stop.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False" for success or failure.}\par
\f0\pard\sb300\shading2000{\fs36\b LDQueue}\par
\f0\pard{\fs20 This object provides a way of storing values.{\line}It is similar to a stack, except that is is fist-in first-out, like a queue.  {\line}You can enqueue (add) a value to the end of the queue and dequeue (remove) the first value at the front of the queue.{\line}You can only enqueue and dequeue the values one by one.}\par

\f0\pard\sb180\shading1000{\fs30\b Dequeue(queueName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove (and get) the value from the front of the specified queue.}\par
\f0\pard\sb75{\fs24\b queueName}\par
\f0\pard{\fs20 The name of the queue.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The value from the queue.}\par
\f0\pard\sb180\shading1000{\fs30\b Enqueue(queueName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Adds a value to the end of the specified queue.}\par
\f0\pard\sb75{\fs24\b queueName}\par
\f0\pard{\fs20 The name of the queue.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to enqueue.}\par
\f0\pard\sb180\shading1000{\fs30\b GetCount(queueName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the count of items in the specified queue.}\par
\f0\pard\sb75{\fs24\b queueName}\par
\f0\pard{\fs20 The name of the queue.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of items in the specified queue.}\par
\f0\pard\sb300\shading2000{\fs36\b LDRegex}\par
\f0\pard{\fs20 Regex (regular expression) text manipulation utilities.}\par

\f0\pard\sb180\shading1000{\fs30\b Match(input,pattern,caseSensitive) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Perform a regex match.}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 The input string to perform the match on (unaltered).}\par
\f0\pard\sb75{\fs24\b pattern}\par
\f0\pard{\fs20 The regex pattern string.}\par
\f0\pard\sb75{\fs24\b caseSensitive}\par
\f0\pard{\fs20 If the regex match is case sensitive ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of match values, indexed by the location index in the input (position).}\par
\f0\pard\sb180\shading1000{\fs30\b Replace(input,pattern,replacement,caseSensitive) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Perform a regex find and replace.}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 The input string to perform the replacement on (unaltered).}\par
\f0\pard\sb75{\fs24\b pattern}\par
\f0\pard{\fs20 The regex pattern string.}\par
\f0\pard\sb75{\fs24\b replacement}\par
\f0\pard{\fs20 The regex replacement string.}\par
\f0\pard\sb75{\fs24\b caseSensitive}\par
\f0\pard{\fs20 If the regex replace is case sensitive ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A modified version of the input string after the regex replace.}\par
\f0\pard\sb300\shading2000{\fs36\b LDResources}\par
\f0\pard{\fs20 Save and load resources to a binary file.{\line}The resources are stored in a single file with the same name and location as the source, with extension sbres.{\line}Resources indlude all ImageList images, all sounds played with Sound.Play, as well as optionally other files or variables.}\par

\f0\pard\sb180\shading1000{\fs30\b AddFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add any file to the resources to be stored.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to the file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b AddText(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add text, or may be variable (including arrays) to the resources to be stored.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text or a Small Basic variable to add to the resources.}\par
\f0\pard\sb180\shading1000{\fs30\b CleanTemp() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delete temporary sound files.}\par
\f0\pard\sb180\shading1000{\fs30\b ExtractFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Extract a saved file to the current directory (Program.Directory).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The filename returned by Files method.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Files \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of loaded files, that may be extracted with ExtractFile method.}\par
\f0\pard\sb180\shading1000{\fs30\b Images \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of loaded images, pre-loaded for use with ImageList.}\par
\f0\pard\sb180\shading1000{\fs30\b Load() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Load all previously saved resources from the sbres file.{\line}ImageList and sounds are all auto loaded ready for use.{\line}Sound files are re-created in your %temp% folder since they are required by Sound.Play.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Save() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save all resource to the sbres file.{\line}This includes all ImageList images, pre-run sounds (Sound.Play) as well as any added files or text/variables.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Sounds \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of loaded sounds, pre-loaded for use with Sound.Play.}\par
\f0\pard\sb180\shading1000{\fs30\b Texts \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array list of all loaded text/variables.}\par
\f0\pard\sb300\shading2000{\fs36\b LDScrollBars}\par
\f0\pard{\fs20 GraphicsWindow ScrollBars - can be used for a scrolling game.{\line}{\line}Warning - Do not alter the GraphicsWindow size using GraphicsWindow.Width or GraphicsWindow.Height AFTER scrollbars have been added.{\line}In this case use LDGraphicsWindow.Width and LDGraphicsWindow.Height.{\line}{\line}For large scrolling regions see Rasterize property.}\par

\f0\pard\sb180\shading1000{\fs30\b Add(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add Scroll Bars to the GraphicsWindow.{\line}The input width and height are those that can be scrolled to.{\line}A value of 0 prevents a scrollbar appearing.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the scrollable region.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the scrollable region.}\par
\f0\pard\sb180\shading1000{\fs30\b HorizontalScroll \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or Set the horizontal ScrollBar position.}\par
\f0\pard\sb180\shading1000{\fs30\b KeyScroll \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set if scrollbars will move with arrow keys "True" (default) or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Modify(action) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move scrollbars.}\par
\f0\pard\sb75{\fs24\b action}\par
\f0\pard{\fs20 Allowed actions include the following.{\line}"PageDown", "PageUp", "PageLeft" and "PageRight"{\line}"ScrollToTop", "ScrollToBottom", "ScrollToLeftEnd" and "ScrollToRightEnd"{\line}"ScrollToHome", "ScrollToEnd"}\par
\f0\pard\sb180\shading1000{\fs30\b MouseScroll \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set if scrollbars will move with mouse wheel "True" (default) or "False".{\line}Hold the shift key down to scroll horizontally with mouse wheel.}\par
\f0\pard\sb180\shading1000{\fs30\b Rasterize \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rasterize drawables "True" (default) or "False".{\line}When more than 100 objects are drawn (not Shapes) SmallBasic will rasterise these to an image for performance reasons.{\line}For a very large scrollable region this will run out of memory and can be disabled here.{\line}If it is disabled, then don't use more than 100 drawable objects.{\line}This property should be set before LDScrollBars.Add is called.}\par
\f0\pard\sb180\shading1000{\fs30\b ScrollBarChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a scroll operation occurs}\par
\f0\pard\sb180\shading1000{\fs30\b VerticalScroll \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or Set the vertical ScrollBar position.}\par
\f0\pard\sb180\shading1000{\fs30\b Visibility \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or Set the ScrollBars' visibility.{\line}"True" or "False".}\par
\f0\pard\sb300\shading2000{\fs36\b LDSearch}\par
\f0\pard{\fs20 Bing online search methods.{\line}Includes web, image, video, news and spelling suggestions.}\par

\f0\pard\sb180\shading1000{\fs30\b Count \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The maximum number of web search results, default 50.}\par
\f0\pard\sb180\shading1000{\fs30\b GetImage(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Do a Bing search for Web images.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 The search text.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of results, index url and value description.}\par
\f0\pard\sb180\shading1000{\fs30\b GetNews(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Do a Bing search for Web news.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 The search text.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of results, index url and value description.}\par
\f0\pard\sb180\shading1000{\fs30\b GetProof(text,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Do a text spell check (proof).  This is for longer text with more detailed information like in Word.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to proof.}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 A mode "Proof" (default for longer text) or "Spell" (for short or single word checks).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of spelling and other suggestions or "" if no suggestions found.}\par
\f0\pard\sb180\shading1000{\fs30\b GetSpelling(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Do a Bing search for Web spelling or alternative search suggestions.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 The search text.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of spelling or alternative suggestions or "" if no suggestions found.}\par
\f0\pard\sb180\shading1000{\fs30\b GetVideo(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Do a Bing search for Web videos.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 The search text.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of results, index url and value description.}\par
\f0\pard\sb180\shading1000{\fs30\b GetWeb(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Do a Bing search for Web sites.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 The search text.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array (up to  50) of results, index url and value description.}\par
\f0\pard\sb180\shading1000{\fs30\b Language \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The language culture to use, default is current culture.{\line}es-AR,en-AU,de-AT,nl-BE,fr-BE,pt-BR,en-CA,fr-CA,es-CL,da-DK,fi-FI,fr-FR,de-DE,zh-HK,en-IN,en-ID,en-IE,it-IT,ja-JP,ko-KR,en-MY,es-MX,nl-NL,en-NZ,no-NO,zh-CN,pl-PL,pt-PT,en-PH,ru-RU,ar-SA,en-ZA,es-ES,sv-SE,fr-CH,de-CH,zh-TW,tr-TR,en-GB,en-US,es-US}\par
\f0\pard\sb300\shading2000{\fs36\b LDServer}\par
\f0\pard{\fs20 Server and Client communication between computers.{\line}Separate programs are required for the server and client - this is for the server.}\par

\f0\pard\sb180\shading1000{\fs30\b AutoMessages \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Show TextWindow connection messages when in auto mode "True" (default) or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Broadcast(message) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Send a message to all clients.}\par
\f0\pard\sb75{\fs24\b message}\par
\f0\pard{\fs20 The message may be any variable including an array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A array of values "SUCCESS", "NOT_CONNECTED", "NO_CLIENT" or "FAILED" with the Client Name being the index.}\par
\f0\pard\sb180\shading1000{\fs30\b ClientConnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a client connects.}\par
\f0\pard\sb180\shading1000{\fs30\b ClientDisconnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a client disconnects.}\par
\f0\pard\sb180\shading1000{\fs30\b ClientMessage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a client sends a message to the server.}\par
\f0\pard\sb180\shading1000{\fs30\b Close(clientName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Disconnect and close (End) a client.}\par
\f0\pard\sb75{\fs24\b clientName}\par
\f0\pard{\fs20 The client name, usually Client1, Client2 etc.{\line}A list of current clients can be obtained from the method GetClients or found from the ClientConnected event.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOT_CONNECTED", "NO_CLIENT" or "FAILED"}\par
\f0\pard\sb180\shading1000{\fs30\b CloseDelay \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 A delay in ms (default 100) when disconnecting to allow a message to be sent before connection closed (Stop, Disconnect and Close).{\line}This delay should also be set for clients in LDClient.CloseDelay.}\par
\f0\pard\sb180\shading1000{\fs30\b Disconnect(clientName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Disconnect a client.}\par
\f0\pard\sb75{\fs24\b clientName}\par
\f0\pard{\fs20 The client name, usually Client1, Client2 etc.{\line}A list of current clients can be obtained from the method GetClients or found from the ClientConnected event.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOT_CONNECTED", "NO_CLIENT" or "FAILED"}\par
\f0\pard\sb180\shading1000{\fs30\b GetClients() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of current connected clients.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of current client names or "" for none.}\par
\f0\pard\sb180\shading1000{\fs30\b IP \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The IP address of the server (it is defaulted to the current LAN IP).{\line}If you want to use over the internet, then a web IP will be needed.}\par
\f0\pard\sb180\shading1000{\fs30\b LastClient \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last client name.}\par
\f0\pard\sb180\shading1000{\fs30\b LastClientConnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last client connected name.}\par
\f0\pard\sb180\shading1000{\fs30\b LastClientDisconnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last client disconnected name.}\par
\f0\pard\sb180\shading1000{\fs30\b LastClientMessage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last client message.}\par
\f0\pard\sb180\shading1000{\fs30\b Port \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The windows port to use (default 100).}\par
\f0\pard\sb180\shading1000{\fs30\b SendMessage(clientName,message) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Send a message to a client.}\par
\f0\pard\sb75{\fs24\b clientName}\par
\f0\pard{\fs20 The client name, usually Client1, Client2 etc.{\line}A list of current clients can be obtained from the method GetClients or found from the ClientConnected event.}\par
\f0\pard\sb75{\fs24\b message}\par
\f0\pard{\fs20 The message may be any variable including an array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOT_CONNECTED", "NO_CLIENT" or "FAILED"}\par
\f0\pard\sb180\shading1000{\fs30\b Start(auto) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Start the server.}\par
\f0\pard\sb75{\fs24\b auto}\par
\f0\pard{\fs20 Enable auto message passing "True" or "False".{\line}If this is used (recommended) then all client data is passed via server to all other clients, {\line}and no processing of send and receive events is required.{\line}The data is updated to arrays of data (indexed by client name) that is returned from the client Update methods.{\line}The auto option should be the same for server and all clients.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The current connection parameter ip:port (e.g. "192.168.1.60:100"), or "FAILED".{\line}This is the parameter to use to connect from the client.}\par
\f0\pard\sb180\shading1000{\fs30\b Stop() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stop the current server and close all clients.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED"}\par
\f0\pard\sb300\shading2000{\fs36\b LDSettings}\par
\f0\pard{\fs20 The Settings library consists of helpers that allow programs to{\line}store and retrieve user settings.}\par

\f0\pard\sb180\shading1000{\fs30\b FilePath \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets or sets the file path for the settings file.}\par
\f0\pard\sb180\shading1000{\fs30\b GetValue(name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the value for the setting identified by the specified name.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The Name of the setting.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The Value of the setting.}\par
\f0\pard\sb180\shading1000{\fs30\b SetValue(name,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sets a value for a setting identified by the specified name.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The Name of the setting.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The Value of the setting.}\par
\f0\pard\sb300\shading2000{\fs36\b LDShapes}\par
\f0\pard{\fs20 Shapes extension utilities.}\par

\f0\pard\sb180\shading1000{\fs30\b AddAnimatedGif(imageName,repeat) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Creates an animated gif shape.  {\line}Do not add a very large number of these or performance may be degraded.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The animated gif file (local or network) to load.}\par
\f0\pard\sb75{\fs24\b repeat}\par
\f0\pard{\fs20 Continuously repeat the animation "True" or "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The animated gif shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddAnimatedImage(imageName,repeat,countX,countY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Creates an animation from a single image with multiple images on one layer.  {\line}Do not add a very large number of these or performance may be degraded.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The image file (local or network) to load.{\line}Can also be an ImageList image.}\par
\f0\pard\sb75{\fs24\b repeat}\par
\f0\pard{\fs20 Continuously repeat the animation "True" or "False".}\par
\f0\pard\sb75{\fs24\b countX}\par
\f0\pard{\fs20 The number of sub-images in the X direction.}\par
\f0\pard\sb75{\fs24\b countY}\par
\f0\pard{\fs20 The number of sub-images in the Y direction.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The animated shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddPolygon(points) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Creates a polygon shape.}\par
\f0\pard\sb75{\fs24\b points}\par
\f0\pard{\fs20 An array of coordinates for the polygon corners with the form points[i][1] = x, points[i][2] = y.{\line}{\line}The number of points must be 3 or more.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The polygon shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRegularPolygon(numPoint,radius) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Creates a regular polygon shape.}\par
\f0\pard\sb75{\fs24\b numPoint}\par
\f0\pard{\fs20 The number of polygon sides.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 The centre to corner distance.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The regular polygon shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddStar(numPoint,innerRadius,outerRadius) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Creates a star shape.{\line}Fun effects can be created with negative distances.}\par
\f0\pard\sb75{\fs24\b numPoint}\par
\f0\pard{\fs20 The number of star points.}\par
\f0\pard\sb75{\fs24\b innerRadius}\par
\f0\pard{\fs20 The centre to inner points' distance.}\par
\f0\pard\sb75{\fs24\b outerRadius}\par
\f0\pard{\fs20 The centre to outer points' distance.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The star shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateOpacity(shapeName,interval,count) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a shape to animate opacity, flash (fade out and in).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control to flash.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 The interval in ms for a complete flash cycle.{\line}A value of 0 will stop the flashing.}\par
\f0\pard\sb75{\fs24\b count}\par
\f0\pard{\fs20 The number of flashes.{\line}A value of 0 will flash continuously.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateRotation(shapeName,interval,count) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a shape to animate rotation (rotate continuously).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control to rotate.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 The interval in ms for a complete 360 degree rotation.{\line}A value of 0 will stop the rotation.{\line}A value less than 0 will rotate anti-clockwise.}\par
\f0\pard\sb75{\fs24\b count}\par
\f0\pard{\fs20 The number of rotations.{\line}A value of 0 will rotate continuously.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateZoom(shapeName,interval,count,scaleX,scaleY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a shape to animate zooming (in and out).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control to zoom.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 The interval in ms for a complete zoom cycle.{\line}A value of 0 will stop the zooming.}\par
\f0\pard\sb75{\fs24\b count}\par
\f0\pard{\fs20 The number of zoom cycles.{\line}A value of 0 will zoom continuously.}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 The X zoom scale factor.}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 The Y zoom scale factor.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationCount(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the number of images in an animated image.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The animated image shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of images in the animated image.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationInterval \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The update interval for animated images in ms (default 100).{\line}A value of zero will pause all animated image updates, for example allowing AnimationSet to set images as required.{\line}This is an internal timer that applies to all animated images that are not paused or completed a non-repeating cycle.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationPause(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pause an animated image.{\line}Paused images can still be updated using AnimationSet}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The animated image shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationResume(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Resume a previously paused animated image.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The animated image shape name.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationSet(shapeName,image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset animated image to a selected image.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The animated image shape name.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 The selected animated image number (indexed from 1).}\par
\f0\pard\sb180\shading1000{\fs30\b BrushColour(shapeName,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set shape Brush colour.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The new brush colour.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushEllipse(brush,x,y,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Draw an ellipse filled with a gradient of colours.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 A previously created gradient or image brush (LDShapes.BrushGradient LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x co-ordinate of the ellipse.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y co-ordinate of the ellipse.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the ellipse.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the ellipse.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushGradient(colours,orientation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a linear or radial gradient brush.}\par
\f0\pard\sb75{\fs24\b colours}\par
\f0\pard{\fs20 An array of colours to apply to the shape in a gradient.}\par
\f0\pard\sb75{\fs24\b orientation}\par
\f0\pard{\fs20 The orientation for the gradient.{\line}"H" horizontal.{\line}"V" vertical.{\line}"DU" diagonally up.{\line}"DD" diagonally down.{\line}"R"  radial (default if "")}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The gradient brush name.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushImage(imageName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an image brush.{\line}These brushes should work anywhere that BrushGradient can be used.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The image to load to the brush.{\line}Value returned from ImageList.LoadImage or local or network image file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The image brush name.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushPolygon(brush,points) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Draw a polygon filled with a gradient of colours.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 A previously created gradient or image brush (LDShapes.BrushGradient LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b points}\par
\f0\pard{\fs20 An array of coordinates for the polygon corners with the form points[i][1] = x, points[i][2] = y.{\line}{\line}The number of points must be 3 or more.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushRectangle(brush,x,y,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Draw a rectangle filled with a gradient of colours.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 A previously created gradient or image brush (LDShapes.BrushGradient LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x co-ordinate of the rectangle.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y co-ordinate of the rectangle.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the rectangle.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the rectangle.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushRoundedRectangle(brush,x,y,width,height,radius) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Draw a rounded rectangle filled with a gradient of colours.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 A previously created gradient or image brush (LDShapes.BrushGradient LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x co-ordinate of the rectangle.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y co-ordinate of the rectangle.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the rectangle.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the rectangle.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 The radius of the rounded corners.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushShape(shapeName,brush) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a shape Brush style as a gradient of colours.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 A previously created gradient or image brush (LDShapes.BrushGradient LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushText(text,background,foreground) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a text brush.{\line}These brushes should work anywhere that BrushGradient can be used.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to add to the brush.{\line}The current GraphicsWindow font is used.}\par
\f0\pard\sb75{\fs24\b background}\par
\f0\pard{\fs20 The background colour.}\par
\f0\pard\sb75{\fs24\b foreground}\par
\f0\pard{\fs20 The foreground (pen) colour.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The text brush name.}\par
\f0\pard\sb180\shading1000{\fs30\b Centre(shapeName,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Centre the shape on a point, also works for zoomed shapes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x coordinate of the centre.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y coordinate of the centre.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b FastMove(shapeName,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Moves the shape with the specified name to a new position.{\line}This method is maximally optimised for speed.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The name of the shape to move.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The x co-ordinate of the new position.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y co-ordinate of the new position.}\par
\f0\pard\sb180\shading1000{\fs30\b Font(shapeName,family,size,bold,italic) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set shape Font.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b family}\par
\f0\pard{\fs20 The new font family name{\line}See LDUtilities.FontList() for available font families.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 The new font size.}\par
\f0\pard\sb75{\fs24\b bold}\par
\f0\pard{\fs20 The new font bold state ("True" or "False").}\par
\f0\pard\sb75{\fs24\b italic}\par
\f0\pard{\fs20 The new font italic state ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllShapes() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of all currently created shapes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of shape names.}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllShapesAt(x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of all of the shapes (if any) at the specified coordinates.{\line}The coordinates could be the mouse coordinates for example.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The X coordinate}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The Y coordinate}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of shape names or "False".{\line}For multiple shapes, the returned array is ordered from top visual layer to bottom.}\par
\f0\pard\sb180\shading1000{\fs30\b GetColour(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get shape Brush and Pen colours.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 3 element array{\line}1) shape brush (or background) colour in hex format{\line}2) shape opacity (0 to 100){\line}3) shape pen (or foreground) colour in hex format}\par
\f0\pard\sb180\shading1000{\fs30\b GetLeft(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the left position of a shape (works for triangles, polygons and lines).{\line}Also works for shapes while animating.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The x coordinate of the left edge of the shape.}\par
\f0\pard\sb180\shading1000{\fs30\b GetOpacity(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the opacity of a shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The name of the shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The opacity of the object as a value between 0 and 100.  0 is completely transparent and 100 is completely opaque.}\par
\f0\pard\sb180\shading1000{\fs30\b GetProperties(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of shape properties.  These are .Net UIElement properties.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of properties and their values.}\par
\f0\pard\sb180\shading1000{\fs30\b GetProperty(shapeName,property) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a shape property.  This is a .Net UIElement property.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 The property name to get.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The value of the property.}\par
\f0\pard\sb180\shading1000{\fs30\b GetTop(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the top position of a shape (works for triangles, polygons and lines).{\line}Also works for shapes while animating.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The y coordinate of the top edge of the shape.}\par
\f0\pard\sb180\shading1000{\fs30\b Height(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the shape's visible (including zoom) height.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The shape visible height.}\par
\f0\pard\sb180\shading1000{\fs30\b LastEventShape \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last shape for which an event occured (ShapeEvent).}\par
\f0\pard\sb180\shading1000{\fs30\b LastEventType \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last shape event type which an event occured (ShapeEvent).  May be one of the following.{\line}"MouseDown"{\line}"MouseUp"{\line}"MouseEnter"{\line}"MouseLeave"{\line}"GotFocus"{\line}"LostFocus"}\par
\f0\pard\sb180\shading1000{\fs30\b Move(shapeName,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Moves a triangle or polygon top-left position.{\line}This method also works for lines (Shapes.AddLine).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name (a triangle, polygon or line shape).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The X (left) coordinate for the triangle, polygon or line.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The Y (top) coordinate for the triangle, polygon or line.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b MoveLine(shapeName,x1,y1,x2,y2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Moves a line shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name (a line created with Shapes.AddLine).}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 The first X coordinate to move the line to.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 The first Y coordinate to move the line to.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 The second X coordinate to move the line to.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 The second Y coordinate to move the line to.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b MovePolygon(shapeName,points) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Moves a polygon shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name (a polygon created with LDShapes.AddPolygon).}\par
\f0\pard\sb75{\fs24\b points}\par
\f0\pard{\fs20 An array of new coordinates for the polygon corners with the form points[i][1] = x, points[i][2] = y.{\line}{\line}The number of points must be 3 or more and can change with each call.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b MoveTriangle(shapeName,x1,y1,x2,y2,x3,y3) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Moves a triangle shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name (a triangle created with Shapes.AddTriangle).}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 The first X coordinate to move the triangle to.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 The first Y coordinate to move the triangle to.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 The second X coordinate to move the triangle to.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 The second Y coordinate to move the triangle to.}\par
\f0\pard\sb75{\fs24\b x3}\par
\f0\pard{\fs20 The third X coordinate to move the triangle to.}\par
\f0\pard\sb75{\fs24\b y3}\par
\f0\pard{\fs20 The third Y coordinate to move the triangle to.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Overlap(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Checks for shape overlap (collision detection for any ellipse or rectangle shape types).{\line}The first shape should be unZoomed and unRotated.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 The first shape name.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 The second shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b OverlapBox(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Checks for shape overlap of bounding boxes (collision detection).}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 The first shape name.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 The second shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b OverlapCircle(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Checks for shape overlap of bounding circles (collision detection).}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 The first shape name.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 The second shape name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False".}\par
\f0\pard\sb180\shading1000{\fs30\b OverlapDetail \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Following a call to an Overlap method, this property provides additional detail abut the intersection.{\line}Result may be one of:{\line}"Empty" - no intersection{\line}"FullyContains" - shape1 is completely inside shape2{\line}"Intersects" - overlap but neither is fully contained{\line}"FullyInside" - shape2 is completely inside shape1}\par
\f0\pard\sb180\shading1000{\fs30\b PenColour(shapeName,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set shape Pen colour.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 The new pen colour.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b PenStyle(shapeName,dash,space) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set shape Pen style (dash, dot etc).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b dash}\par
\f0\pard{\fs20 The dash length.}\par
\f0\pard\sb75{\fs24\b space}\par
\f0\pard{\fs20 The space length.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b PenWidth(shapeName,width) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set shape Pen width.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The new pen width.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RasteriseTurtleLines() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rasterise all turtle trail lines.{\line}When the number of turtle trails is large the program may slow due to the number of line shapes (trails) present.{\line}This converts the turtle trails from line shapes to background drawings. }\par
\f0\pard\sb180\shading1000{\fs30\b RemoveTurtleLines() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove all turtle trail lines.}\par
\f0\pard\sb180\shading1000{\fs30\b ResetTurtle() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset the Turtle after a GraphicsWindow.Clear().}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b ReSize(shapeName,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Resize shape width and height (an absolute version of zoom).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The shape width.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The shape height.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b RotateAbout(shapeName,x,y,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotate a shape about a point.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape name.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The X coordinate to rotate the shape about.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The Y coordinate to rotate the shape about.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle in degrees to rotate the shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetImage(shapeName,imageName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set or change an image in a button or image shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The image or button name.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The image to load.{\line}Value returned from ImageList.LoadImage or local or network image file.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetProperty(shapeName,property,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a shape property.  This is a .Net UIElement property.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 The property name to set.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to set the property to.}\par
\f0\pard\sb180\shading1000{\fs30\b SetShapeEvent(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Register a shape to record mouse events: MouseDown, MouseUp, MouseEnter, MouseLeave, GotFocus and LostFocus.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control to add.}\par
\f0\pard\sb180\shading1000{\fs30\b SetSize(shapeName,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset the size of a shape as if it was created with the new size.{\line}The position (top left point) is unchanged.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The shape width.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The shape height.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b SetTurtleImage(imageName,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the turtle to an image.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 The image to load for the turtle.{\line}Value returned from ImageList.LoadImage or local or network image file.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 The size to scale the turtle to (default turtle is 16).}\par
\f0\pard\sb180\shading1000{\fs30\b ShapeEvent \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a shape event occurs to a registered shape (SetShapeEvent)}\par
\f0\pard\sb180\shading1000{\fs30\b Skew(shapeName,angleX,angleY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Skews the shape with the specified name by the specified angles.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The name of the shape to skew.}\par
\f0\pard\sb75{\fs24\b angleX}\par
\f0\pard{\fs20 The angle to skew the shape in the X direction.}\par
\f0\pard\sb75{\fs24\b angleY}\par
\f0\pard{\fs20 The angle to skew the shape in the Y direction.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Width(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the shape's visible (including zoom) width.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The shape visible width.}\par
\f0\pard\sb180\shading1000{\fs30\b ZIndex(shapeName,z_index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set shape z index (layer position negative are background and positive are foreground - default 0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 The shape or control name.}\par
\f0\pard\sb75{\fs24\b z_index}\par
\f0\pard{\fs20 The z-index (zero, positive or negative interger).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b ZoomAll(scaleX,scaleY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zoom all shapes.}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 The x-axis zoom level.}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 The y-axis zoom level.}\par
\f0\pard\sb300\shading2000{\fs36\b LDShell}\par
\f0\pard{\fs20 Functions for extended file infos, LNK/URL shortcuts and Shell apps. (All code and methods provided by Pappa Lapub).}\par

\f0\pard\sb180\shading1000{\fs30\b AllDetails \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets all available extended properties as Array ("idx=property name;", where -1=Infotip, 0=Name, .. up to 286=Total bitrate (or ev. ?Full bitrate? on engl systems)).}\par
\f0\pard\sb180\shading1000{\fs30\b ApplyVerbOn(path,verb) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Apply the given Verb (contextmenu item) for the given file or folder.{\line}List of available Verbs (for a filetype or folder) under 'GetAllVerbsFor'.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 The full file- or folder path.}\par
\f0\pard\sb75{\fs24\b verb}\par
\f0\pard{\fs20 The Verb to apply (case- and '&' insensitive).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" on success, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CascadeWindows() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Orders all opended windows in cascades on the desktop (Revert with RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b DateTimeSettings() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Shows the dialog for date- and time settings.}\par
\f0\pard\sb180\shading1000{\fs30\b DTIconsHide() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hides all desktop icons.}\par
\f0\pard\sb180\shading1000{\fs30\b DTIconsOn \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets weather the desktop icons are currently visible ("True" or "False").}\par
\f0\pard\sb180\shading1000{\fs30\b DTIconsShow() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Shows all hidden desktop icons again.}\par
\f0\pard\sb180\shading1000{\fs30\b DTIconsToggle() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Toggles the view of all desktop icons automatically (On/Off).}\par
\f0\pard\sb180\shading1000{\fs30\b ExploreFolder(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Opens a specified folder in a Windows Explorer window. (parent folder for existing file path). In new tab in QTTabBar.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 The folder path to open in explorer (file path opens parent folder). The folder must exist.}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllDetailNamesFor(path,step1) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the names of all available extended properties for a given file or folder as Array (up to max. 316, w/o -1=Infotip).}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 The full file- or folder path.}\par
\f0\pard\sb75{\fs24\b step1}\par
\f0\pard{\fs20 Indizes in speps by 1?  "True" or "False" (default, real property ID).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The names of all available extended properties as Array ("idx=property name;...", w/o Infotip) on success, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllDetailsFor(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets all available extended properties for the given file or folder as Array (up to max. 316, without -1=Infotip).}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 The full file- or folder path.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 All available extended properties as Array ("property name=value;...", without Infotip) on success, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllVerbsFor(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets all available Verbs (contextmenu items) for a given filetype or folder as Array.{\line}Applying of a Verb on file/folder under see 'ApplyVerbOn'.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 The full file- or folder path.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 All available Verbs as Array ("idx=verb;...", w/o '&') on success, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetDetail(path,infoType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the value of an extended property for a given file or folder.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 The full file- or folder path.}\par
\f0\pard\sb75{\fs24\b infoType}\par
\f0\pard{\fs20 The ID number or name of the property (eg. -1="Infotip"/"", 0="Name", 1="Size", etc.){\line}ID numbers and names of available properties under s. 'AllDetails'.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The value of the property if available, else "". "FAILED" on failure (eg. missing path).{\line}Infotip lines separated by lf and ending with crlf.}\par
\f0\pard\sb180\shading1000{\fs30\b GetSetting(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets values for global Shell settings (s. folder opions-view, CheckedStatus).}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 An integer constant for the value to get (eg. 1, 2, 4, "8", "32" etc.).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False" on success, else "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://msdn.microsoft.com/library/windows/desktop/gg537739.aspx{\line}ShowAllObjects = SBShell.GetSetting(1){\line}ShowExtensions = SBShell.GetSetting(2){\line}ShowInfoTip = SBShell.GetSetting(8192){\line}ShowSuperHidden = SBShell.GetSetting(262144)}\par
\f0\pard\sb180\shading1000{\fs30\b GetSystemInfo(info) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets a given Systeminformation.}\par
\f0\pard\sb75{\fs24\b info}\par
\f0\pard{\fs20 The name of the value to get. Options:{\line}"DirectoryServiceAvailable", "DoubleClickTime", "ProcessorLevel", "ProcessorSpeed", "ProcessorArchitecture", "PhysicalMemoryInstalled", "IsOS_DomainMember"{\line}(Only XP: "IsOS_Professional", "IsOS_Personal").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The queried value on success, else "" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b LinkCreate(shortcut,target) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Creates a new lnk/url shortcut (Shell32). Further editing with 'LinkSetProperty'.}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 The full path for the new lnk/url shortcut file.}\par
\f0\pard\sb75{\fs24\b target}\par
\f0\pard{\fs20 The full path of the target file/-folder resp. URL address.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The full file path of the created shortcut on success, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b LinkGetProperty(shortcut,property) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets properties of a lnk/url shortcut link, like target pfad, arguments etc.}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 The full path of the lnk/url shortcut link file.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 The property to get (case independent, * for Urls) like:{\line}"Target"  target path *{\line}"Args"    arguments{\line}"Folder"  working directory{\line}"Desc"    comment *{\line}"HotKey"  shortcut key comb * (default: 0){\line}"Style"   window style * (1 normal, 3 max, 7 min){\line}"Icon"    icon path}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The value of the property if available or "". "FAILED" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b LinkSetProperty(shortcut,target,args,folder,desc,icoPath,icoIdx,hotkey,style) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Modifies properties of an existing lnk/url shortcut link, like target path, arguments etc. (* for Urls).}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 The full path of an existing lnk/url shortcut link file.}\par
\f0\pard\sb75{\fs24\b target}\par
\f0\pard{\fs20 * The full path of the target file/-folder resp. URL address.}\par
\f0\pard\sb75{\fs24\b args}\par
\f0\pard{\fs20 Startparameter when launching the shortcut or "" (for url).}\par
\f0\pard\sb75{\fs24\b folder}\par
\f0\pard{\fs20 The full path of the start folder or "" (for url).}\par
\f0\pard\sb75{\fs24\b desc}\par
\f0\pard{\fs20 * Comment or description for the shortcut or "".}\par
\f0\pard\sb75{\fs24\b icoPath}\par
\f0\pard{\fs20 * Full path of the icon file for the shortcut or "".}\par
\f0\pard\sb75{\fs24\b icoIdx}\par
\f0\pard{\fs20 * Index of the icon in the icon file (default: 0, for .ico).}\par
\f0\pard\sb75{\fs24\b hotkey}\par
\f0\pard{\fs20 * keys combination to launch the shortcut link (default: 0).}\par
\f0\pard\sb75{\fs24\b style}\par
\f0\pard{\fs20 * Window style when launching the shortcut (default: 1 normal, 3 max, 7 min).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The full file path of the modified shortcut on success, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Name \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the name of the executing assembly for this extension.}\par
\f0\pard\sb180\shading1000{\fs30\b OpenFolder(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Opens explorer with the given file-/folder path (parent folder for existing file path). In new tab in QTTabBar.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Opens the specified folder (file path opens parent folder). The folder must exist.}\par
\f0\pard\sb180\shading1000{\fs30\b RestoreWindows() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Restores all minimized windows in the taskbar (after ShowDesktop, TileAll.., CascadeWindows) again.}\par
\f0\pard\sb180\shading1000{\fs30\b RunBox() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Shows the Run(box) Dialog.}\par
\f0\pard\sb180\shading1000{\fs30\b SelectFolder(title,initDir) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Shows a folder selection dialog.}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 The title to show on the dialog.}\par
\f0\pard\sb75{\fs24\b initDir}\par
\f0\pard{\fs20 The start folder when the dialog opens or "" for last selected folder (default: Computer).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The full folder path after selection or "" when canceled, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ShellLink(shortcut,target) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Creates a new lnk/url shortcut (IWshRuntimeLibrary). Further editing with 'ShellLinkSet'.}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 The full path for the new lnk/url shortcut file.}\par
\f0\pard\sb75{\fs24\b target}\par
\f0\pard{\fs20 The full path of the target file/-folder resp. URL address.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The full file path of the created shortcut on success, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ShellLinkGet(shortcut,property) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets properties of a lnk/url shortcut link, like target pfad, arguments etc. (IWshRuntimeLibrary).}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 The full path of the lnk/url shortcut link file.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 The property to get (case independent, * for Urls) like:{\line}"Target"   target path *{\line}"Args"    arguments{\line}"Folder"  working directory{\line}"Desc"    comment *{\line}"HotKey"   shortcut key comb * (default: 0){\line}"Style"   window style * (1 normal, 3 max, 7 min){\line}"Icon"    icon path,Idx (default: ,0)}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The value of the property if available or "". "FAILED" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b ShellLinkSet(shortcut,target,args,folder,desc,icon,hotkey,style) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Modifies properties of an existing lnk/url shortcut link, like target path, arguments etc. (* for Urls) (IWshRuntimeLibrary).}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 The full path of an existing lnk/url shortcut link file.}\par
\f0\pard\sb75{\fs24\b target}\par
\f0\pard{\fs20 * The full path of the target file/-folder resp. URL address.}\par
\f0\pard\sb75{\fs24\b args}\par
\f0\pard{\fs20 Startparameter when launching the shortcut or "" (for url).}\par
\f0\pard\sb75{\fs24\b folder}\par
\f0\pard{\fs20 The full path of the start folder or "" (for url).}\par
\f0\pard\sb75{\fs24\b desc}\par
\f0\pard{\fs20 * Comment or description for the shortcut or "".}\par
\f0\pard\sb75{\fs24\b icon}\par
\f0\pard{\fs20 * The full path (resp. path,Idx) of the icon for the shortcut link or "". 'Idx' is Index of the icon in in the file (default: 0, for .ico).}\par
\f0\pard\sb75{\fs24\b hotkey}\par
\f0\pard{\fs20 * keys combination to launch the shortcut link (default: 0).}\par
\f0\pard\sb75{\fs24\b style}\par
\f0\pard{\fs20 * Window style when launching the shortcut (default: 1 normal, 3 max, 7 min).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The full file path of the modified shortcut on success, else "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ShowDesktop() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Minimizes all opened windows into the taskbar and showes the desktop (Revert with RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b ShowFileProperties(filePath) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Opens the shell properties dialog for a given file or folder path (GW is needed for that, not available from TW or Console).}\par
\f0\pard\sb75{\fs24\b filePath}\par
\f0\pard{\fs20 The full file- or folder path.}\par
\f0\pard\sb180\shading1000{\fs30\b SpecialFolderConstants \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets a list of all CSIDL numbers and their according special System-/Shell folder names as Array ("csidl=folder name;").}\par
\f0\pard\sb180\shading1000{\fs30\b SpecialFolderList(csidl) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets all items in a special system/shell folder (upper level only).}\par
\f0\pard\sb75{\fs24\b csidl}\par
\f0\pard{\fs20 The CSIDL number of the system folder (0 to 47, constants and names of available folders under s. SpecialFolderConstants).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The names of all objects in the system folder as Array (only upper level) on success, else "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://msdn.microsoft.com/library/bb774096.aspx{\line}eg. CSIDL for:{\line} 3 Control panel{\line} 5 my documents{\line} 8 Recent{\line} 9 SendTo{\line}10 RecBin{\line}16 Desktop folder{\line}17 Computer{\line}20 Fonts{\line}32 Temp Inet Files}\par
\f0\pard\sb180\shading1000{\fs30\b SpecialFolderPaths \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets a list of all special System-/Shell folder names and their according folder paths as Array ("folder name=path;").}\par
\f0\pard\sb180\shading1000{\fs30\b SpecialFolders \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets a list of all special System folders as Array ("folder name=path;"). For Shell folders s. 'SpecialFolderPaths'.}\par
\f0\pard\sb180\shading1000{\fs30\b StartSettings() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Shows the dialog for startmen?/taskbar settings.}\par
\f0\pard\sb180\shading1000{\fs30\b Switch3D() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Orders all opended windows in a 3D stack on the desktop to select through (with arrow keys).}\par
\f0\pard\sb180\shading1000{\fs30\b TileAllHoriz() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Orders all opened windows horizontally tiled on the desktop (Revert with RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b TileAllVert() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Orders all opened windows vertically tiled on the desktop (Revert with RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b ToggleDesktop() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Toggles the view of the (windowless) desktop on and off (s. ShowDesktop/RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b Version \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the current file version of this extension (else 0.0.0.0).}\par
\f0\pard\sb300\shading2000{\fs36\b LDSort}\par
\f0\pard{\fs20 Sort arrays (the sorting of character strings may be case sensitive or insensitive).}\par

\f0\pard\sb180\shading1000{\fs30\b ByIndex(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sort an array of any dimension by the index (key).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to sort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A sorted array.}\par
\f0\pard\sb180\shading1000{\fs30\b ByValue(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sort a 1D array by the value (the indices are re-numbered from 1).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to sort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A sorted array.}\par
\f0\pard\sb180\shading1000{\fs30\b ByValueWithIndex(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sort a 1D array by the value (the indices are unchanged, but sorted).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to sort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A sorted array.}\par
\f0\pard\sb180\shading1000{\fs30\b CaseSensitive \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 String comparisons are case sensitive "True" or "False".}\par
\f0\pard\sb300\shading2000{\fs36\b LDSound}\par
\f0\pard{\fs20 A Sound Recorder.  A microphone (may be internal) is required.{\line}System sounds can also be played (if they are set appropriately).}\par

\f0\pard\sb180\shading1000{\fs30\b Asterisk() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play system Asterisk sound.}\par
\f0\pard\sb180\shading1000{\fs30\b Beep() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play system Beep sound.}\par
\f0\pard\sb180\shading1000{\fs30\b Exclamation() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play system Exclamation sound.}\par
\f0\pard\sb180\shading1000{\fs30\b Hand() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play system Hand sound.}\par
\f0\pard\sb180\shading1000{\fs30\b MusicPlayTime(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the play time for a music file.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path of the music file e.g. "C:\\Users\\Public\\Music\\song.mp3".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The file play time in seconds (0 if failed).}\par
\f0\pard\sb180\shading1000{\fs30\b Pause() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pause a recording.}\par
\f0\pard\sb180\shading1000{\fs30\b Question() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play system Question sound.}\par
\f0\pard\sb180\shading1000{\fs30\b Resume() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Resume a paused recording.}\par
\f0\pard\sb180\shading1000{\fs30\b Start() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Start recording sound.}\par
\f0\pard\sb180\shading1000{\fs30\b Stop(wavFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stop and save current sound recording.}\par
\f0\pard\sb75{\fs24\b wavFile}\par
\f0\pard{\fs20 The full path to a wav file to save the recording.{\line}The extension will be set to ".wav" if it is not already.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Tone(frequency,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play a system tone sound with frequency and duration.{\line}Uses the motherboard speaker (not the sound card) and may be low quality or not available.}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 The tone frequency (from 37 to 32767 Hz).}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 The tone duration in ms.}\par
\f0\pard\sb180\shading1000{\fs30\b Volume(command) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Change the volume of sounds.}\par
\f0\pard\sb75{\fs24\b command}\par
\f0\pard{\fs20 One of the following options to change the sound volume level.{\line}"Up" increase volume level.{\line}"Down" decrease volume level.{\line}"Mute" toggle between mute and un-mute volume level.}\par
\f0\pard\sb300\shading2000{\fs36\b LDSpeech}\par
\f0\pard{\fs20 The Speech library allows text to be spoken and speech recognition.}\par

\f0\pard\sb180\shading1000{\fs30\b LastSpoken \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Text of the last speech spoken (and recognised) by the computer.}\par
\f0\pard\sb180\shading1000{\fs30\b LastSpokenConfidence \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last speech spoken detection confidence of correctness (0 to 1).}\par
\f0\pard\sb180\shading1000{\fs30\b Listen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when speech is spoken (and recognised) by the computer.{\line}A good microphone, lots of training or consise dictionary are needed to get decent results.}\par
\f0\pard\sb180\shading1000{\fs30\b Speak(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speak some text.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Text to be spoken.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Speed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speed of speech (-10 to 10).}\par
\f0\pard\sb180\shading1000{\fs30\b Vocabulary(dictionary) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a vocabulary of words and phrases for the speech regonition to use.{\line}If this is unset, then a large language vocabulary is used and the results will generally be less good (unusable).{\line}Also distinct phrases can have a better recognition than single words.}\par
\f0\pard\sb75{\fs24\b dictionary}\par
\f0\pard{\fs20 An array of words or phrases to be recognised.{\line}If it is empty, then the default language vocabulary is used.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Voice \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The current voice.}\par
\f0\pard\sb180\shading1000{\fs30\b Voices() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Returns an array of available voices.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of available voices.}\par
\f0\pard\sb180\shading1000{\fs30\b Volume \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Volume of speech (0 to 100).}\par
\f0\pard\sb300\shading2000{\fs36\b LDStatistics}\par
\f0\pard{\fs20 Performs statistics on a 1D array of data.}\par

\f0\pard\sb180\shading1000{\fs30\b Count \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The number of data points.}\par
\f0\pard\sb180\shading1000{\fs30\b Differentiate(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate the derivative of a 1D data array.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to differentiate (array[x]=y).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 1D array of the Derivative of the input array.}\par
\f0\pard\sb180\shading1000{\fs30\b DistBinomial(n,p) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an array with a Binomial distribution.{\line}{\line}This is like the probablity of getting k heads from 20 (n) coin tosses, with a probablity for each toss getting a heads of 0.5 (p).}\par
\f0\pard\sb75{\fs24\b n}\par
\f0\pard{\fs20 The number of tries.}\par
\f0\pard\sb75{\fs24\b p}\par
\f0\pard{\fs20 The probablity of success for each try.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 1D array of the Binomial distribution, probablity of k successes (Array[k] = y).}\par
\f0\pard\sb180\shading1000{\fs30\b DistNormal(distMean,distSTD,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an array with a Normal distribution.}\par
\f0\pard\sb75{\fs24\b distMean}\par
\f0\pard{\fs20 The mean of the distribution.}\par
\f0\pard\sb75{\fs24\b distSTD}\par
\f0\pard{\fs20 The standard deviation of the distribution.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 The number of points.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 1D array of the Normal distribution (Array[x] = y).}\par
\f0\pard\sb180\shading1000{\fs30\b DistTriangular(rangeMin,rangeMax,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an array with a Triangular distribution.}\par
\f0\pard\sb75{\fs24\b rangeMin}\par
\f0\pard{\fs20 The minimum value.}\par
\f0\pard\sb75{\fs24\b rangeMax}\par
\f0\pard{\fs20 The maximum value.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 The number of points.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 1D array of the Triangular distribution (Array[x] = y).}\par
\f0\pard\sb180\shading1000{\fs30\b DistUniform(rangeMin,rangeMax,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create an array with a Uniform distribution.}\par
\f0\pard\sb75{\fs24\b rangeMin}\par
\f0\pard{\fs20 The minimum value.}\par
\f0\pard\sb75{\fs24\b rangeMax}\par
\f0\pard{\fs20 The maximum value.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 The number of points.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 1D array of the Uniform distribution (Array[x] = y).}\par
\f0\pard\sb180\shading1000{\fs30\b Frequency(array,bins,normalised) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate a frequency distribution from array of data.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to create the frequency distribution from.}\par
\f0\pard\sb75{\fs24\b bins}\par
\f0\pard{\fs20 The number of bins spanning the data.}\par
\f0\pard\sb75{\fs24\b normalised}\par
\f0\pard{\fs20 Is the frequency normalised to integrate to 1 ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Frequency distribution as an array (array[bin]=frequency).}\par
\f0\pard\sb180\shading1000{\fs30\b GeometricMean \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The geometric mean of the data points (all points > 0).}\par
\f0\pard\sb180\shading1000{\fs30\b HarmonicMean \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The harmonic mean of the data points (all points > 0).}\par
\f0\pard\sb180\shading1000{\fs30\b Integrate(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Calculate the integral of a 1D data array.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to integrate (array[x]=y).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A 1D array of the Integral of the input array.}\par
\f0\pard\sb180\shading1000{\fs30\b InterpolateX(array,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Interpolate a 1D data array to find the value of x(y).{\line}{\line}The values of y should be monotonically increasing with x.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to interpolate (array[x]=y).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The value of y (may be an array of y values).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The interpolated value x or an array of x values.}\par
\f0\pard\sb180\shading1000{\fs30\b InterpolateY(array,x) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Interpolate a 1D data array to find the value of y(x).{\line}{\line}The values of x should be monotonically increasing.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to interpolate (array[x]=y).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The value of x (may be an array of x values).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The interpolated value y or an array of y values.}\par
\f0\pard\sb180\shading1000{\fs30\b Max \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The maximum value of the data points.}\par
\f0\pard\sb180\shading1000{\fs30\b Mean \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The arithmetic mean of the data points.}\par
\f0\pard\sb180\shading1000{\fs30\b Median \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The median of the data points.}\par
\f0\pard\sb180\shading1000{\fs30\b Min \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The minimum value of the data points.}\par
\f0\pard\sb180\shading1000{\fs30\b Mode \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The mode of the data points.}\par
\f0\pard\sb180\shading1000{\fs30\b PDev \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The population deviation of the data points.}\par
\f0\pard\sb180\shading1000{\fs30\b SDev \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The standard deviation of the data points.}\par
\f0\pard\sb180\shading1000{\fs30\b SetArray(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set a 1D array of numbers to perform some statistics on.{\line}{\line}This command must be called before any statistics are calculated.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 The array to perform statistics on.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of the data sorted.}\par
\f0\pard\sb180\shading1000{\fs30\b Sum \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The sum of data points.}\par
\f0\pard\sb180\shading1000{\fs30\b Sum2 \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The sum of the squares of the data points.}\par
\f0\pard\sb300\shading2000{\fs36\b LDStopwatch}\par
\f0\pard{\fs20 Accurate system stopwatches.}\par

\f0\pard\sb180\shading1000{\fs30\b Add() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new stopwatch.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The stopwatch name.}\par
\f0\pard\sb180\shading1000{\fs30\b DelayUpTo(delay) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delay up to a maximum interval since the last time this is called.{\line}Useful in a game loop to maintain an even play speed.}\par
\f0\pard\sb75{\fs24\b delay}\par
\f0\pard{\fs20 The maximum delay in ms.}\par
\f0\pard\sb180\shading1000{\fs30\b ElapsedMilliseconds(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the total elapsed time measured in milliseconds.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 The stopwatch name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Elapsed milliseconds.}\par
\f0\pard\sb180\shading1000{\fs30\b ElapsedTicks(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the total elapsed time measured in timer ticks for very short intervals.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 The stopwatch name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Elapsed ticks.}\par
\f0\pard\sb180\shading1000{\fs30\b Frequency \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the frequency of the stopwatch timer in ticks per second.{\line}This represents the finest resolution of time your hardware can measure with ElapsedTicks.}\par
\f0\pard\sb180\shading1000{\fs30\b Reset(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stops the current stopwatch and resets the elapsed time to 0.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 The stopwatch name.}\par
\f0\pard\sb180\shading1000{\fs30\b Restart(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stops the current stopwatch, resets the elapsed time to 0 and restarts the stopwatch.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 The stopwatch name.}\par
\f0\pard\sb180\shading1000{\fs30\b Start(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Starts or resumes the current stopwatch.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 The stopwatch name.}\par
\f0\pard\sb180\shading1000{\fs30\b Stop(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stops the current stopwatch.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 The stopwatch name.}\par
\f0\pard\sb300\shading2000{\fs36\b LDText}\par
\f0\pard{\fs20 Text manipulations.}\par

\f0\pard\sb180\shading1000{\fs30\b Compare(text1,text2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Lexically compare 2 text strings, the comparison is case insensitive and culture invariant.}\par
\f0\pard\sb75{\fs24\b text1}\par
\f0\pard{\fs20 The first string to compare.}\par
\f0\pard\sb75{\fs24\b text2}\par
\f0\pard{\fs20 The second string to compare.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An integer:{\line}less than zero (text1 is less than text2){\line}zero (strings are equal){\line}greater than zero (text1 is greater than text2)}\par
\f0\pard\sb180\shading1000{\fs30\b FastStringAppend(fastString,text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Append a string value to a fast string object.}\par
\f0\pard\sb75{\fs24\b fastString}\par
\f0\pard{\fs20 A fast string object.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The test to append.}\par
\f0\pard\sb180\shading1000{\fs30\b FastStringClear(fastString) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Reset a fast string object to "".}\par
\f0\pard\sb75{\fs24\b fastString}\par
\f0\pard{\fs20 A fast string object.}\par
\f0\pard\sb180\shading1000{\fs30\b FastStringGet(fastString) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the current text in a fast string.}\par
\f0\pard\sb75{\fs24\b fastString}\par
\f0\pard{\fs20 A fast string object.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The current fast string text.}\par
\f0\pard\sb180\shading1000{\fs30\b FastStringNew() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new fast string appending object.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The fast string append object.}\par
\f0\pard\sb180\shading1000{\fs30\b FindAll(text,find) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get all occurances of a subtext in some text.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to search.}\par
\f0\pard\sb75{\fs24\b find}\par
\f0\pard{\fs20 The subtext to search for.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array with the positions of the start of each subtext or 0 for none.}\par
\f0\pard\sb180\shading1000{\fs30\b GetHeight(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the height in pixels that text will be displayed in the GraphicsWindow with the current font.{\line}The GraphicsWindow must be open to use this method.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to get the height.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The width in pixels.}\par
\f0\pard\sb180\shading1000{\fs30\b GetWidth(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the width in pixels that text will be displayed in the GraphicsWindow with the current font.{\line}The GraphicsWindow must be open to use this method.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 The text to get the width.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The width in pixels.}\par
\f0\pard\sb180\shading1000{\fs30\b Replace(text,find,replace) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Find and Replace all occurances of one text with another.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 A text to modify.}\par
\f0\pard\sb75{\fs24\b find}\par
\f0\pard{\fs20 The text to find and replace.}\par
\f0\pard\sb75{\fs24\b replace}\par
\f0\pard{\fs20 The text to replace the found text.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A modified copy of the input text.}\par
\f0\pard\sb180\shading1000{\fs30\b Split(text,separator) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Split a variable into an array delimiated by a separator.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 A text string to split.}\par
\f0\pard\sb75{\fs24\b separator}\par
\f0\pard{\fs20 A separator string (e.g. " "), or an array of separator strings.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A result array of deliminated texts.}\par
\f0\pard\sb180\shading1000{\fs30\b Trim(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Return a string with all leading and trailing 'white space' removed.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 A string to trim.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A trimmed copy of the input string.}\par
\f0\pard\sb300\shading2000{\fs36\b LDTextWindow}\par
\f0\pard{\fs20 TextWindow utilities.{\line}Includes low level keyboard events.}\par

\f0\pard\sb180\shading1000{\fs30\b Capture(fileName,border) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save the TextWindow as an image file (png, jpg, bmp, gif, tiff or ico).{\line}{\line}The window must be visible and a short delay may be required after updating the window before calling.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The file to save the image to (*.png, *.jpg, *.bmp, *.gif, *.tiff or *.ico).{\line}If this is set to "", then the image is created internally as an ImageList.}\par
\f0\pard\sb75{\fs24\b border}\par
\f0\pard{\fs20 Include the window border ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The ImageList image if fileName is "", otherwise if output to a file, then "" is returned.}\par
\f0\pard\sb180\shading1000{\fs30\b Encoding \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set extended encoding for the TextWindow.{\line}Allowed values are:{\line}"ASCII" (default), "Unicode", "UTF7", "UTF8"}\par
\f0\pard\sb180\shading1000{\fs30\b Hide() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hide the TextWindow.{\line}Replacement for standard method that may fail (do not mix these methods).}\par
\f0\pard\sb180\shading1000{\fs30\b KeyDown \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Low level event when a key is pressed down.{\line}This event is independent of any window focus, i.e. not just for TextWindow or GraphicsWindow.}\par
\f0\pard\sb180\shading1000{\fs30\b KeyUp \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Low level event when a key is released.{\line}This event is independent of any window focus, i.e. not just for TextWindow or GraphicsWindow.}\par
\f0\pard\sb180\shading1000{\fs30\b LastKey \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Last key pressed or released.}\par
\f0\pard\sb180\shading1000{\fs30\b Print(border) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Print the TextWindow contents.{\line}{\line}The window must be visible and a short delay may be required after updating the window before calling.}\par
\f0\pard\sb75{\fs24\b border}\par
\f0\pard{\fs20 Include the window border ("True" or "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb180\shading1000{\fs30\b Read(delay) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read from a TextWindow with a maximum delay.{\line}This sends a Return (ENTER) to the TextWindow after the delay.{\line}If the user presses Return before the delay is completed, then no further action is taken.}\par
\f0\pard\sb75{\fs24\b delay}\par
\f0\pard{\fs20 A maximum delay in ms before the Read is terminated.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The text that was read from the TextWindow.}\par
\f0\pard\sb180\shading1000{\fs30\b ReadNumber(delay) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Read a number from a TextWindow with a maximum delay.{\line}This sends a Return (ENTER) to the TextWindow after the delay.{\line}If the user presses Return before the delay is completed, then no further action is taken.}\par
\f0\pard\sb75{\fs24\b delay}\par
\f0\pard{\fs20 A maximum delay in ms before the Read is terminated.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number that was read from the TextWindow.}\par
\f0\pard\sb180\shading1000{\fs30\b SendKey(window,key) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Send a key to a window.  This is the same a typing the key into a window.}\par
\f0\pard\sb75{\fs24\b window}\par
\f0\pard{\fs20 The window title e.g. TextWindow.Title or GraphicsWindow.Title.}\par
\f0\pard\sb75{\fs24\b key}\par
\f0\pard{\fs20 The key to send e.g. "Return"}\par
\f0\pard\sb180\shading1000{\fs30\b SetColour(index,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Replace one of the standard TextWindow colours.{\line}There are 16 available colours, by default they are indexed 0 to 15:{\line}Black (0), DarkBlue (1), DarkGreen (2), DarkCyan (3), DarkRed (4), DarkMagenta (5), DarkYellow (6), Gray (7),{\line}DarkGray (8), Blue (9), Green (10), Cyan (11), Red (12), Magenta (13), Yellow (14), White (15).{\line}Note that you can still use TextWindow.BackgroundColor and TextWindow.ForegroundColor to use the new colours (with the original colour names), alternatively the colours can be selected using LDTextWindow.SetColours from the indices.{\line}The colours must be set using either method before they are applied.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 The stanadard colour index colour to replace.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Any colour to replace a standard colour with.}\par
\f0\pard\sb180\shading1000{\fs30\b SetColours(fgIndex,bgIndex) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the current foreground and background colour indices.}\par
\f0\pard\sb75{\fs24\b fgIndex}\par
\f0\pard{\fs20 The foreground colour index (0 to 15).}\par
\f0\pard\sb75{\fs24\b bgIndex}\par
\f0\pard{\fs20 The background colour index (0 to 15).}\par
\f0\pard\sb180\shading1000{\fs30\b Show() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Show the TextWindow and give it focus.{\line}Replacement for standard method that may fail (do not mix these methods).}\par
\f0\pard\sb300\shading2000{\fs36\b LDTimer}\par
\f0\pard{\fs20 Additional timers.}\par

\f0\pard\sb180\shading1000{\fs30\b Add() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new timer.  All timers created with this method call the event subroutine defined by Tick.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The timer name.}\par
\f0\pard\sb180\shading1000{\fs30\b AddTick(tick) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new timer.  This timer only calls its own event subroutine.}\par
\f0\pard\sb75{\fs24\b tick}\par
\f0\pard{\fs20 The event subroutine for this timer.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The timer name.}\par
\f0\pard\sb180\shading1000{\fs30\b Interval(timer,interval) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Starts or resumes a timer.}\par
\f0\pard\sb75{\fs24\b timer}\par
\f0\pard{\fs20 The timer name.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 Sets the interval (in milliseconds) specifying how often the timer should raise the Tick event.  This value can range from 10 to 100000000.}\par
\f0\pard\sb180\shading1000{\fs30\b LastTimer \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The last timer created with Add that raised an event.}\par
\f0\pard\sb180\shading1000{\fs30\b Pause(timer) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pauses a timer.  Tick events will not be raised.}\par
\f0\pard\sb75{\fs24\b timer}\par
\f0\pard{\fs20 The timer name.}\par
\f0\pard\sb180\shading1000{\fs30\b Resume(timer) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Resumes a timer from a paused state.  Tick events will now be raised.}\par
\f0\pard\sb75{\fs24\b timer}\par
\f0\pard{\fs20 The timer name.}\par
\f0\pard\sb180\shading1000{\fs30\b Tick \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Raises an event when a timer created with Add ticks.}\par
\f0\pard\sb300\shading2000{\fs36\b LDTranslate}\par
\f0\pard{\fs20 Language translation methods.}\par

\f0\pard\sb180\shading1000{\fs30\b Languages() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of language codes and their language.{\line}The array indices are the required language codes for the Translate method.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The 1D array of language codes and names.}\par
\f0\pard\sb180\shading1000{\fs30\b Translate(input,languageFrom,languageTo) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Translate a text from one language to another.}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 The text to translate.}\par
\f0\pard\sb75{\fs24\b languageFrom}\par
\f0\pard{\fs20 The language code to translate from.}\par
\f0\pard\sb75{\fs24\b languageTo}\par
\f0\pard{\fs20 The language code to translate to.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The translated text.}\par
\f0\pard\sb300\shading2000{\fs36\b LDUnits}\par
\f0\pard{\fs20 A general editable unit conversion system.{\line}All units and dimensions are case sensitive.{\line}A base unit consists of a single dimension and name, and are all independent.{\line}A derived unit consists of a description, name and units definition consisting of base or other derived units, and optional additive term, usually 0.{\line}A unit is parsed by separting . / + - and *, then recursively resolving derived unit conversions, bracketed () terms first.{\line}Values (especially those with a decimal point '.' or minus '-') should be contained in ().{\line}A unit may be prefixed by a prefix or number value (e.g. m is mili 0.001, K is kilo 1000 etc).{\line}Any unit may be postfixed by a power.{\line}A typical unit may be "mile/hr", "m/s2" or "MJ/day" etc and can be any combination of base and derived units.{\line}Any pair of unis that are dimensionally the same can be converted.{\line}An additive value is only used for non-compound unit conversions (e.g. C to F).{\line}To avoid obscure prefix unit conflicts use a full prefix name (e.g. min could be 60 seconds or 0.001 inches, the latter should be milliin).  {\line}Currency conversions are updated daily.}\par

\f0\pard\sb180\shading1000{\fs30\b AddBaseUnit(dimension,name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a base unit to the system.}\par
\f0\pard\sb75{\fs24\b dimension}\par
\f0\pard{\fs20 The base unit dimension (e.g. TEMPERATURE).}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The unit name (be careful it doesn't confict with existing unit names).}\par
\f0\pard\sb180\shading1000{\fs30\b AddConstant(description,name,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a dimensionless constant to the system.}\par
\f0\pard\sb75{\fs24\b description}\par
\f0\pard{\fs20 An optional long name or description of the constant.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The constant name (be careful it doesn't confict with existing constant names).}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The derived constant value.}\par
\f0\pard\sb180\shading1000{\fs30\b AddDerivedUnit(description,name,units,add) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a derived unit to the system.}\par
\f0\pard\sb75{\fs24\b description}\par
\f0\pard{\fs20 An optional long name or description of the derived unit.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The unit name (be careful it doesn't confict with existing unit names).}\par
\f0\pard\sb75{\fs24\b units}\par
\f0\pard{\fs20 The derived unit definition.}\par
\f0\pard\sb75{\fs24\b add}\par
\f0\pard{\fs20 An optional addition term.}\par
\f0\pard\sb180\shading1000{\fs30\b Convert(value,fromUnit,toUnit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert a value from one unit to another.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 The value to convert.}\par
\f0\pard\sb75{\fs24\b fromUnit}\par
\f0\pard{\fs20 The units to convert from.}\par
\f0\pard\sb75{\fs24\b toUnit}\par
\f0\pard{\fs20 The units to convert to.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The converted value or "FAILED" (usually non-existant unit or inconsistant dimensions).}\par
\f0\pard\sb180\shading1000{\fs30\b Export() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Export the current unit system to a file (units.txt in the current program folder).}\par
\f0\pard\sb180\shading1000{\fs30\b GetBaseUnits() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of current base units.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of available base units, indexed by unit dimension.{\line}The array values are the base unit names.}\par
\f0\pard\sb180\shading1000{\fs30\b GetConstants() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of current constants.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of available constants, indexed by constant name with (description).{\line}The array values are the constant values.}\par
\f0\pard\sb180\shading1000{\fs30\b GetDerivedUnits() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of current derived units.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of available derived units, indexed by unit name with (description).{\line}The array values are the base (or derived units) used for conversion.}\par
\f0\pard\sb180\shading1000{\fs30\b GetDimensions(unit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of dimensions for a unit.}\par
\f0\pard\sb75{\fs24\b unit}\par
\f0\pard{\fs20 The unit to get dimensins of.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array indexed by dimension and value of the dimension power or "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetErrors() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of error messages if a Convert fails or conflicts are found for added units or constants.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Array of error messages or "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetPrefixes() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a list of current prefixes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of available prefices, indexed by prefix name.{\line}The array value is the prefix value.}\par
\f0\pard\sb180\shading1000{\fs30\b Import() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Import a unit system from a file (units.txt in the current program folder).}\par
\f0\pard\sb300\shading2000{\fs36\b LDUtilities}\par
\f0\pard{\fs20 General }\par

\f0\pard\sb180\shading1000{\fs30\b CleanTemp() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Delete all Small Basic related files from the temp folder.{\line}These are files with extensions tmp, pdb and dll.{\line}Other applications may also use these, so best to use with no other apps running.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number of files deleted.}\par
\f0\pard\sb180\shading1000{\fs30\b ColourList() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of available colour names.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of colour names.}\par
\f0\pard\sb180\shading1000{\fs30\b CSVDeliminator \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 A single character deliminator for reading and writing CSV files{\line}Default ","}\par
\f0\pard\sb180\shading1000{\fs30\b CurrentCulture \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or set the current culture.}\par
\f0\pard\sb180\shading1000{\fs30\b DPIX \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the display device X DPI (dots per inch) resolution.}\par
\f0\pard\sb180\shading1000{\fs30\b DPIY \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the display device Y DPI (dots per inch) resolution.}\par
\f0\pard\sb180\shading1000{\fs30\b FixFlickr() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Fix the Flickr object (Version 1.0).}\par
\f0\pard\sb180\shading1000{\fs30\b FontList() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of available font names.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of font names.}\par
\f0\pard\sb180\shading1000{\fs30\b ForceInvoke \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Experimental option to speed some interactions with SmallBasicLibrary objects.{\line}0 no force (default), 1 force Invoke (serial), 2 force BeginInvoke (async)}\par
\f0\pard\sb180\shading1000{\fs30\b GetCultureInvariantNumber(input) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a number expressed in the culture invariant form.{\line}A number must be culture invariant in order to be treated as a number in calculations.{\line}A current culture number is how it is input or output.{\line}For example "3.14" is culture invariant, while "3,14" is French culture.}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 A number expressed in the current culture.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number expressed in culture invariant form or input on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b GetCurrentCultureNumber(input) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get a number expressed in the current culture.{\line}A number must be culture invariant in order to be treated as a number in calculations.{\line}A current culture number is how it is input or output.{\line}For example "3.14" is culture invariant, while "3,14" is French culture.}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 A culture invariant number.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The number expressed in the current culture or input on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b GetNextMapIndex(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the next integer for object names.{\line}For example Buttons are labeled "Button1", "Button2" etc.{\line}This method returns the integer index that would be used for the next object added.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 The map (list) type, valid listNames (Case sensitive) are:{\line}"Button"{\line}"TextBox"{\line}"ImageList"{\line}"Ellipse"{\line}"Image"{\line}"Line"{\line}"Rectangle"{\line}"Text"{\line}"Triangle"{\line}"Polygon"{\line}"Control"}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The next object index to be used (0 on failure).}\par
\f0\pard\sb180\shading1000{\fs30\b IsNumber(input) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Test if the input will be treated by SmallBasic as a number.{\line}This is a culture invariant number, e.g. "3.14", but not "3,14" or "24x".}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 The input to test.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" or "False"}\par
\f0\pard\sb180\shading1000{\fs30\b KeyDown(key) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get if a key is down.{\line}Useful for simplified keyboard game control.}\par
\f0\pard\sb75{\fs24\b key}\par
\f0\pard{\fs20 The key to get down state, eg "Space".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The key down state ("True" or "False")}\par
\f0\pard\sb180\shading1000{\fs30\b NetworkURL \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the web address for use with LDNetwork if gamedata and highscore methods are handled on another server.}\par
\f0\pard\sb180\shading1000{\fs30\b Priority \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Experimental option to speed some dispatcher interactions with SmallBasicLibrary objects.{\line}1 to 10, (default 7, Render)}\par
\f0\pard\sb180\shading1000{\fs30\b SendClick(x,y,button) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Send a mouse click at the specified screen location.  Note this is Mouse.MouseX/Y, not GraphicsWindow.MouseX/Y.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 The screen x position to click, -1 uses current mouse position.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The screen y position to click, -1 uses current mouse position.}\par
\f0\pard\sb75{\fs24\b button}\par
\f0\pard{\fs20 The button to press ("Left", "Right" or "Middle")}\par
\f0\pard\sb180\shading1000{\fs30\b ShowErrors \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Report any detected errors to TextWindow "True" (default) or "False"}\par
\f0\pard\sb180\shading1000{\fs30\b ShowFileErrors \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Report any detected file not found errors to TextWindow "True" (default) or "False"}\par
\f0\pard\sb180\shading1000{\fs30\b ShowNoShapeErrors \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Report any detected shapeName not found in method "True" (default) or "False"}\par
\f0\pard\sb180\shading1000{\fs30\b ShowPrintPreview \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Show the print preview window when printing with LDGraphicsWindow.Print and LDTextWindow.Print ("True" or "False"){\line}Default "True"}\par
\f0\pard\sb180\shading1000{\fs30\b UseDispatcher \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Experimental option to speed some interactions with SmallBasicLibrary objects.{\line}"True" (default) or "False"}\par
\f0\pard\sb180\shading1000{\fs30\b UseExpression \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Experimental option to speed some interactions with SmallBasicLibrary objects.{\line}"True" (default) or "False"}\par
\f0\pard\sb180\shading1000{\fs30\b Version() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gets the current version of the extension and displays a window with this information and a changelog.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The current version.}\par
\f0\pard\sb300\shading2000{\fs36\b LDVector}\par
\f0\pard{\fs20 3D vector algebra methods, useful for LD3DView manipulations.{\line}All vectors or points are a 3 element array indexed by 1,2,3.}\par

\f0\pard\sb180\shading1000{\fs30\b Add(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add 2 vectors.}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 The first vector.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 The second vector.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The resulting vector or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b AngleBetween(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the angle between 2 vectors.}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 The first vector.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 The second vector.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The angle (in degrees) between the vectors or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b CrossProduct(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the vector cross product of 2 vectors.}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 The first vector.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 The second vector.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The vector cross product or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b DotProduct(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the dot product of 2 vectors.}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 The first vector.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 The second vector.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The dot product or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Length(vector) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the length of a vector.}\par
\f0\pard\sb75{\fs24\b vector}\par
\f0\pard{\fs20 The vector.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The vector length or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Multiply(vector,scalar) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Multiply a vector by a scalar.}\par
\f0\pard\sb75{\fs24\b vector}\par
\f0\pard{\fs20 The vector.}\par
\f0\pard\sb75{\fs24\b scalar}\par
\f0\pard{\fs20 A scalar number to resize the vector.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The rescaled vector or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Normalise(vector) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Normalise a vector to unit length.}\par
\f0\pard\sb75{\fs24\b vector}\par
\f0\pard{\fs20 The vector.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A rescaled vector of unit length or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(vector,about,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotate one vector about a direction defined by a second vector.}\par
\f0\pard\sb75{\fs24\b vector}\par
\f0\pard{\fs20 The vector to rotate.}\par
\f0\pard\sb75{\fs24\b about}\par
\f0\pard{\fs20 The vector axis direction to rotate about.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle (in degrees) to rotate the vector by.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The rotated vector or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b RotatePoint(point,center,about,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotate a point about a specified center point and direction.}\par
\f0\pard\sb75{\fs24\b point}\par
\f0\pard{\fs20 The point to rotate.}\par
\f0\pard\sb75{\fs24\b center}\par
\f0\pard{\fs20 The point to rotate about.}\par
\f0\pard\sb75{\fs24\b about}\par
\f0\pard{\fs20 The vector axis direction to rotate about.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 The angle (in degrees) to rotate the point by.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The rotated point or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Subtract(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Subtract one vector from another.}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 The first vector.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 The second vector (to subtract from the first).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The resulting vector or "" on failure.}\par
\f0\pard\sb300\shading2000{\fs36\b LDWaveForm}\par
\f0\pard{\fs20 Create PPM (Pulse Position Modulation) sound signals to control RC (remote control) devices.{\line}See http://blogs.msdn.com/b/smallbasic/archive/2014/05/10/smallbasic-pulse-position-modulation-extension.aspx.{\line}Additonally create simple sound waveforms, which can be played asynchronously at the same time.{\line}{\line}SlimDX runtme for .Net 4.0 requires to be installed before this object can be used (http://slimdx.org/download.php).}\par

\f0\pard\sb180\shading1000{\fs30\b Amplitude \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Signal amplitude (maximum is 2^15 = 32768, default is 20262).}\par
\f0\pard\sb180\shading1000{\fs30\b Async \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play the sound asynchronously (return before sound completes), "True" or "False" default.}\par
\f0\pard\sb180\shading1000{\fs30\b Loop \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Continuously loop the sound, "True" or "False" default.{\line}Lopping sounds can be stopped by calling Stop method as they are playing.}\par
\f0\pard\sb180\shading1000{\fs30\b Pan \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The left (-100) to right (100) stereo panning, (default 0).}\par
\f0\pard\sb180\shading1000{\fs30\b PlayDX7(channels) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play DX7.}\par
\f0\pard\sb75{\fs24\b channels}\par
\f0\pard{\fs20 An array of values for each channel (values between 0 and 1, usually 8 channels).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The wave name or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b PlayHarmonics(frequency,duration,harmonics) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play a user defined wave form as a sum of harmonics.}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 Frequency (HZ).}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Duration (ms).  If this is negative then the waveform is repeated (-duration) times.}\par
\f0\pard\sb75{\fs24\b harmonics}\par
\f0\pard{\fs20 Harmonic amplitudes.{\line}This is an array, where the index is a harmonic multiple of the base frequency (2, 3, etc) and the value is the relative amplitude of the harmonic.{\line}A square wave can be formed by (https://en.wikipedia.org/wiki/Square_wave):{\line}For i = 3 To 21 Step 2{\line}  harmonics[i] = 1/i{\line}EndFor{\line}squareWave = LDWaveForm.PlayHarmonics(256,1000,harmonics)}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The wave name or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b PlaySineWave(frequency,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play a Sine wave form.}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 Frequency (HZ).}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Duration (ms).  If this is negative then the waveform is repeated (-duration) times.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The wave name or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b PlaySquareWave(frequency,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play a square wave form.}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 Frequency (HZ).}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Duration (ms).  If this is negative then the waveform is repeated (-duration) times.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The wave name or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b PlayWave(frequency,duration,waveform) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play a user defined wave form.}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 Frequency (HZ).}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Duration (ms).  If this is negative then the waveform is repeated (-duration) times.}\par
\f0\pard\sb75{\fs24\b waveform}\par
\f0\pard{\fs20 Form for the repeating wave.{\line}This is an array, where the index is an increasing relative time (the actual value is normalised to the frequency) and the value is an amplitude (-1 to 1).{\line}Example of a triangular wave would be "0=-1;1=1;2=-1;"}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The wave name or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b PlayWavFile(fileName,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Play a wav file.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The *.wav file.}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Duration (ms).  If this is negative then the waveform is repeated (-duration) times.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The wave name or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b Stop(waveName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stop a playing sound.}\par
\f0\pard\sb75{\fs24\b waveName}\par
\f0\pard{\fs20 The sound wave name.}\par
\f0\pard\sb180\shading1000{\fs30\b Volume \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The volume to play the waveform (0 to 100).}\par
\f0\pard\sb300\shading2000{\fs36\b LDWebCam}\par
\f0\pard{\fs20 Provides access to a webcam.}\par

\f0\pard\sb180\shading1000{\fs30\b Effect \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The current effect.{\line}Can be set using the Effect properties.{\line}(e.g. LDWebCam.Effect = LDWebCam.EffectGray).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBlocks \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectBulge \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectContrast \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectCyan \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectFishEye \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectFuzzy \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectGamma \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectGray \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectHue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectInverse \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectJagged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectLightness \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectMagenta \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectNone \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectOilPaint \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectParameter \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Effect parameter - see LDImage effects for the parameter values for effects.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectPixelate \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectPosterise \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectRed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectReflect \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectRotate \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectSaturation \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectSnow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectSwirl \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b EffectYellow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b End() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 End the webcam display, call this before removing the webcam shape.}\par
\f0\pard\sb180\shading1000{\fs30\b Interval \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 The webcam update minimim delay between updates in ms (default 20).{\line}It will in practice be larger in many cases, especialyy with effects set.}\par
\f0\pard\sb180\shading1000{\fs30\b Pause() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pause the webcam updates.}\par
\f0\pard\sb180\shading1000{\fs30\b PreWin8Mode \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Use pre-Windows 8 method.{\line}"True" or "False" (default).}\par
\f0\pard\sb180\shading1000{\fs30\b Resume() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Resume the webcam updates.}\par
\f0\pard\sb180\shading1000{\fs30\b Snapshot() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Take a snapshot and save it as a jpg with a SaveAs dialog.}\par
\f0\pard\sb180\shading1000{\fs30\b SnapshotToFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Take a snapshot and save it to a file.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 File to save jpg snapshot to.}\par
\f0\pard\sb180\shading1000{\fs30\b SnapshotToImageList() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Take a snapshot and save it to the ImageList (memory loaded image).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Returns the name of the image that was loaded.}\par
\f0\pard\sb180\shading1000{\fs30\b Start(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Start a webcam display object (SmallBasic shape).  If this is called more than once, multiple copies af the same webcam image are be generated.{\line}{\line}This object can be moved, zommed, rotated etc using the standard Shapes methods.{\line}{\line}Maximum resolution usually at 640 x 480 pixels, smaller may be faster.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 The width of the webcam display object.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 The height of the webcam display object.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The name of the webcam display object.}\par
\f0\pard\sb300\shading2000{\fs36\b LDWindows}\par
\f0\pard{\fs20 Create additional GraphicsWindows.{\line}{\line}All variables are shared between windows (global scope).{\line}GraphicsWindow events must be registered for each window, but the event subroutine can be shared.{\line}All other events can be registered once as normal.{\line}All commands or methods apply to the current active window, set using CurrentID.{\line}The original or default GraphicsWindow has id 0.}\par

\f0\pard\sb180\shading1000{\fs30\b Activated \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Event when a window is activated.{\line}Use this event with care - not recommended for most cases.}\par
\f0\pard\sb180\shading1000{\fs30\b Active \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or set the id of a window active state (top most).{\line}-1 if no active windows.}\par
\f0\pard\sb180\shading1000{\fs30\b Create() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Create a new GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An id for the created window.}\par
\f0\pard\sb180\shading1000{\fs30\b CurrentID \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get or set the current window id.}\par
\f0\pard\sb180\shading1000{\fs30\b LastActivated \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Last window activated.}\par
\f0\pard\sb300\shading2000{\fs36\b LDxml}\par
\f0\pard{\fs20 xml file parsing methods.}\par

\f0\pard\sb180\shading1000{\fs30\b AddNode(name,attributes,text,location) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Add a new node.{\line}The current node is unchanged, it is not updated to be the new node.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The new node element name.}\par
\f0\pard\sb75{\fs24\b attributes}\par
\f0\pard{\fs20 An array of attributes (values indexed by attribute name) for the new node or "".}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Inner text for the new node or "".}\par
\f0\pard\sb75{\fs24\b location}\par
\f0\pard{\fs20 Where the node is inserted.{\line}"Append" - insert at the end of current node's child nodes.{\line}"Prepend" - insert at the start of current node's child nodes.{\line}"Before" - insert before the current node.{\line}"After" - insert after the current node.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Attributes \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get an array of attribute text values indexed by attribute name or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b AttributesCount \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the number of attributes of the current node.}\par
\f0\pard\sb180\shading1000{\fs30\b ChildrenCount \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the number of children of the current node.}\par
\f0\pard\sb180\shading1000{\fs30\b FirstChild() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move the current node to the first child node if there is one.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b FirstNode() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Set the current node to the first document node.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b FromArray(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Performs the inverse function of ToArray method, create an xml document from an array definition.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 A Small Basic array with the correct format.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A name for the document or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b LastChild() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move the current node to the last child node if there is one.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b NextSibling() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move the current node to the next sibling node if there is one.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b NodeInnerText \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the inner text of the current node and all children or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b NodeName \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the name of the current node or "" on failure.}\par
\f0\pard\sb180\shading1000{\fs30\b NodeType \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Get the type of the current node.{\line}May be one of many types, but commonly "Element" or "Text".}\par
\f0\pard\sb180\shading1000{\fs30\b Open(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Open an existing xml file.  This must be called before any other methods can be used.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to the xml file to open.{\line}If this is "", then a new empty xml document is created.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A name for the document or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Parent() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move the current node to the parent node if there is one.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b PreviousSibling() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Move the current node to the previous sibling node if there is one.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveNode() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove the current node and all child nodes.{\line}The current node is reset to the previous sibling or parent node if no previous sibling exists.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 The new current node "SIBLING", "PARENT" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b RenameRoot(name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rename the root element (default is "root").}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 The name of the root element.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Save(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Save the current xml document to a file.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 The full path to the file to write the xml.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Switch(docName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Switch to another open xml document.  The current node for all documents are preserved.}\par
\f0\pard\sb75{\fs24\b docName}\par
\f0\pard{\fs20 The name returned by Open method.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ToArray() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Convert the current xml document to a Small Basic array.{\line}The structure and depth of the array may be quite complex.{\line}Each node has optional arrays "Attributes", and "Children" or "Data".{\line}If there are are child nodes then they are indexed first by number to deliminate multiple children with the same name.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 A Small Basic array or "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b View() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 View XML for dubugging purposes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 None.}\par
\f0\pard\sb300\shading2000{\fs36\b LDZip}\par
\f0\pard{\fs20 Zip file compression utilities.}\par

\f0\pard\sb180\shading1000{\fs30\b Remove(zipFile,files) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Remove a file (or directory with all sub files) from an existing zip archive.}\par
\f0\pard\sb75{\fs24\b zipFile}\par
\f0\pard{\fs20 The zip archive to remove a file from.}\par
\f0\pard\sb75{\fs24\b files}\par
\f0\pard{\fs20 An array of files to remove from the zip archive.{\line}A single file or directory may also be deleted.{\line}Any directories will be recursively removed from the zip.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An error message or "".}\par
\f0\pard\sb180\shading1000{\fs30\b UnZip(zipFile,directory) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Uncompress a zip archive.}\par
\f0\pard\sb75{\fs24\b zipFile}\par
\f0\pard{\fs20 The zip archive to uncompress.}\par
\f0\pard\sb75{\fs24\b directory}\par
\f0\pard{\fs20 A directory to uncompress the files to (existing files will be overwritten).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An error message or "".}\par
\f0\pard\sb180\shading1000{\fs30\b Zip(zipFile,files) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Compress files to a zip archive.}\par
\f0\pard\sb75{\fs24\b zipFile}\par
\f0\pard{\fs20 The zip archive file to create.}\par
\f0\pard\sb75{\fs24\b files}\par
\f0\pard{\fs20 An array of files to append to the zip archive.{\line}A single file or directory may also be set.{\line}Any directories will be recursively added to the zip.{\line}Any white space in files or directories will be replaced with "_".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An error message or "".}\par
\f0\pard\sb180\shading1000{\fs30\b ZipList(zipFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 List the files in a zip archive.}\par
\f0\pard\sb75{\fs24\b zipFile}\par
\f0\pard{\fs20 The zip archive.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 An array of file names in the zip or an error message.}\par
}
