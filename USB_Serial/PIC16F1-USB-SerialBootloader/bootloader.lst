gpasm-1.5.0 #1285 (Sep 12 2016) bootloader.as   5-19-2018  11:20:15         PAGE  1


LOC    OBJECT CODE    LINE  SOURCE TEXT
  VALUE

                      00001 ; vim:noet:sw=8:ts=8:ai:syn=pic
                      00002 ;
                      00003 ; USB 512-Word CDC Bootloader for PIC16(L)F1454/5/9
                      00004 ; Copyright (c) 2015, Matt Sarnoff (msarnoff.org)
                      00005 ; v1.0, February 12, 2015
                      00006 ; Released under a 3-clause BSD license: see the accompanying LICENSE file.
                      00007 ;
                      00008 ; Bootloader is entered if the MCLR/RA3 pin is grounded at power-up or reset,
                      00009 ; or if there is no application programmed. (The internal pull-up is used,
                      00010 ; no external resistor is necessary.)
                      00011 ;
                      00012 ; To be detected as a valid application, the lower 8 bytes of the first
                      00013 ; instruction word must NOT be 0xFF.
                      00014 ;
                      00015 ; At application start, the device is configured with a 48MHz CPU clock,
                      00016 ; using the internal oscillator and 3x PLL. If a different oscillator
                      00017 ; configuration is required, it must be set by the application.
                      00018 ;
                      00019 ; A serial number between 0 and 65535 should be specified during the build
                      00020 ; by using the gpasm -D argument to set the SERIAL_NUMBER symbol, e.g.
                      00021 ;   gpasm -D SERIAL_NUMBER=12345
                      00022 ; If not specified, it will default to zero.
                      00023 ; A host may not behave correctly if multiple PICs with the same serial number
                      00024 ; are connected simultaneously.
                      00025 ;
                      00026 ; Code notes:
                      00027 ; - Labels that do not begin with an underscore can be called as functions.
                      00028 ;   Labels that begin with an underscore are not safe to call, they should only
                      00029 ;   be reached via goto.
                      00030 ;
                      00031 ; - FSR0L, FSR0H, FSR1L, and FSR1H are used as temporary registers in several
                      00032 ;   places, e.g. as loop counters. They're accessible regardless of the current
                      00033 ;   bank, and automatically saved/restored on interrupt. Neato!
                      00034 ;
                      00035 ; - As much stuff as possible is packed into bank 0 of RAM. This includes the
                      00036 ;   buffer descriptors, bootloader state, endpoint 0 OUT and IN buffers,
                      00037 ;   the endpoint 1 IN buffer (only a single byte is used), and the beginning of
                      00038 ;   the 64-byte endpoint 1 OUT buffer.
                      00039 ;
                      00040 ; - Notification endpoint 2 is enabled, but never used. The endpoint 2 IN
                      00041 ;   buffer descriptor is left uninitialized. The endpoint 2 OUT buffer
                      00042 ;   descriptor is used as 4 bytes of RAM.
                      00043 ;
                      00044 ; - The programming protocol is described in the 'usb16f1prog' script. It is
                      00045 ;   very minimal, but does provide checksum verification. Writing the ID words
                      00046 ;   (0x8000-8003) is not supported at this time, and writing the configuration
                      00047 ;   words is not possible via self-programming.
                      00048 
                      00049 ; With logging enabled, the bootloader will not fit in 512 words.
                      00050 ; Use this only for debugging!
                      00051 ; For more info, see log_macros.inc and log.asm.
                      00052 
  00000000            00053 LOGGING_ENABLED   equ 0
gpasm-1.5.0 #1285 (Sep 12 2016) bootloader.as   5-19-2018  11:20:15         PAGE  2


LOC    OBJECT CODE    LINE  SOURCE TEXT
  VALUE

                      00054 ; Overdrive data in descriptor by app
  00000000            00055 ENABLE_POWER_CONFIG equ 0
                      00056 
                      00057 ;USE_RA3_SWITCH and USE_RC3_SWITCH and USE_RC5_SWITCH are all mutually exclusive, 0 or 1
                      00058 
                      00059 
                      00060 ; Bootloader switch definition RA3
  00000000            00061 USE_RA3_SWITCH    equ 0
                      00062 ; Bootloader switch definition RC3 (external pull-up need for this pin)
  00000000            00063 USE_RC3_SWITCH    equ 0
                      00064 ; Bootloader switch definition RC5 (external pull-up need for this pin)
  00000001            00065 USE_RC5_SWITCH    equ 1
                      00066 
                      00067 
                      00068 
                      00069   radix dec
                      00070   list n=0,st=off
                      00071   include "p16f1454.inc"
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ; Build date : Aug 13 2015
                      00005 ;  MPASM PIC16F1454 processor include
                      00006 ; 
                      00007 ;  (c) Copyright 1999-2015 Microchip Technology, All rights reserved
                      00008 ;==========================================================================
                      00009 
                      01044         LIST
                      00078   list
                      00079   errorlevel -302
                      00080 
                      00081 
                      00082 
                      00083 ;;; Configuration
                      00084   if LOGGING_ENABLED
                      00085 WRT_CONFIG    equ _WRT_HALF
                      00086   else
  00003FFE            00087 WRT_CONFIG    equ _WRT_BOOT
                      00088   endif
                      00089 
                      00090 #if USE_RA3_SWITCH
                      00091   __config _CONFIG1, _FOSC_INTOSC & _WDTE_SWDTEN & _PWRTE_ON & _MCLRE_OFF & _CP_OFF & _BOREN_ON & _IESO_
                            OFF & _FCMEN_OFF
                      00092 #else
8007   0FCC           00093   __config _CONFIG1, _FOSC_INTOSC & _WDTE_SWDTEN & _PWRTE_ON & _MCLRE_ON & _CP_OFF & _BOREN_ON & _IESO_O
                            FF & _FCMEN_OFF
                      00094 #endif
                      00095 
8008   1FCE           00096   __config _CONFIG2, WRT_CONFIG & _CPUDIV_NOCLKDIV & _USBLSCLK_48MHz & _PLLMULT_3x & _PLLEN_ENABLED & _S
                            TVREN_ON & _BORV_LO & _LVP_OFF
                      00097 
                      00098 
                      00099 
                      00100 ;;; Constants and varaiable addresses
  00000004            00101 SERIAL_NUMBER_DIGIT_CNT equ 4
                      00102   ifndef SERIAL_NUMBER
  0000                00103   variable SERIAL_NUMBER=0  ; Why doesnt 'equ' work here? Go figure
                      00104   endif
                      00105 
                      00106 ; I plan to apply for an Openmoko Product ID: the current product ID is temporary.
                      00107 ; If your organization has its own vendor ID/product ID, substitute it here.
                      00108 ; The Openmoko vendor/product ID cannot be used in closed-source/non-open-hardware
                      00109 ; projects: see http://wiki.openmoko.org/wiki/USB_Product_IDs
  000004D8            00110 USB_VENDOR_ID   equ 0x04D8
  0000000A            00111 USB_PRODUCT_ID    equ 0x000A  ; to be filled in once I obtain a product ID
                      00112 
  00000012            00113 DEVICE_DESC_LEN   equ 18  ; device descriptor length
  00000043            00114 CONFIG_DESC_TOTAL_LEN equ 67  ; total length of configuration descriptor and sub-descriptors
  0000000A            00115 SERIAL_NUM_DESC_LEN equ 2+(SERIAL_NUMBER_DIGIT_CNT*2)
  0000005F            00116 ALL_DESCS_TOTAL_LEN equ DEVICE_DESC_LEN+CONFIG_DESC_TOTAL_LEN+SERIAL_NUM_DESC_LEN
                      00117 
  00000008            00118 EP0_BUF_SIZE    equ 8 ; endpoint 0 buffer size
  00000040            00119 EP1_OUT_BUF_SIZE  equ 64  ; endpoint 1 OUT (CDC data) buffer size
  00000001            00120 EP1_IN_BUF_SIZE   equ 1 ; endpoint 1 IN (CDC data) buffer size (only need 1 byte to return status codes)
  00000001            00121 EP2_IN_BUF_SIZE   equ 1 ; endpoint 2 IN (CDC data) buffer size
                      00122 
                      00123 ; Since we're only using 5 endpoints, use the BDT area for buffers,
                      00124 ; and use the 4 bytes normally occupied by the EP2 OUT buffer descriptor for variables.
  00000030            00125 USB_STATE   equ BANKED_EP2OUT+0
  00000031            00126 EP0_DATA_IN_PTR   equ BANKED_EP2OUT+1 ; pointer to descriptor to be sent (low byte only)
  00000032            00127 EP0_DATA_IN_COUNT equ BANKED_EP2OUT+2 ; remaining bytes to be sent
  00000033            00128 APP_POWER_CONFIG  equ BANKED_EP2OUT+3 ; application power config byte
  00002018            00129 EP0OUT_BUF    equ EP3OUT
  00000038            00130 BANKED_EP0OUT_BUF equ BANKED_EP3OUT ; buffers go immediately after EP2 IN's buffer descriptor
  00002020            00131 EP0IN_BUF   equ EP0OUT_BUF+EP0_BUF_SIZE
  00000040            00132 BANKED_EP0IN_BUF  equ BANKED_EP0OUT_BUF+EP0_BUF_SIZE
                      00133 
                      00134 ; Use another byte to store the checksum we use to verify writes
  00000001            00135 EXTRA_VARS_LEN    equ 1
  00000048            00136 EXPECTED_CHECKSUM equ BANKED_EP0IN_BUF+EP0_BUF_SIZE ; for saving expected checksum
                      00137 
  00002029            00138 EP1IN_BUF   equ EP0IN_BUF+EP0_BUF_SIZE+EXTRA_VARS_LEN
  00000049            00139 BANKED_EP1IN_BUF  equ BANKED_EP0IN_BUF+EP0_BUF_SIZE+EXTRA_VARS_LEN
                      00140 
  0000202A            00141 EP1OUT_BUF    equ EP1IN_BUF+EP1_IN_BUF_SIZE ; only use 1 byte for EP1 IN
  0000004A            00142 BANKED_EP1OUT_BUF equ BANKED_EP1IN_BUF+EP1_IN_BUF_SIZE
                      00143 
  0000206A            00144 EP2IN_BUF   equ EP1OUT_BUF+EP1_OUT_BUF_SIZE ; only use 1 byte for EP2 IN
  0000008A            00145 BANKED_EP2IN_BUF  equ BANKED_EP1OUT_BUF+EP1_OUT_BUF_SIZE
                      00146 
                      00147 ; High byte of all endpoint buffers.
  00000020            00148 EPBUF_ADRH    equ (EP0OUT_BUF>>8)
                      00149   if ((EP0IN_BUF>>8) != (EP0OUT_BUF>>8)) || ((EP1OUT_BUF>>8) != (EP0OUT_BUF>>8)) || ((EP1IN_BUF>>8) != (
                            EP0OUT_BUF>>8))
                      00150   error "Endpoint buffers must be in the same 256-word region"
                      00151   endif
                      00152 
                      00153 ; Total length of all RAM (variables, buffers, BDT entries) used by the bootloader,
  0000006A            00154 USED_RAM_LEN    equ EP1OUT_BUF+EP1_OUT_BUF_SIZE-BDT_START
                      00155 
                      00156   if LOGGING_ENABLED
                      00157 BOOTLOADER_SIZE   equ 0x1000
                      00158   else
  00000200            00159 BOOTLOADER_SIZE   equ 0x200
                      00160   endif
                      00161 
                      00162 ; Application code locations
  00000200            00163 APP_ENTRY_POINT   equ BOOTLOADER_SIZE
  00000202            00164 APP_CONFIG    equ BOOTLOADER_SIZE+2
  00000204            00165 APP_INTERRUPT   equ BOOTLOADER_SIZE+4
                      00166 
                      00167 ; USB_STATE bit flags
  00000000            00168 IS_CONTROL_WRITE  equ 0 ; current endpoint 0 transaction is a control write
  00000001            00169 ADDRESS_PENDING   equ 1 ; need to set address in next IN transaction
  00000002            00170 DEVICE_CONFIGURED equ 2 ; the device is configured
                      00171 
                      00172 
                      00173 
                      00174 ;;; Vectors
0000                  00175   org 0x0000
0000                  00176 RESET_VECT
                      00177 ; Enable weak pull-ups
                      00178 #if USE_RA3_SWITCH
                      00179   banksel OPTION_REG
                      00180   bcf OPTION_REG,NOT_WPUEN
                      00181 #endif
0000   0021           00182   banksel OSCCON
0001   290E           00183   goto  bootloader_start  ; to be continued further down in the file
                      00184 
0004                  00185   org 0x0004
0004                  00186 INTERRUPT_VECT
0004   3182           00187   movlp high APP_INTERRUPT  ; XC8 *expects* this
0005   2A04           00188   goto  APP_INTERRUPT
                      00189 
                      00190 
                      00191 ;;; Handles a control transfer on endpoint 0.
                      00192 ;;; arguments:  expects USTAT value in FSR1H
                      00193 ;;;   BSR=0
                      00194 ;;; returns:  none
                      00195 ;;; clobbers: W, FSR1H
0006                  00196 usb_service_ep0
0006   1907           00197   btfsc FSR1H,DIR ; is it an IN transfer or an OUT/SETUP?
0007   286E           00198   goto  _usb_ctrl_in
                      00199 ; it's an OUT or SETUP transfer
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0008   0820           00200   movfw BANKED_EP0OUT_STAT
0009   393C           00201   andlw b'00111100' ; isolate PID bits
000A   3C34           00202   sublw PID_SETUP ; is it a SETUP packet?
000B   1D03 2828      00203   bnz arm_ep0_out ; if not, it's a regular OUT, just rearm the buffer
                      00204   ; it's a SETUP packet--fall through
                      00205 
                      00206 ; Handles a SETUP control transfer on endpoint 0.
                      00207 ; BSR=0
000D                  00208 _usb_ctrl_setup
000D   1030           00209   bcf USB_STATE,IS_CONTROL_WRITE
                      00210 ; get bmRequestType, but don't bother checking whether it's standard/class/vendor...
                      00211 ; the CDC and standard requests we'll receive have distinct bRequest numbers
000E   13A0           00212   bcf BANKED_EP0OUT_STAT,UOWN ; dearm the OUT endpoint
000F   13A4           00213   bcf BANKED_EP0IN_STAT,UOWN  ; dearm the IN endpoint
                      00214 
0010   0838           00215   movfw BANKED_EP0OUT_BUF+bmRequestType
0011   1FB8           00216   btfss BANKED_EP0OUT_BUF+bmRequestType,7 ; is this host->device?
0012   1430           00217   bsf USB_STATE,IS_CONTROL_WRITE    ; if so, this is a control write
                      00218 ; check request number: is it Get Descriptor?
0013   3006           00219   movlw GET_DESCRIPTOR
0014   0239           00220   subwf BANKED_EP0OUT_BUF+bRequest,w
0015   1903 283E      00221   bz  _usb_get_descriptor
                      00222 ; is it Set Address?
0017   3005           00223   movlw SET_ADDRESS
0018   0239           00224   subwf BANKED_EP0OUT_BUF+bRequest,w
0019   1903 285F      00225   bz  _usb_set_address
                      00226 ; is it Set_Configuration?
001B   3009           00227   movlw SET_CONFIG
001C   0239           00228   subwf BANKED_EP0OUT_BUF+bRequest,w
001D   1903 2861      00229   bz  _usb_set_configuration
                      00230 ; is it Get Configuration?
001F   3008           00231   movlw GET_CONFIG
0020   0239           00232   subwf BANKED_EP0OUT_BUF+bRequest,w
0021   1903 2867      00233   bz  _usb_get_configuration
                      00234 ; unhandled request? fall through to _usb_ctrl_invalid
                      00235 
                      00236 ; Finishes a rejected SETUP transaction: the endpoints are stalled
0023                  00237 _usb_ctrl_invalid
0023   003D           00238   banksel UCON
0024   120E           00239   bcf UCON,PKTDIS ; reenable packet processing
0025   0020           00240   banksel BANKED_EP0IN_STAT
0026   300C           00241   movlw _DAT0|_DTSEN|_BSTALL
0027   2037           00242   call  arm_ep0_in_with_flags
0028                  00243 arm_ep0_out
0028   300C           00244   movlw _DAT0|_DTSEN|_BSTALL
0029                  00245 arm_ep0_out_with_flags      ; W specifies STAT flags
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0029   00A0           00246   movwf BANKED_EP0OUT_STAT
002A   3008           00247   movlw EP0_BUF_SIZE    ; reset the buffer count
002B   00A1           00248   movwf BANKED_EP0OUT_CNT
002C   17A0           00249   bsf BANKED_EP0OUT_STAT,UOWN ; arm the OUT endpoint
002D   0008           00250   return
                      00251 
                      00252 ; Finishes a successful SETUP transaction.
002E                  00253 _usb_ctrl_complete
002E   003D           00254   banksel UCON
002F   120E           00255   bcf UCON,PKTDIS   ; reenable packet processing
0030   0020           00256   banksel USB_STATE
0031   1830           00257   btfsc USB_STATE,IS_CONTROL_WRITE
0032   283A           00258   goto  _cwrite
                      00259 ; this is a control read; prepare the IN endpoint for the data stage
                      00260 ; and the OUT endpoint for the status stage
0033   207C           00261 _cread  call  ep0_read_in   ; read data into IN buffer
0034   3048           00262   movlw _DAT1|_DTSEN    ; OUT buffer will be ready for status stage
                      00263 ; value in W is used to specify the EP0 OUT flags
0035   2029           00264 _armbfs call  arm_ep0_out_with_flags
0036   3048           00265   movlw _DAT1|_DTSEN    ; arm IN buffer
0037                  00266 arm_ep0_in_with_flags     ; W specifies STAT flags
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0037   00A4           00267   movwf BANKED_EP0IN_STAT
0038   17A4           00268   bsf BANKED_EP0IN_STAT,UOWN
0039   0008           00269   return
                      00270 ; this is a control write: prepare the IN endpoint for the status stage
                      00271 ; and the OUT endpoint for the next SETUP transaction
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
003A   13A4           00272 _cwrite bcf BANKED_EP0IN_STAT,UOWN  ; ensure we have ownership of the buffer
003B   01A5           00273   clrf  BANKED_EP0IN_CNT  ; we'll be sending a zero-length packet
003C   300C           00274   movlw _DAT0|_DTSEN|_BSTALL  ; make OUT buffer ready for next SETUP packet
003D   2835           00275   goto  _armbfs     ; arm OUT and IN buffers
                      00276 
                      00277 
                      00278 
                      00279 ; Handles a Get Descriptor request.
                      00280 ; BSR=0
003E                  00281 _usb_get_descriptor
                      00282 ; check descriptor type
003E   3002           00283   movlw DESC_CONFIG
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
003F   023B           00284   subwf BANKED_EP0OUT_BUF+wValueH,w
0040   1903 284E      00285   bz  _config_descriptor
0042   3003           00286   movlw DESC_STRING
0043   023B           00287   subwf BANKED_EP0OUT_BUF+wValueH,w
0044   1903 2852      00288   bz  _string_descriptor
0046   3001           00289   movlw DESC_DEVICE
0047   023B           00290   subwf BANKED_EP0OUT_BUF+wValueH,w
0048   1D03 2823      00291   bnz _usb_ctrl_invalid
004A                  00292 _device_descriptor
004A   30A1           00293   movlw low DEVICE_DESCRIPTOR
004B   00B1           00294   movwf EP0_DATA_IN_PTR
004C   3012           00295   movlw DEVICE_DESC_LEN
004D   2855           00296   goto  _set_data_in_count_from_w
004E                  00297 _config_descriptor
004E   30B3           00298   movlw low CONFIGURATION_DESCRIPTOR
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
004F   00B1           00299   movwf EP0_DATA_IN_PTR
0050   3043           00300   movlw CONFIG_DESC_TOTAL_LEN ; length includes all subordinate descriptors
0051   2855           00301   goto  _set_data_in_count_from_w
0052                  00302 _string_descriptor
                      00303 ; only one string descriptor (serial number) is supported,
                      00304 ; so don't bother checking wValueL
0052   30F6           00305   movlw low SERIAL_NUMBER_STRING_DESCRIPTOR
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0053   00B1           00306   movwf EP0_DATA_IN_PTR
0054   300A           00307   movlw SERIAL_NUM_DESC_LEN
0055                  00308 _set_data_in_count_from_w
0055   00B2           00309   movwf EP0_DATA_IN_COUNT
                      00310 ; the count needs to be set to the minimum of the descriptor's length (in W)
                      00311 ; and the requested length
0056   08BF           00312   tstf  BANKED_EP0OUT_BUF+wLengthH  ; test high byte...
0057   1D03 282E      00313   bnz _usb_ctrl_complete    ; use length of descriptor
                      00314 
0059   023E           00315   subwf BANKED_EP0OUT_BUF+wLengthL,w
005A   1803 282E      00316   bc  _usb_ctrl_complete    ; if W <= f, no need to adjust
005C   083E           00317   movfw BANKED_EP0OUT_BUF+wLengthL
005D   00B2           00318   movwf EP0_DATA_IN_COUNT
005E   282E           00319   goto  _usb_ctrl_complete
                      00320 
                      00321 ; Handles a Set Address request.
                      00322 ; The address is actually set in the IN status stage.
005F                  00323 _usb_set_address
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
005F   14B0           00324   bsf USB_STATE,ADDRESS_PENDING ; address will be assigned in the status stage
0060   282E           00325   goto  _usb_ctrl_complete
                      00326 
                      00327 ; Handles a Set Configuration request.
                      00328 ; For now just accept any nonzero configuration.
                      00329 ; BSR=0
0061                  00330 _usb_set_configuration
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0061   1130           00331   bcf USB_STATE,DEVICE_CONFIGURED ; temporarily clear flag
0062   08BA           00332   tstf  BANKED_EP0OUT_BUF+wValueL ; anything other than 0 is valid
0063   1D03           00333   skpz
0064   1530           00334   bsf USB_STATE,DEVICE_CONFIGURED
0065   2096           00335   call  cdc_init
0066   282E           00336   goto  _usb_ctrl_complete
                      00337 
                      00338 ; Handles a Get Configuration request.
                      00339 ; BSR=0
0067                  00340 _usb_get_configuration
                      00341 ; load a pointer to either a 0 or a 1 in ROM
                      00342 ; the 0 and 1 have been chosen so that they are adjacent
0067   30BF           00343   movlw low CONFIGURATION_0_CONSTANT
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0068   1930           00344   btfsc USB_STATE,DEVICE_CONFIGURED
                      00345   incw
0069   3E01               M         addlw   1
006A   00B1           00346   movwf EP0_DATA_IN_PTR
006B   3001           00347   movlw 1
006C   00B2           00348   movwf EP0_DATA_IN_COUNT
006D   282E           00349   goto  _usb_ctrl_complete
                      00350 
                      00351 ; Handles an IN control transfer on endpoint 0.
                      00352 ; BSR=0
006E                  00353 _usb_ctrl_in
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
006E   1830           00354   btfsc USB_STATE,IS_CONTROL_WRITE  ; is this a control read or write?
006F   2875           00355   goto  _check_for_pending_address
                      00356 ; fetch more data and re-arm the IN endpoint
0070   207C           00357   call  ep0_read_in
0071   3008           00358   movlw _DTSEN
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0072   1F24           00359   btfss BANKED_EP0IN_STAT,DTS ; toggle DTS
0073   1709           00360   bsf WREG,DTS
0074   2837           00361   goto  arm_ep0_in_with_flags ; arm the IN buffer
                      00362 
                      00363 ; if this is the status stage of a Set Address request, assign the address here.
                      00364 ; The OUT buffer has already been armed for the next SETUP.
0075                  00365 _check_for_pending_address
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0075   1CB0           00366   btfss USB_STATE,ADDRESS_PENDING
0076   0008           00367   return
                      00368 ; read the address out of the setup packed in the OUT buffer
0077   10B0           00369   bcf USB_STATE,ADDRESS_PENDING
0078   083A           00370   movfw BANKED_EP0OUT_BUF+wValueL
0079   003D           00371   banksel UADDR
007A   0096           00372   movwf UADDR
007B   0008           00373   return
                      00374 
                      00375 
                      00376 
                      00377 ;;; Reads descriptor data from EP0_DATA_IN_PTR, copies it to the EP0 IN buffer,
                      00378 ;;; and decrements EP0_DATA_IN_COUNT.
                      00379 ;;; arguments:  BSR=0
                      00380 ;;; returns:  EP0_DATA_IN_PTRL advanced
                      00381 ;;;   EP0_DATA_IN_COUNT decremented
                      00382 ;;; clobbers: W, FSR0, FSR1
007C                  00383 ep0_read_in
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
007C   13A4           00384   bcf BANKED_EP0IN_STAT,UOWN  ; make sure we have ownership of the buffer
007D   01A5           00385   clrf  BANKED_EP0IN_CNT  ; initialize buffer size to 0
007E   08B2           00386   tstf  EP0_DATA_IN_COUNT ; do nothing if there are 0 bytes to send
                      00387   retz
007F   1903               M         skpnz
0080   0008               M         return
0081   0831           00388   movfw EP0_DATA_IN_PTR   ; set up source pointer
0082   0084           00389   movwf FSR0L
0083   3081           00390   movlw DESCRIPTOR_ADRH|0x80
0084   0085           00391   movwf FSR0H
                      00392   ldfsr1d EP0IN_BUF   ; set up destination pointer
0085   3020               M         movlw   low EP0IN_BUF
0086   0086               M         movwf   FSR1L
0087   3020               M         movlw   (high EP0IN_BUF) & 0x7F
0088   0087               M         movwf   FSR1H
0089   0103           00393   clrw
                      00394 ; byte copy loop
008A   3C08           00395 _bcopy  sublw EP0_BUF_SIZE    ; have we filled the buffer?
008B   1903 2893      00396   bz  _bcdone
008D   0012           00397   moviw FSR0++
008E   001E           00398   movwi FSR1++
008F   0AA5           00399   incf  BANKED_EP0IN_CNT,f  ; increase number of bytes copied
0090   0825           00400   movfw BANKED_EP0IN_CNT  ; save to test on the next iteration
0091   0BB2           00401   decfsz  EP0_DATA_IN_COUNT,f ; decrement number of bytes remaining
0092   288A           00402   goto  _bcopy
                      00403 ; write back the updated source pointer
0093   0804           00404 _bcdone movfw FSR0L
0094   00B1           00405   movwf EP0_DATA_IN_PTR
                      00406 
                      00407 #if ENABLE_POWER_CONFIG
                      00408 ; if we're sending the configuration descriptor, we need to inject the app's
                      00409 ; values for bus power/self power and max current consumption
                      00410 _check_for_config_bmattributes
                      00411   movlw (low CONFIGURATION_DESCRIPTOR)+EP0_BUF_SIZE
                      00412   subwf FSR0L,w
                      00413   bnz _check_for_config_bmaxpower
                      00414 ; if we're sending the first 8 bytes of the configuration descriptor,
                      00415 ; set bit 6 of bmAttributes if the application is self-powered
                      00416   btfsc APP_POWER_CONFIG,0
                      00417   bsf BANKED_EP0IN_BUF+7,6
                      00418   return
                      00419 _check_for_config_bmaxpower
                      00420   movlw (low CONFIGURATION_DESCRIPTOR)+(EP0_BUF_SIZE*2)
                      00421   subwf FSR0L,w
                      00422   retnz
                      00423 ; if we're sending the second 8 bytes of the configuration descriptor,
                      00424 ; replace bMaxPower with the app's value
                      00425   movfw APP_POWER_CONFIG
                      00426   bcf WREG,0      ; value is in the upper 7 bits
                      00427   movwf BANKED_EP0IN_BUF+0
                      00428 #endif
0095   0008           00429   return
                      00430 
                      00431 
                      00432 
                      00433 ;;; Initializes the buffers for the CDC endpoints (1 OUT, 1 IN, and 2 IN).
                      00434 ;;; arguments:  none
                      00435 ;;; returns:  none
                      00436 ;;; clobbers: W, BSR=0
0096                  00437 cdc_init
0096   0020           00438   banksel BANKED_EP1OUT_STAT
0097   20AD           00439   call  arm_ep1_out
                      00440   ; arm EP1 IN buffer, clearing data toggle bit
0098   0103           00441   clrw
                      00442 
                      00443 ; arms endpoint 1 IN, toggling DTS if W=(1<<DTS)
0099                  00444 arm_ep1_in
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0099   01AD           00445   clrf  BANKED_EP1IN_CNT  ; next packet will have 0 length (unless another OUT is received)
009A   05AC           00446   andwf BANKED_EP1IN_STAT,f ; clear all bits (except DTS if bit is set in W)
009B   06AC           00447   xorwf BANKED_EP1IN_STAT,f ; update data toggle (if bit is set in W)
009C   17AC           00448   bsf BANKED_EP1IN_STAT,UOWN
009D   0008           00449   return
                      00450 
                      00451 
                      00452 
                      00453 ;;; Services a transaction on one of the CDC endpoints.
                      00454 ;;; arguments:  USTAT value in FSR1H
                      00455 ;;;   BSR=0
                      00456 ;;; returns:  none
                      00457 ;;; clobbers: W, FSR0, FSR1
009E                  00458 usb_service_cdc
009E   3040           00459   movlw (1<<DTS)
                      00460   retbfs  FSR1H,ENDP1   ; ignore endpoint 2
009F   1A07               M         btfsc   FSR1H,ENDP1
00A0   0008               M         return
                      00461   bbfs  FSR1H,DIR,arm_ep1_in  ; if endpoint 1 IN, rearm buffer
00A1   1907               M         btfsc   FSR1H,DIR
00A2   2899               M         goto    arm_ep1_in
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00A3   08A9           00462   movf  BANKED_EP1OUT_CNT,f ; test for a zero-length packet
00A4   1903 28AD      00463   bz  arm_ep1_out   ; (just ignore them and rearm the OUT buffer)
00A6   13AC           00464   bcf BANKED_EP1IN_STAT,UOWN
00A7   20B2           00465   call  bootloader_exec_cmd ; execute command; status returned in W
                      00466 
00A8   0020           00467   banksel BANKED_EP1IN_BUF
00A9   00C9           00468   movwf BANKED_EP1IN_BUF  ; copy status to IN buffer
00AA   3001           00469   movlw 1
00AB   00AD           00470   movwf BANKED_EP1IN_CNT  ; output byte count is 1
00AC   17AC           00471   bsf BANKED_EP1IN_STAT,UOWN
                      00472   ; fall through to arm_ep1_out
                      00473 
00AD                  00474 arm_ep1_out
00AD   3040           00475   movlw EP1_OUT_BUF_SIZE  ; set CNT
00AE   00A9           00476   movwf BANKED_EP1OUT_CNT
00AF   01A8           00477   clrf  BANKED_EP1OUT_STAT  ; ignore data toggle
00B0   17A8           00478   bsf BANKED_EP1OUT_STAT,UOWN ; rearm OUT buffer
00B1   0008           00479   return
                      00480 
                      00481 
                      00482 
                      00483 ;;; Executes a bootloader command.
                      00484 ;;; arguments:  command payload in EP1 OUT buffer
                      00485 ;;;     BSR=0
                      00486 ;;; returns:  status code in W
                      00487 ;;; clobbers: W, BSR, FSR0, FSR1
00B2                  00488 bootloader_exec_cmd
                      00489 ; check length of data packet
00B2   3004           00490   movlw BCMD_SET_PARAMS_LEN
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00B3   0229           00491   subwf BANKED_EP1OUT_CNT,w
00B4   1903 28C4      00492   bz  _bootloader_set_params
00B6   3040           00493   movlw BCMD_WRITE_LEN
00B7   0229           00494   subwf BANKED_EP1OUT_CNT,w
00B8   1903 28D8      00495   bz  _bootloader_write
00BA   3001           00496   movlw BCMD_RESET_LEN
00BB   0229           00497   subwf BANKED_EP1OUT_CNT,w
00BC   1903 28BF      00498   bz  _bootloader_reset
00BE   3402           00499   retlw BSTAT_INVALID_COMMAND
                      00500 
                      00501 ; Resets the device if the received byte matches the reset character.
00BF                  00502 _bootloader_reset
00BF   3052           00503   movlw BCMD_RESET_CHAR
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00C0   024A           00504   subwf BANKED_EP1OUT_BUF,w ; check received character
00C1   1D03           00505   skpz
00C2   3402           00506   retlw BSTAT_INVALID_COMMAND
                      00507 ; command is valid, reset the device
00C3   0001           00508   reset
                      00509 
                      00510 ; Sets the write address, expected checksum of the next 32 words,
                      00511 ; and erases the row at that address if the last byte of the command matches
                      00512 ; the "erase" character.
                      00513 ; BSR=0
00C4                  00514 _bootloader_set_params
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00C4   084C           00515   movfw BANKED_EP1OUT_BUF+BCMD_SET_PARAMS_CKSUM ; expected checksum
00C5   00C8           00516   movwf EXPECTED_CHECKSUM     ; save for verification during write command
00C6   084D           00517   movfw BANKED_EP1OUT_BUF+BCMD_SET_PARAMS_ERASE
00C7   0086           00518   movwf FSR1L ; temp
00C8   084A           00519   movfw BANKED_EP1OUT_BUF+BCMD_SET_PARAMS_ADRL  ; address lower bits
00C9   0087           00520   movwf FSR1H ; temp
00CA   084B           00521   movfw BANKED_EP1OUT_BUF+BCMD_SET_PARAMS_ADRH  ; address upper bits
00CB   0023           00522   banksel PMADRH
00CC   0092           00523   movwf PMADRH
00CD   0807           00524   movfw FSR1H ; bring lower bits out of temp
00CE   0091           00525   movwf PMADRL
                      00526 ; do we need to erase?
00CF   3045           00527   movlw BCMD_ERASE_CHAR
00D0   0206           00528   subwf FSR1L,w
00D1   1D03           00529   skpz
00D2   3401           00530   retlw BSTAT_OK  ; if no reset command is given, return OK
                      00531 
                      00532 ; Erases the row of flash in PMADRH:PMADRL.
                      00533 ; BSR=3
00D3                  00534 _bootloader_erase
00D3   3014           00535   movlw (1<<FREE)|(1<<WREN) ; enable write and erase to program memory
00D4   0095           00536   movwf PMCON1
00D5   2106           00537   call  flash_unlock    ; stalls until erase finishes
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
00D6   1115           00538 _wdone  bcf PMCON1,WREN   ; clear write enable flag
00D7   3401           00539   retlw BSTAT_OK
                      00540 
                      00541 ; Verifies that the checksum of the 32 words (64 bytes) in the EP1 OUT buffer
                      00542 ; matches the previously sent value. If so, the 32 bytes are then written to
                      00543 ; flash memory at the address in PMADRH:PMADRL. (set by a prior command)
                      00544 ; BSR=0
00D8                  00545 _bootloader_write
                      00546 ; The expected checksum is the two's complement of the sum of the bytes.
                      00547 ; If the data is valid, we can add the checksum to the sum of the bytes and
                      00548 ; the result will be 0. We initialize a temporary register with the expected
                      00549 ; checksum, and then add each byte to it as it's processed.
                      00550 ; If the value in the temp register is 0 after all 64 bytes have been copied
                      00551 ; to the write latches, proceed with the write.
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00D8   0848           00552   movfw EXPECTED_CHECKSUM
00D9   0086           00553   movwf FSR1L     ; use a temp for the running checksum
                      00554   ldfsr0d EP1OUT_BUF    ; set up read pointer
00DA   302A               M         movlw   low EP1OUT_BUF
00DB   0084               M         movwf   FSR0L
00DC   3020               M         movlw   (high EP1OUT_BUF) & 0x7F
00DD   0085               M         movwf   FSR0H
00DE   3024           00555   movlw (1<<LWLO)|(1<<WREN) ; write to latches only
00DF   0023           00556   banksel PMCON1
00E0   0095           00557   movwf PMCON1
                      00558 ; simultaneously compute the checksum of the 32 words and copy them to the
                      00559 ; write latches
00E1   3020           00560   movlw 32      ; number of words to write minus 1
00E2   0087           00561   movwf FSR1H     ; used for loop count
00E3   0012           00562 _wloop  moviw FSR0++      ; load lower byte
00E4   0786           00563   addwf FSR1L,f     ; add lower byte to checksum
00E5   0093           00564   movwf PMDATL      ; copy to write latch
00E6   0012           00565   moviw FSR0++      ; load upper byte
00E7   0786           00566   addwf FSR1L,f     ; add upper byte to checksum
00E8   0094           00567   movwf PMDATH      ; copy to write latch
                      00568 ; after writing the 32nd word to PMDATH:PMDATL, don't execute the unlock sequence
                      00569 ; or advance the address pointer!
00E9   0387           00570   decf  FSR1H,f     ; decrement loop count
00EA   1903 28EF      00571   bz  _wcksum     ; if 0, we're done writing to the latches
                      00572 ; still have more words to go
00EC   2106           00573   call  flash_unlock    ; execute unlock sequence
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
00ED   0A91           00574   incf  PMADRL,f    ; increment write address
00EE   28E3           00575   goto  _wloop
                      00576 ; verify the checksum
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
00EF   0195           00577 _wcksum clrf  PMCON1
00F0   0886           00578   tstf  FSR1L
00F1   1D03           00579   skpz
00F2   3403           00580   retlw BSTAT_INVALID_CHECKSUM  ; if there's a mismatch, abort the write
                      00581 ; checksum is valid, write the data
00F3   1515           00582   bsf PMCON1,WREN
00F4   2106           00583   call  flash_unlock    ; stalls until write finishes
                      00584 ; verify the write: compare each byte in the buffer to its counterpart that
                      00585 ; was just written to flash.
                      00586 ; we do this backwards so we don't waste instructions resetting the pointers.
                      00587 ; (note: PMADRH:PMADRL is already pointing at the last written word, but FSR0
                      00588 ; is pointing to one byte past the end of the buffer)
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
00F5   0195           00589   clrf  PMCON1      ; clear write enable
00F6   1687           00590   bsf FSR1H,5     ; set loop count to 32 (just need to set one bit because it's already 0)
00F7   1415           00591 _vloop  bsf PMCON1,RD   ; read word from flash
00F8   0000           00592   nop       ; 2 required nops
00F9   0000           00593   nop
00FA   0011           00594   moviw --FSR0      ; get high byte of expected word
00FB   0214           00595   subwf PMDATH,w    ; compare with high byte written to flash
00FC   1D03           00596   skpz
00FD   3404           00597   retlw BSTAT_VERIFY_FAILED
00FE   0011           00598   moviw --FSR0      ; get low byte of expected word
00FF   0213           00599   subwf PMDATL,w    ; compare with low byte written to flash
0100   1D03           00600   skpz
0101   3404           00601   retlw BSTAT_VERIFY_FAILED
0102   0391           00602   decf  PMADRL,f    ; decrement read address
0103   0B87           00603   decfsz  FSR1H,f     ; decrement loop count
0104   28F7           00604   goto  _vloop
0105   3401           00605   retlw BSTAT_OK
                      00606 
                      00607 
                      00608 ;;; Executes the flash unlock sequence, performing an erase or write.
                      00609 ;;; arguments:  PMCON1 bits CFGS, LWLO, FREE and WREN set appropriately
                      00610 ;;;   BSR=3
                      00611 ;;; returns:  none
                      00612 ;;; clobbers: W
0106                  00613 flash_unlock
0106   3055           00614   movlw 0x55
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
0107   0096           00615   movwf PMCON2
0108   30AA           00616   movlw 0xAA
0109   0096           00617   movwf PMCON2
010A   1495           00618   bsf PMCON1,WR
010B   0000           00619   nop
010C   0000           00620   nop
010D   0008           00621 ret return
                      00622 
                      00623 
                      00624 
                      00625 ;;; Main function
                      00626 ;;; BSR=1 (OSCCON bank)
010E                  00627 bootloader_start
                      00628 ; Configure the oscillator (48MHz from INTOSC using 3x PLL)
010E   30FC           00629   movlw (1<<SPLLEN)|(1<<SPLLMULT)|(1<<IRCF3)|(1<<IRCF2)|(1<<IRCF1)|(1<<IRCF0)
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 1 from now on.
010F   0099           00630   movwf OSCCON
                      00631 
                      00632 ; Wait for the oscillator and PLL to stabilize
0110   3051           00633 _wosc movlw (1<<PLLRDY)|(1<<HFIOFR)|(1<<HFIOFS)
0111   051A           00634   andwf OSCSTAT,w
0112   3C51           00635   sublw (1<<PLLRDY)|(1<<HFIOFR)|(1<<HFIOFS)
0113   1D03 2910      00636   bnz _wosc
                      00637 
                      00638 ; Check for valid application code: the lower 8 bits of the first word cannot be 0xFF
0115   213E           00639   call  app_is_present
0116   1903 2921      00640   bz  _bootloader_main  ; if we have no application, enter bootloader mode
                      00641 
                      00642 ; We have a valid application? Check if the entry pin is grounded
                      00643 
                      00644 
                      00645 #if USE_RC3_SWITCH
                      00646   banksel ANSELC        ;disable analog function on pin
                      00647   bcf   ANSELC,ANSC3
                      00648 
                      00649   banksel PORTC
                      00650   btfss PORTC,RC3
                      00651   goto  _bootloader_main  ; enter bootloader mode if input is low
                      00652 #endif
                      00653 
                      00654 
                      00655 #if USE_RC5_SWITCH
0118   0023           00656   banksel ANSELC        ;disable analog function on pin
Error[113]  : Symbol not previously defined: "ANSC5"
0119   100E           00657   bcf   ANSELC,ANSC5
                      00658 
011A   0020           00659   banksel PORTC
011B   1E8E           00660   btfss PORTC,RC5
011C   2921           00661   goto  _bootloader_main  ; enter bootloader mode if input is low
                      00662 #endif
                      00663 
                      00664 
                      00665 #if USE_RA3_SWITCH
                      00666   banksel PORTA
                      00667   btfss PORTA,RA3
                      00668   goto  _bootloader_main  ; enter bootloader mode if input is low
                      00669 
                      00670 ; We have a valid application and the entry pin is high. Start the application.
                      00671   banksel OPTION_REG
                      00672   bsf OPTION_REG,NOT_WPUEN  ; but first, disable weak pullups
                      00673 #endif
                      00674 
                      00675 #if USE_RC3_SWITCH
                      00676   banksel ANSELC        ;enable analog function on pin
                      00677   bsf   ANSELC,ANSC3
                      00678 #endif
                      00679 
                      00680 #if USE_RC5_SWITCH
011D   0023           00681   banksel ANSELC        ;enable analog function on pin
Error[113]  : Symbol not previously defined: "ANSC5"
011E   140E           00682   bsf   ANSELC,ANSC5
                      00683 #endif
                      00684 
                      00685 
011F   3182           00686   movlp high APP_ENTRY_POINT  ; attempt to appease certain user apps
0120   2A00           00687   goto  APP_ENTRY_POINT
                      00688 
                      00689 
                      00690 ; Not entering application code: initialize the USB interface and wait for commands.
0121                  00691 _bootloader_main
                      00692 ; Enable active clock tuning
                      00693 
                      00694   if LOGGING_ENABLED
                      00695   call  uart_init
                      00696 ; Print a power-on character
                      00697   call  log_init
                      00698   logch '^',LOG_NEWLINE
                      00699   endif
                      00700 
0121   3090           00701   movlw (1<<ACTSRC)|(1<<ACTEN)
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 7 from now on.
0122   009B           00702   movwf ACTCON    ; source = USB
                      00703 
                      00704 
                      00705 ; Initialize USB
0123   2144           00706   call  usb_init
                      00707 
                      00708 ; Attach to the bus (could be a subroutine, but inlining it saves 2 instructions)
0124                  00709 _usb_attach
                      00710   logch 'A',0
                          M         if      LOGGING_ENABLED
                          M         movlw   (((('A'-32) & b'00111111') | 0) & b'01111111')
                          M         call    log_single_byte
                          M         endif
0124   003D           00711   banksel UCON    ; reset UCON
0125   018E           00712   clrf  UCON
0126   003D           00713   banksel UCON    ; reset UCON
0127                  00714 _usben
0127   158E           00715   bsf UCON,USBEN    ; enable USB module and wait until ready
0128   1D8E           00716   btfss UCON,USBEN
0129   2927           00717   goto  _usben
                      00718   logch '!',LOG_NEWLINE
                          M         if      LOGGING_ENABLED
                          M         movlw   (((('!'-32) & b'00111111') | LOG_NEWLINE) & b'01111111')
                          M         call    log_single_byte
                          M         endif
                      00719 
                      00720 
                      00721 ;;; Idle loop. In bootloader mode, the MCU just spins here, and all USB
                      00722 ;;; communication is interrupt-driven.
                      00723 ;;; This snippet is deliberately located within the first 256 words of program
                      00724 ;;; memory, so we can easily check in the interrupt handler if the interrupt
                      00725 ;;; occurred while executing application code or bootloader code.
                      00726 ;;; (TOSH will be 0x00 when executing bootloader code, i.e. this snippet)
012A                  00727 bootloader_main_loop
                      00728 
                      00729   if LOGGING_ENABLED
                      00730 ; Print any pending characters in the log
                      00731   call  log_service
                      00732   endif
                      00733 
012A   003D           00734   banksel UIR
                      00735 ; reset?
012B   1C10           00736   btfss UIR,URSTIF
012C   2930           00737   goto  _utrans   ; not a reset? just start servicing transactions
012D   2144           00738   call  usb_init  ; if so, reset the USB interface (clears interrupts)
012E   003D           00739   banksel UIR
012F   1010           00740   bcf UIR,URSTIF  ; clear the flag
                      00741 ; service transactions
0130                  00742 _utrans
0130   003D           00743   banksel UIR
0131   1D90           00744   btfss UIR,TRNIF
0132   292A           00745   goto bootloader_main_loop
0133   080F           00746   movfw USTAT   ; stash the status in a temp register
0134   0087           00747   movwf FSR1H
0135   1190           00748   bcf UIR,TRNIF ; clear flag and advance USTAT fifo
                      00749 
0136   0020           00750   banksel BANKED_EP0OUT_STAT
0137   3978           00751   andlw b'01111000' ; check endpoint number
0138   1D03 293C      00752   bnz _ucdc   ; if not endpoint 0, it's a CDC message
013A   2006           00753   call  usb_service_ep0 ; handle the control message
013B   2930           00754   goto  _utrans
                      00755 
                      00756 
013C                  00757 _ucdc
013C   209E           00758   call  usb_service_cdc ; USTAT value is still in FSR1H
013D   2930           00759   goto  _utrans
                      00760 
                      00761 
                      00762 ;;; Determines if application code is present in flash memory.
                      00763 ;;; arguments:  none
                      00764 ;;; returns:  Z flag cleared if application code is present
                      00765 ;;; clobbers: W, FSR0
013E                  00766 app_is_present
013E   0184           00767   clrf  FSR0L
013F   3082           00768   movlw (high APP_ENTRY_POINT)|0x80 ; need to set high bit to indicate program memory
0140   0085           00769   movwf FSR0H
0141   3F00           00770   moviw 0[FSR0]
                      00771   incw        ; if W was 0xFF, it'll be 0 now
0142   3E01               M         addlw   1
0143   0008           00772   return        ; Z flag will be unset if app code is present
                      00773 
                      00774 
                      00775 
                      00776 #if ENABLE_POWER_CONFIG
                      00777 ;;; Gets the application's power config byte and stores it in APP_POWER_CONFIG.
                      00778 ;;; arguments:  none
                      00779 ;;; returns:  none
                      00780 ;;; clobbers: W, BSR, FSR0
                      00781 get_app_power_config
                      00782   banksel APP_POWER_CONFIG
                      00783   movlw 0x33      ; default value: bus-powered, max current 100 mA
                      00784   movwf APP_POWER_CONFIG
                      00785   call  app_is_present
                      00786   retz        ; if Z flag is set, we have no application, just return
                      00787   if LOGGING_ENABLED
                      00788   pagesel APP_CONFIG
                      00789   endif
                      00790   call  APP_CONFIG    ; config value returned in W
                      00791   pagesel get_app_power_config
                      00792   banksel APP_POWER_CONFIG
                      00793   movwf APP_POWER_CONFIG
                      00794   return
                      00795 #endif
                      00796 
                      00797 
                      00798 ;;; Initializes the USB system and resets all associated registers.
                      00799 ;;; arguments:  none
                      00800 ;;; returns:  none
                      00801 ;;; clobbers: W, BSR, FSR0, FSR1H
0144                  00802 usb_init
                      00803   logch 'R',LOG_NEWLINE
                          M         if      LOGGING_ENABLED
                          M         movlw   (((('R'-32) & b'00111111') | LOG_NEWLINE) & b'01111111')
                          M         call    log_single_byte
                          M         endif
                      00804 ; clear USB registers
0144   003D           00805   banksel UEIR
0145   0193           00806   clrf  UEIR
0146   0190           00807   clrf  UIR
                      00808 ; disable endpoints we won't use
0147   0199           00809   clrf  UEP1
0148   019A           00810   clrf  UEP2
0149   019B           00811   clrf  UEP3
014A   019C           00812   clrf  UEP4
014B   019D           00813   clrf  UEP5
014C   019E           00814   clrf  UEP6
014D   019F           00815   clrf  UEP7
                      00816 ; set configuration
014E   0197           00817   clrf  UEIE    ; don't need any error interrupts
014F   3014           00818   movlw (1<<UPUEN)|(1<<FSEN)
0150   0091           00819   movwf UCFG    ; enable pullups, full speed, no ping-pong buffering
0151   3009           00820   movlw (1<<TRNIE)|(1<<URSTIE)
0152   0092           00821   movwf UIE   ; only need interrupts for transaction complete and reset
                      00822 ; clear all BDT entries, variables, and buffers
0153   0184           00823   clrf  FSR0L
0154   3020           00824   movlw high BDT_START  ; BDT starts at 0x2000
0155   0085           00825   movwf FSR0H
0156   306A           00826   movlw USED_RAM_LEN
0157   0087           00827   movwf FSR1H   ; loop count
0158   3000           00828   movlw 0
0159   001A           00829 _ramclr movwi FSR0++
015A   0B87           00830   decfsz  FSR1H,f
015B   2959           00831   goto  _ramclr
                      00832 #if ENABLE_POWER_CONFIG
                      00833 ; get the app's power configuration (if it's present)
                      00834   call  get_app_power_config
                      00835 #endif
                      00836 ; reset ping-pong buffers and address
015C   003D           00837   banksel UCON
015D   170E           00838   bsf UCON,PPBRST
015E   0196           00839   clrf  UADDR
015F   120E           00840   bcf UCON,PKTDIS ; enable packet processing
0160   130E           00841   bcf UCON,PPBRST ; clear ping-pong buffer reset flag
                      00842 ; flush pending transactions
0161   1D90           00843 _tflush btfss UIR,TRNIF
0162   2966           00844   goto  _initep
0163   1190           00845   bcf UIR,TRNIF
0164   210D           00846   call  ret   ; need at least 6 cycles before checking TRNIF again
0165   2961           00847   goto  _tflush
                      00848 ; initialize endpoints:
                      00849 ; 0 for control
                      00850 ; 1 for CDC bulk data
                      00851 ; 2 for CDC notifications (though it's never actually used)
                      00852 ; my intuition was that I should wait until a SET_CONFIGURATION is received
                      00853 ; before setting up endpoints 1 and 2... but there seemed to be a timing issue
                      00854 ; when doing so, so I moved them here
0166                  00855 _initep
0166   3016           00856   movlw (1<<EPHSHK)|(1<<EPOUTEN)|(1<<EPINEN)
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 29 from now on.
0167   0098           00857   movwf UEP0
0168   301E           00858   movlw (1<<EPHSHK)|(1<<EPCONDIS)|(1<<EPOUTEN)|(1<<EPINEN)
0169   0099           00859   movwf UEP1
016A   301A           00860   movlw (1<<EPHSHK)|(1<<EPCONDIS)|(1<<EPINEN)
016B   009A           00861   movwf UEP2
                      00862 
                      00863 ; initialize endpoint buffers and counts
016C   0020           00864   banksel BANKED_EP0OUT_ADRL
016D   3018           00865   movlw low EP0OUT_BUF  ; set endpoint 0 OUT address low
016E   00A2           00866   movwf BANKED_EP0OUT_ADRL
016F   3020           00867   movlw low EP0IN_BUF ; set endpoint 0 IN address low
0170   00A6           00868   movwf BANKED_EP0IN_ADRL
0171   302A           00869   movlw low EP1OUT_BUF  ; set endpoint 1 OUT address low
0172   00AA           00870   movwf BANKED_EP1OUT_ADRL
0173   3029           00871   movlw low EP1IN_BUF ; set endpoint 1 IN address low
0174   00AE           00872   movwf BANKED_EP1IN_ADRL
0175   306A           00873   movlw low EP2IN_BUF ; set endpoint 2 IN address low
0176   00B6           00874   movwf BANKED_EP2IN_ADRL
0177   3020           00875   movlw EPBUF_ADRH  ; set all ADRH values
0178   00A3           00876   movwf BANKED_EP0OUT_ADRH
0179   00A7           00877   movwf BANKED_EP0IN_ADRH
017A   00AB           00878   movwf BANKED_EP1OUT_ADRH
017B   00AF           00879   movwf BANKED_EP1IN_ADRH
017C   00B7           00880   movwf BANKED_EP2IN_ADRH
                      00881 
017D   2828           00882   goto  arm_ep0_out
                      00883 
                      00884 
                      00885 
                      00886 ;;; Includes
                      00887   if LOGGING_ENABLED
                      00888   include "log.asm"
                      00889   endif
                      00890 
                      00891 
                      00892 
                      00893 ;;; Descriptors
                      00894 
                      00895 ; Place all the descriptors at the end of the bootloader region.
                      00896 ; This serves 2 purposes: 1) as long as the total length of all descriptors is
                      00897 ; less than 256, we can address them with an 8-bit pointer,
                      00898 ; and 2) the assembler will raise an error if space is exhausted.
01A1                  00899   org BOOTLOADER_SIZE-ALL_DESCS_TOTAL_LEN
  00000001            00900 DESCRIPTOR_ADRH equ high $
01A1                  00901 DEVICE_DESCRIPTOR
01A1   3412           00902   dt  DEVICE_DESC_LEN ; bLength
01A2   3401           00903   dt  0x01    ; bDescriptorType
01A3   3400 3402      00904   dt  0x00, 0x02  ; bcdUSB (USB 2.0)
01A5   3402           00905   dt  0x02    ; bDeviceClass (communication device)
01A6   3400           00906   dt  0x00    ; bDeviceSubclass
01A7   3400           00907   dt  0x00    ; bDeviceProtocol
01A8   3408           00908   dt  0x08    ; bMaxPacketSize0 (8 bytes)
01A9   34D8 3404      00909   dt  low USB_VENDOR_ID, high USB_VENDOR_ID ; idVendor
01AB   340A 3400      00910   dt  low USB_PRODUCT_ID, high USB_PRODUCT_ID ; idProduct
01AD   3401 3400      00911   dt  0x01, 0x00  ; bcdDevice (1)
01AF   3400           00912   dt  0x00    ; iManufacturer
01B0   3400           00913   dt  0x00    ; iProduct
01B1   3401           00914   dt  0x01    ; iSerialNumber
01B2   3401           00915   dt  0x01    ; bNumConfigurations
                      00916 
01B3                  00917 CONFIGURATION_DESCRIPTOR
01B3   3409           00918   dt  0x09    ; bLength
01B4   3402           00919   dt  0x02    ; bDescriptorType
01B5   3443 3400      00920   dt  CONFIG_DESC_TOTAL_LEN, 0x00 ; wTotalLength
01B7   3402           00921   dt  0x02    ; bNumInterfaces
01B8   3401           00922   dt  0x01    ; bConfigurationValue
01B9   3400           00923   dt  0x00    ; iConfiguration
01BA   3480           00924   dt  0x80    ; bmAttributes
01BB   3411           00925   dt  0x11    ; bMaxPower
                      00926 
01BC                  00927 INTERFACE_DESCRIPTOR_0
01BC   3409           00928   dt  0x09    ; bLength
01BD   3404           00929   dt  0x04    ; bDescriptorType (INTERFACE)
01BE   3400           00930   dt  0x00    ; bInterfaceNumber
01BF                  00931 CONFIGURATION_0_CONSTANT
01BF   3400           00932   dt  0x00    ; bAlternateSetting
01C0                  00933 CONFIGURATION_1_CONSTANT
01C0   3401           00934   dt  0x01    ; bNumEndpoints
01C1   3402           00935   dt  0x02    ; bInterfaceClass (communication)
01C2   3402           00936   dt  0x02    ; bInterfaceSubclass (abstract control model)
01C3   3401           00937   dt  0x01    ; bInterfaceProtocol (V.25ter, common AT commands)
01C4   3400           00938   dt  0x00    ; iInterface
                      00939 
                      00940   if (CONFIGURATION_0_CONSTANT>>8) != (CONFIGURATION_1_CONSTANT>>8)
                      00941   error "CONSTANT_0 and CONSTANT_1 must be in the same 256-word region"
                      00942   endif
                      00943 
01C5                  00944 HEADER_FUNCTIONAL_DESCRIPTOR
01C5   3405           00945   dt  0x05    ; bFunctionLength
01C6   3424           00946   dt  0x24    ; bDescriptorType (CS_INTERFACE)
01C7   3400           00947   dt  0x00    ; bDescriptorSubtype (header functional descriptor)
01C8   3410 3401      00948   dt  0x10,0x01 ; bcdCDC (specification version, 1.1)
                      00949 
01CA                  00950 ABSTRACT_CONTROL_MANAGEMENT_FUNCTIONAL_DESCRIPTOR
01CA   3404           00951   dt  0x04    ; bFunctionLength
01CB   3424           00952   dt  0x24    ; bDescriptorType (CS_INTERFACE)
01CC   3402           00953   dt  0x02    ; bDescriptorSubtype (abstract control management functional descriptor)
01CD   3402           00954   dt  0x02    ; bmCapabilities
                      00955 
01CE                  00956 UNION_FUNCTIONAL_DESCRIPTOR
01CE   3405           00957   dt  0x05    ; bFunctionLength
01CF   3424           00958   dt  0x24    ; bDescriptorType (CS_INTERFACE)
01D0   3406           00959   dt  0x06    ; bDescriptorSubtype (union functional descriptor)
01D1   3400           00960   dt  0x00    ; bMasterInterface
01D2   3401           00961   dt  0x01    ; bSlaveInterface0
                      00962 
01D3                  00963 CALL_MANAGEMENT_FUNCTIONAL_DESCRIPTOR
01D3   3405           00964   dt  0x05    ; bFunctionLength
01D4   3424           00965   dt  0x24    ; bDescriptorType (CS_INTERFACE)
01D5   3401           00966   dt  0x01    ; bDescriptorSubtype (call management functional descriptor)
01D6   3400           00967   dt  0x00    ; bmCapabilities (doesn't handle call management)
01D7   3401           00968   dt  0x01    ; dDataInterface
                      00969 
01D8                  00970 ENDPOINT_DESCRIPTOR_2_IN
01D8   3407           00971   dt  0x07    ; bLength
01D9   3405           00972   dt  0x05    ; bDescriptorType (ENDPOINT)
01DA   3482           00973   dt  0x82    ; bEndpointAddress (2 IN)
01DB   3403           00974   dt  0x03    ; bmAttributes (transfer type: interrupt)
01DC   3408 3400      00975   dt  0x08, 0x00  ; wMaxPacketSize (8)
01DE   347F           00976   dt  0x7f    ; bInterval
                      00977 
01DF                  00978 INTERFACE_DESCRIPTOR_1
01DF   3409           00979   dt  0x09    ; bLength
01E0   3404           00980   dt  0x04    ; bDescriptorType (INTERFACE)
01E1   3401           00981   dt  0x01    ; bInterfaceNumber
01E2   3400           00982   dt  0x00    ; bAlternateSetting
01E3   3402           00983   dt  0x02    ; bNumEndpoints
01E4   340A           00984   dt  0x0a    ; bInterfaceClass (data)
01E5   3400           00985   dt  0x00    ; bInterfaceSubclass
01E6   3400           00986   dt  0x00    ; bInterfaceProtocol
01E7   3400           00987   dt  0x00    ; iInterface
                      00988 
01E8                  00989 ENDPOINT_DESCRIPTOR_1_IN
01E8   3407           00990   dt  0x07    ; bLength
01E9   3405           00991   dt  0x05    ; bDescriptorType (ENDPOINT)
01EA   3481           00992   dt  0x81    ; bEndpointAddress (1 IN)
01EB   3402           00993   dt  0x02    ; bmAttributes (transfer type: bulk)
01EC   3440 3400      00994   dt  0x40, 0x00  ; wMaxPacketSize (64)
01EE   3400           00995   dt  0x00    ; bInterval
                      00996 
01EF                  00997 ENDPOINT_DESCRIPTOR_1_OUT
01EF   3407           00998   dt  0x07    ; bLength
01F0   3405           00999   dt  0x05    ; bDescriptorType (ENDPOINT)
01F1   3401           01000   dt  0x01    ; bEndpointAddress (1 OUT)
01F2   3402           01001   dt  0x02    ; bmAttributes (transfer type: bulk)
01F3   3440 3400      01002   dt  0x40, 0x00  ; wMaxPacketSize (64)
01F5   3400           01003   dt  0x00    ; bInterval
                      01004 
                      01005 ; extract nibbles from serial number
  00000000            01006 SN1 equ (SERIAL_NUMBER>>12) & 0xF
  00000000            01007 SN2 equ (SERIAL_NUMBER>>8) & 0xF
  00000000            01008 SN3 equ (SERIAL_NUMBER>>4) & 0xF
  00000000            01009 SN4 equ SERIAL_NUMBER & 0xF
                      01010 
01F6                  01011 SERIAL_NUMBER_STRING_DESCRIPTOR
01F6   340A           01012   dt  SERIAL_NUM_DESC_LEN ; bLength
01F7   3403           01013   dt  0x03    ; bDescriptorType (STRING)
01F8   3430 3400      01014   dt  '0'+SN1+((SN1>9)*7), 0x00 ; convert hex digits to ASCII
01FA   3430 3400      01015   dt  '0'+SN2+((SN2>9)*7), 0x00
01FC   3430 3400      01016   dt  '0'+SN3+((SN3>9)*7), 0x00
01FE   3430 3400      01017   dt  '0'+SN4+((SN4>9)*7), 0x00
                      01018 
                      01019 ; Raise an error if the descriptors aren't properly aligned. (This means you
                      01020 ; changed the descriptors withouth updating the definition of ALL_DESCS_TOTAL_LEN.)
                      01021   if $!=BOOTLOADER_SIZE
                      01022   error "Descriptors must be aligned with the end of the bootloader region"
                      01023   endif
                      01024 
                      01025   end
Error[181]  : Error generating hex file.
