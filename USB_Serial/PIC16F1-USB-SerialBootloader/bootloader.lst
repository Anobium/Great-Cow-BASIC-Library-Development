gpasm-1.5.0 #1285 (Sep 12 2016) bootloader.as   5-18-2018  16:55:10         PAGE  1


LOC    OBJECT CODE    LINE  SOURCE TEXT
  VALUE

                      00001 ; vim:noet:sw=8:ts=8:ai:syn=pic
                      00002 ;
                      00003 ; USB 512-Word CDC Bootloader for PIC16(L)F1454/5/9
                      00004 ; Copyright (c) 2015, Matt Sarnoff (msarnoff.org)
                      00005 ; v1.0, February 12, 2015
                      00006 ; Released under a 3-clause BSD license: see the accompanying LICENSE file.
                      00007 ;
                      00008 ; Bootloader is entered if the MCLR/RA3 pin is grounded at power-up or reset,
                      00009 ; or if there is no application programmed. (The internal pull-up is used,
                      00010 ; no external resistor is necessary.)
                      00011 ;
                      00012 ; To be detected as a valid application, the lower 8 bytes of the first
                      00013 ; instruction word must NOT be 0xFF.
                      00014 ;
                      00015 ; At application start, the device is configured with a 48MHz CPU clock,
                      00016 ; using the internal oscillator and 3x PLL. If a different oscillator
                      00017 ; configuration is required, it must be set by the application.
                      00018 ;
                      00019 ; A serial number between 0 and 65535 should be specified during the build
                      00020 ; by using the gpasm -D argument to set the SERIAL_NUMBER symbol, e.g.
                      00021 ;   gpasm -D SERIAL_NUMBER=12345
                      00022 ; If not specified, it will default to zero.
                      00023 ; A host may not behave correctly if multiple PICs with the same serial number
                      00024 ; are connected simultaneously.
                      00025 ;
                      00026 ; Code notes:
                      00027 ; - Labels that do not begin with an underscore can be called as functions.
                      00028 ;   Labels that begin with an underscore are not safe to call, they should only
                      00029 ;   be reached via goto.
                      00030 ;
                      00031 ; - FSR0L, FSR0H, FSR1L, and FSR1H are used as temporary registers in several
                      00032 ;   places, e.g. as loop counters. They're accessible regardless of the current
                      00033 ;   bank, and automatically saved/restored on interrupt. Neato!
                      00034 ;
                      00035 ; - As much stuff as possible is packed into bank 0 of RAM. This includes the
                      00036 ;   buffer descriptors, bootloader state, endpoint 0 OUT and IN buffers,
                      00037 ;   the endpoint 1 IN buffer (only a single byte is used), and the beginning of
                      00038 ;   the 64-byte endpoint 1 OUT buffer.
                      00039 ;
                      00040 ; - Notification endpoint 2 is enabled, but never used. The endpoint 2 IN
                      00041 ;   buffer descriptor is left uninitialized. The endpoint 2 OUT buffer
                      00042 ;   descriptor is used as 4 bytes of RAM.
                      00043 ;
                      00044 ; - The programming protocol is described in the 'usb16f1prog' script. It is
                      00045 ;   very minimal, but does provide checksum verification. Writing the ID words
                      00046 ;   (0x8000-8003) is not supported at this time, and writing the configuration
                      00047 ;   words is not possible via self-programming.
                      00048 
                      00049 ; With logging enabled, the bootloader will not fit in 512 words.
                      00050 ; Use this only for debugging!
                      00051 ; For more info, see log_macros.inc and log.asm.
                      00052 
  00000000            00053 LOGGING_ENABLED   equ 0
gpasm-1.5.0 #1285 (Sep 12 2016) bootloader.as   5-18-2018  16:55:10         PAGE  2


LOC    OBJECT CODE    LINE  SOURCE TEXT
  VALUE

                      00054 ; Overdrive data in descriptor by app
  00000000            00055 ENABLE_POWER_CONFIG equ 0
                      00056 
                      00057 ;USE_RA3_SWITCH and USE_RC3_SWITCH are mutually exclusive, 0 or 1
                      00058 ; Bootloader switch definition RA3
  00000001            00059 USE_RA3_SWITCH    equ 1
                      00060 ; Bootloader switch definition RC3 (external pull-up need for this pin)
  00000000            00061 USE_RC3_SWITCH    equ 0
                      00062 
                      00063   radix dec
                      00064   list n=0,st=off
                      00065   include "p16f1454.inc"
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ; Build date : Aug 13 2015
                      00005 ;  MPASM PIC16F1454 processor include
                      00006 ; 
                      00007 ;  (c) Copyright 1999-2015 Microchip Technology, All rights reserved
                      00008 ;==========================================================================
                      00009 
                      01044         LIST
                      00072   list
                      00073   errorlevel -302
                      00074 
                      00075 
                      00076 
                      00077 ;;; Configuration
                      00078   if LOGGING_ENABLED
                      00079 WRT_CONFIG    equ _WRT_HALF
                      00080   else
  00003FFE            00081 WRT_CONFIG    equ _WRT_BOOT
                      00082   endif
                      00083 
                      00084 #if USE_RA3_SWITCH
8007   0F8C           00085   __config _CONFIG1, _FOSC_INTOSC & _WDTE_SWDTEN & _PWRTE_ON & _MCLRE_OFF & _CP_OFF & _BOREN_ON & _IESO_
                            OFF & _FCMEN_OFF
                      00086 #else
                      00087   __config _CONFIG1, _FOSC_INTOSC & _WDTE_SWDTEN & _PWRTE_ON & _MCLRE_ON & _CP_OFF & _BOREN_ON & _IESO_O
                            FF & _FCMEN_OFF
                      00088 #endif
                      00089 
8008   1FCE           00090   __config _CONFIG2, WRT_CONFIG & _CPUDIV_NOCLKDIV & _USBLSCLK_48MHz & _PLLMULT_3x & _PLLEN_ENABLED & _S
                            TVREN_ON & _BORV_LO & _LVP_OFF
                      00091 
                      00092 
                      00093 
                      00094 ;;; Constants and varaiable addresses
  00000004            00095 SERIAL_NUMBER_DIGIT_CNT equ 4
                      00096   ifndef SERIAL_NUMBER
  0000                00097   variable SERIAL_NUMBER=0  ; Why doesnt 'equ' work here? Go figure
                      00098   endif
                      00099 
                      00100 ; I plan to apply for an Openmoko Product ID: the current product ID is temporary.
                      00101 ; If your organization has its own vendor ID/product ID, substitute it here.
                      00102 ; The Openmoko vendor/product ID cannot be used in closed-source/non-open-hardware
                      00103 ; projects: see http://wiki.openmoko.org/wiki/USB_Product_IDs
  00001D50            00104 USB_VENDOR_ID   equ 0x1D50
  0000EEEE            00105 USB_PRODUCT_ID    equ 0xEEEE  ; to be filled in once I obtain a product ID
                      00106 
  00000012            00107 DEVICE_DESC_LEN   equ 18  ; device descriptor length
  00000043            00108 CONFIG_DESC_TOTAL_LEN equ 67  ; total length of configuration descriptor and sub-descriptors
  0000000A            00109 SERIAL_NUM_DESC_LEN equ 2+(SERIAL_NUMBER_DIGIT_CNT*2)
  0000005F            00110 ALL_DESCS_TOTAL_LEN equ DEVICE_DESC_LEN+CONFIG_DESC_TOTAL_LEN+SERIAL_NUM_DESC_LEN
                      00111 
  00000008            00112 EP0_BUF_SIZE    equ 8 ; endpoint 0 buffer size
  00000040            00113 EP1_OUT_BUF_SIZE  equ 64  ; endpoint 1 OUT (CDC data) buffer size
  00000001            00114 EP1_IN_BUF_SIZE   equ 1 ; endpoint 1 IN (CDC data) buffer size (only need 1 byte to return status codes)
  00000001            00115 EP2_IN_BUF_SIZE   equ 1 ; endpoint 2 IN (CDC data) buffer size
                      00116 
                      00117 ; Since we're only using 5 endpoints, use the BDT area for buffers,
                      00118 ; and use the 4 bytes normally occupied by the EP2 OUT buffer descriptor for variables.
  00000030            00119 USB_STATE   equ BANKED_EP2OUT+0
  00000031            00120 EP0_DATA_IN_PTR   equ BANKED_EP2OUT+1 ; pointer to descriptor to be sent (low byte only)
  00000032            00121 EP0_DATA_IN_COUNT equ BANKED_EP2OUT+2 ; remaining bytes to be sent
  00000033            00122 APP_POWER_CONFIG  equ BANKED_EP2OUT+3 ; application power config byte
  00002018            00123 EP0OUT_BUF    equ EP3OUT
  00000038            00124 BANKED_EP0OUT_BUF equ BANKED_EP3OUT ; buffers go immediately after EP2 IN's buffer descriptor
  00002020            00125 EP0IN_BUF   equ EP0OUT_BUF+EP0_BUF_SIZE
  00000040            00126 BANKED_EP0IN_BUF  equ BANKED_EP0OUT_BUF+EP0_BUF_SIZE
                      00127 
                      00128 ; Use another byte to store the checksum we use to verify writes
  00000001            00129 EXTRA_VARS_LEN    equ 1
  00000048            00130 EXPECTED_CHECKSUM equ BANKED_EP0IN_BUF+EP0_BUF_SIZE ; for saving expected checksum
                      00131 
  00002029            00132 EP1IN_BUF   equ EP0IN_BUF+EP0_BUF_SIZE+EXTRA_VARS_LEN
  00000049            00133 BANKED_EP1IN_BUF  equ BANKED_EP0IN_BUF+EP0_BUF_SIZE+EXTRA_VARS_LEN
                      00134 
  0000202A            00135 EP1OUT_BUF    equ EP1IN_BUF+EP1_IN_BUF_SIZE ; only use 1 byte for EP1 IN
  0000004A            00136 BANKED_EP1OUT_BUF equ BANKED_EP1IN_BUF+EP1_IN_BUF_SIZE
                      00137 
  0000206A            00138 EP2IN_BUF   equ EP1OUT_BUF+EP1_OUT_BUF_SIZE ; only use 1 byte for EP2 IN
  0000008A            00139 BANKED_EP2IN_BUF  equ BANKED_EP1OUT_BUF+EP1_OUT_BUF_SIZE
                      00140 
                      00141 ; High byte of all endpoint buffers.
  00000020            00142 EPBUF_ADRH    equ (EP0OUT_BUF>>8)
                      00143   if ((EP0IN_BUF>>8) != (EP0OUT_BUF>>8)) || ((EP1OUT_BUF>>8) != (EP0OUT_BUF>>8)) || ((EP1IN_BUF>>8) != (
                            EP0OUT_BUF>>8))
                      00144   error "Endpoint buffers must be in the same 256-word region"
                      00145   endif
                      00146 
                      00147 ; Total length of all RAM (variables, buffers, BDT entries) used by the bootloader,
  0000006A            00148 USED_RAM_LEN    equ EP1OUT_BUF+EP1_OUT_BUF_SIZE-BDT_START
                      00149 
                      00150   if LOGGING_ENABLED
                      00151 BOOTLOADER_SIZE   equ 0x1000
                      00152   else
  00000200            00153 BOOTLOADER_SIZE   equ 0x200
                      00154   endif
                      00155 
                      00156 ; Application code locations
  00000200            00157 APP_ENTRY_POINT   equ BOOTLOADER_SIZE
  00000202            00158 APP_CONFIG    equ BOOTLOADER_SIZE+2
  00000204            00159 APP_INTERRUPT   equ BOOTLOADER_SIZE+4
                      00160 
                      00161 ; USB_STATE bit flags
  00000000            00162 IS_CONTROL_WRITE  equ 0 ; current endpoint 0 transaction is a control write
  00000001            00163 ADDRESS_PENDING   equ 1 ; need to set address in next IN transaction
  00000002            00164 DEVICE_CONFIGURED equ 2 ; the device is configured
                      00165 
                      00166 
                      00167 
                      00168 ;;; Vectors
0000                  00169   org 0x0000
0000                  00170 RESET_VECT
                      00171 ; Enable weak pull-ups
                      00172 #if USE_RA3_SWITCH
0000   0021           00173   banksel OPTION_REG
0001   1395           00174   bcf OPTION_REG,NOT_WPUEN
                      00175 #endif
0002   0021           00176   banksel OSCCON
0003   290E           00177   goto  bootloader_start  ; to be continued further down in the file
                      00178 
0004                  00179   org 0x0004
0004                  00180 INTERRUPT_VECT
0004   3182           00181   movlp high APP_INTERRUPT  ; XC8 *expects* this
0005   2A04           00182   goto  APP_INTERRUPT
                      00183 
                      00184 
                      00185 ;;; Handles a control transfer on endpoint 0.
                      00186 ;;; arguments:  expects USTAT value in FSR1H
                      00187 ;;;   BSR=0
                      00188 ;;; returns:  none
                      00189 ;;; clobbers: W, FSR1H
0006                  00190 usb_service_ep0
0006   1907           00191   btfsc FSR1H,DIR ; is it an IN transfer or an OUT/SETUP?
0007   286E           00192   goto  _usb_ctrl_in
                      00193 ; it's an OUT or SETUP transfer
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0008   0820           00194   movfw BANKED_EP0OUT_STAT
0009   393C           00195   andlw b'00111100' ; isolate PID bits
000A   3C34           00196   sublw PID_SETUP ; is it a SETUP packet?
000B   1D03 2828      00197   bnz arm_ep0_out ; if not, it's a regular OUT, just rearm the buffer
                      00198   ; it's a SETUP packet--fall through
                      00199 
                      00200 ; Handles a SETUP control transfer on endpoint 0.
                      00201 ; BSR=0
000D                  00202 _usb_ctrl_setup
000D   1030           00203   bcf USB_STATE,IS_CONTROL_WRITE
                      00204 ; get bmRequestType, but don't bother checking whether it's standard/class/vendor...
                      00205 ; the CDC and standard requests we'll receive have distinct bRequest numbers
000E   13A0           00206   bcf BANKED_EP0OUT_STAT,UOWN ; dearm the OUT endpoint
000F   13A4           00207   bcf BANKED_EP0IN_STAT,UOWN  ; dearm the IN endpoint
                      00208 
0010   0838           00209   movfw BANKED_EP0OUT_BUF+bmRequestType
0011   1FB8           00210   btfss BANKED_EP0OUT_BUF+bmRequestType,7 ; is this host->device?
0012   1430           00211   bsf USB_STATE,IS_CONTROL_WRITE    ; if so, this is a control write
                      00212 ; check request number: is it Get Descriptor?
0013   3006           00213   movlw GET_DESCRIPTOR
0014   0239           00214   subwf BANKED_EP0OUT_BUF+bRequest,w
0015   1903 283E      00215   bz  _usb_get_descriptor
                      00216 ; is it Set Address?
0017   3005           00217   movlw SET_ADDRESS
0018   0239           00218   subwf BANKED_EP0OUT_BUF+bRequest,w
0019   1903 285F      00219   bz  _usb_set_address
                      00220 ; is it Set_Configuration?
001B   3009           00221   movlw SET_CONFIG
001C   0239           00222   subwf BANKED_EP0OUT_BUF+bRequest,w
001D   1903 2861      00223   bz  _usb_set_configuration
                      00224 ; is it Get Configuration?
001F   3008           00225   movlw GET_CONFIG
0020   0239           00226   subwf BANKED_EP0OUT_BUF+bRequest,w
0021   1903 2867      00227   bz  _usb_get_configuration
                      00228 ; unhandled request? fall through to _usb_ctrl_invalid
                      00229 
                      00230 ; Finishes a rejected SETUP transaction: the endpoints are stalled
0023                  00231 _usb_ctrl_invalid
0023   003D           00232   banksel UCON
0024   120E           00233   bcf UCON,PKTDIS ; reenable packet processing
0025   0020           00234   banksel BANKED_EP0IN_STAT
0026   300C           00235   movlw _DAT0|_DTSEN|_BSTALL
0027   2037           00236   call  arm_ep0_in_with_flags
0028                  00237 arm_ep0_out
0028   300C           00238   movlw _DAT0|_DTSEN|_BSTALL
0029                  00239 arm_ep0_out_with_flags      ; W specifies STAT flags
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0029   00A0           00240   movwf BANKED_EP0OUT_STAT
002A   3008           00241   movlw EP0_BUF_SIZE    ; reset the buffer count
002B   00A1           00242   movwf BANKED_EP0OUT_CNT
002C   17A0           00243   bsf BANKED_EP0OUT_STAT,UOWN ; arm the OUT endpoint
002D   0008           00244   return
                      00245 
                      00246 ; Finishes a successful SETUP transaction.
002E                  00247 _usb_ctrl_complete
002E   003D           00248   banksel UCON
002F   120E           00249   bcf UCON,PKTDIS   ; reenable packet processing
0030   0020           00250   banksel USB_STATE
0031   1830           00251   btfsc USB_STATE,IS_CONTROL_WRITE
0032   283A           00252   goto  _cwrite
                      00253 ; this is a control read; prepare the IN endpoint for the data stage
                      00254 ; and the OUT endpoint for the status stage
0033   207C           00255 _cread  call  ep0_read_in   ; read data into IN buffer
0034   3048           00256   movlw _DAT1|_DTSEN    ; OUT buffer will be ready for status stage
                      00257 ; value in W is used to specify the EP0 OUT flags
0035   2029           00258 _armbfs call  arm_ep0_out_with_flags
0036   3048           00259   movlw _DAT1|_DTSEN    ; arm IN buffer
0037                  00260 arm_ep0_in_with_flags     ; W specifies STAT flags
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0037   00A4           00261   movwf BANKED_EP0IN_STAT
0038   17A4           00262   bsf BANKED_EP0IN_STAT,UOWN
0039   0008           00263   return
                      00264 ; this is a control write: prepare the IN endpoint for the status stage
                      00265 ; and the OUT endpoint for the next SETUP transaction
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
003A   13A4           00266 _cwrite bcf BANKED_EP0IN_STAT,UOWN  ; ensure we have ownership of the buffer
003B   01A5           00267   clrf  BANKED_EP0IN_CNT  ; we'll be sending a zero-length packet
003C   300C           00268   movlw _DAT0|_DTSEN|_BSTALL  ; make OUT buffer ready for next SETUP packet
003D   2835           00269   goto  _armbfs     ; arm OUT and IN buffers
                      00270 
                      00271 
                      00272 
                      00273 ; Handles a Get Descriptor request.
                      00274 ; BSR=0
003E                  00275 _usb_get_descriptor
                      00276 ; check descriptor type
003E   3002           00277   movlw DESC_CONFIG
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
003F   023B           00278   subwf BANKED_EP0OUT_BUF+wValueH,w
0040   1903 284E      00279   bz  _config_descriptor
0042   3003           00280   movlw DESC_STRING
0043   023B           00281   subwf BANKED_EP0OUT_BUF+wValueH,w
0044   1903 2852      00282   bz  _string_descriptor
0046   3001           00283   movlw DESC_DEVICE
0047   023B           00284   subwf BANKED_EP0OUT_BUF+wValueH,w
0048   1D03 2823      00285   bnz _usb_ctrl_invalid
004A                  00286 _device_descriptor
004A   30A1           00287   movlw low DEVICE_DESCRIPTOR
004B   00B1           00288   movwf EP0_DATA_IN_PTR
004C   3012           00289   movlw DEVICE_DESC_LEN
004D   2855           00290   goto  _set_data_in_count_from_w
004E                  00291 _config_descriptor
004E   30B3           00292   movlw low CONFIGURATION_DESCRIPTOR
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
004F   00B1           00293   movwf EP0_DATA_IN_PTR
0050   3043           00294   movlw CONFIG_DESC_TOTAL_LEN ; length includes all subordinate descriptors
0051   2855           00295   goto  _set_data_in_count_from_w
0052                  00296 _string_descriptor
                      00297 ; only one string descriptor (serial number) is supported,
                      00298 ; so don't bother checking wValueL
0052   30F6           00299   movlw low SERIAL_NUMBER_STRING_DESCRIPTOR
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0053   00B1           00300   movwf EP0_DATA_IN_PTR
0054   300A           00301   movlw SERIAL_NUM_DESC_LEN
0055                  00302 _set_data_in_count_from_w
0055   00B2           00303   movwf EP0_DATA_IN_COUNT
                      00304 ; the count needs to be set to the minimum of the descriptor's length (in W)
                      00305 ; and the requested length
0056   08BF           00306   tstf  BANKED_EP0OUT_BUF+wLengthH  ; test high byte...
0057   1D03 282E      00307   bnz _usb_ctrl_complete    ; use length of descriptor
                      00308 
0059   023E           00309   subwf BANKED_EP0OUT_BUF+wLengthL,w
005A   1803 282E      00310   bc  _usb_ctrl_complete    ; if W <= f, no need to adjust
005C   083E           00311   movfw BANKED_EP0OUT_BUF+wLengthL
005D   00B2           00312   movwf EP0_DATA_IN_COUNT
005E   282E           00313   goto  _usb_ctrl_complete
                      00314 
                      00315 ; Handles a Set Address request.
                      00316 ; The address is actually set in the IN status stage.
005F                  00317 _usb_set_address
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
005F   14B0           00318   bsf USB_STATE,ADDRESS_PENDING ; address will be assigned in the status stage
0060   282E           00319   goto  _usb_ctrl_complete
                      00320 
                      00321 ; Handles a Set Configuration request.
                      00322 ; For now just accept any nonzero configuration.
                      00323 ; BSR=0
0061                  00324 _usb_set_configuration
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0061   1130           00325   bcf USB_STATE,DEVICE_CONFIGURED ; temporarily clear flag
0062   08BA           00326   tstf  BANKED_EP0OUT_BUF+wValueL ; anything other than 0 is valid
0063   1D03           00327   skpz
0064   1530           00328   bsf USB_STATE,DEVICE_CONFIGURED
0065   2096           00329   call  cdc_init
0066   282E           00330   goto  _usb_ctrl_complete
                      00331 
                      00332 ; Handles a Get Configuration request.
                      00333 ; BSR=0
0067                  00334 _usb_get_configuration
                      00335 ; load a pointer to either a 0 or a 1 in ROM
                      00336 ; the 0 and 1 have been chosen so that they are adjacent
0067   30BF           00337   movlw low CONFIGURATION_0_CONSTANT
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0068   1930           00338   btfsc USB_STATE,DEVICE_CONFIGURED
                      00339   incw
0069   3E01               M         addlw   1
006A   00B1           00340   movwf EP0_DATA_IN_PTR
006B   3001           00341   movlw 1
006C   00B2           00342   movwf EP0_DATA_IN_COUNT
006D   282E           00343   goto  _usb_ctrl_complete
                      00344 
                      00345 ; Handles an IN control transfer on endpoint 0.
                      00346 ; BSR=0
006E                  00347 _usb_ctrl_in
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
006E   1830           00348   btfsc USB_STATE,IS_CONTROL_WRITE  ; is this a control read or write?
006F   2875           00349   goto  _check_for_pending_address
                      00350 ; fetch more data and re-arm the IN endpoint
0070   207C           00351   call  ep0_read_in
0071   3008           00352   movlw _DTSEN
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0072   1F24           00353   btfss BANKED_EP0IN_STAT,DTS ; toggle DTS
0073   1709           00354   bsf WREG,DTS
0074   2837           00355   goto  arm_ep0_in_with_flags ; arm the IN buffer
                      00356 
                      00357 ; if this is the status stage of a Set Address request, assign the address here.
                      00358 ; The OUT buffer has already been armed for the next SETUP.
0075                  00359 _check_for_pending_address
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0075   1CB0           00360   btfss USB_STATE,ADDRESS_PENDING
0076   0008           00361   return
                      00362 ; read the address out of the setup packed in the OUT buffer
0077   10B0           00363   bcf USB_STATE,ADDRESS_PENDING
0078   083A           00364   movfw BANKED_EP0OUT_BUF+wValueL
0079   003D           00365   banksel UADDR
007A   0096           00366   movwf UADDR
007B   0008           00367   return
                      00368 
                      00369 
                      00370 
                      00371 ;;; Reads descriptor data from EP0_DATA_IN_PTR, copies it to the EP0 IN buffer,
                      00372 ;;; and decrements EP0_DATA_IN_COUNT.
                      00373 ;;; arguments:  BSR=0
                      00374 ;;; returns:  EP0_DATA_IN_PTRL advanced
                      00375 ;;;   EP0_DATA_IN_COUNT decremented
                      00376 ;;; clobbers: W, FSR0, FSR1
007C                  00377 ep0_read_in
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
007C   13A4           00378   bcf BANKED_EP0IN_STAT,UOWN  ; make sure we have ownership of the buffer
007D   01A5           00379   clrf  BANKED_EP0IN_CNT  ; initialize buffer size to 0
007E   08B2           00380   tstf  EP0_DATA_IN_COUNT ; do nothing if there are 0 bytes to send
                      00381   retz
007F   1903               M         skpnz
0080   0008               M         return
0081   0831           00382   movfw EP0_DATA_IN_PTR   ; set up source pointer
0082   0084           00383   movwf FSR0L
0083   3081           00384   movlw DESCRIPTOR_ADRH|0x80
0084   0085           00385   movwf FSR0H
                      00386   ldfsr1d EP0IN_BUF   ; set up destination pointer
0085   3020               M         movlw   low EP0IN_BUF
0086   0086               M         movwf   FSR1L
0087   3020               M         movlw   (high EP0IN_BUF) & 0x7F
0088   0087               M         movwf   FSR1H
0089   0103           00387   clrw
                      00388 ; byte copy loop
008A   3C08           00389 _bcopy  sublw EP0_BUF_SIZE    ; have we filled the buffer?
008B   1903 2893      00390   bz  _bcdone
008D   0012           00391   moviw FSR0++
008E   001E           00392   movwi FSR1++
008F   0AA5           00393   incf  BANKED_EP0IN_CNT,f  ; increase number of bytes copied
0090   0825           00394   movfw BANKED_EP0IN_CNT  ; save to test on the next iteration
0091   0BB2           00395   decfsz  EP0_DATA_IN_COUNT,f ; decrement number of bytes remaining
0092   288A           00396   goto  _bcopy
                      00397 ; write back the updated source pointer
0093   0804           00398 _bcdone movfw FSR0L
0094   00B1           00399   movwf EP0_DATA_IN_PTR
                      00400 
                      00401 #if ENABLE_POWER_CONFIG
                      00402 ; if we're sending the configuration descriptor, we need to inject the app's
                      00403 ; values for bus power/self power and max current consumption
                      00404 _check_for_config_bmattributes
                      00405   movlw (low CONFIGURATION_DESCRIPTOR)+EP0_BUF_SIZE
                      00406   subwf FSR0L,w
                      00407   bnz _check_for_config_bmaxpower
                      00408 ; if we're sending the first 8 bytes of the configuration descriptor,
                      00409 ; set bit 6 of bmAttributes if the application is self-powered
                      00410   btfsc APP_POWER_CONFIG,0
                      00411   bsf BANKED_EP0IN_BUF+7,6
                      00412   return
                      00413 _check_for_config_bmaxpower
                      00414   movlw (low CONFIGURATION_DESCRIPTOR)+(EP0_BUF_SIZE*2)
                      00415   subwf FSR0L,w
                      00416   retnz
                      00417 ; if we're sending the second 8 bytes of the configuration descriptor,
                      00418 ; replace bMaxPower with the app's value
                      00419   movfw APP_POWER_CONFIG
                      00420   bcf WREG,0      ; value is in the upper 7 bits
                      00421   movwf BANKED_EP0IN_BUF+0
                      00422 #endif
0095   0008           00423   return
                      00424 
                      00425 
                      00426 
                      00427 ;;; Initializes the buffers for the CDC endpoints (1 OUT, 1 IN, and 2 IN).
                      00428 ;;; arguments:  none
                      00429 ;;; returns:  none
                      00430 ;;; clobbers: W, BSR=0
0096                  00431 cdc_init
0096   0020           00432   banksel BANKED_EP1OUT_STAT
0097   20AD           00433   call  arm_ep1_out
                      00434   ; arm EP1 IN buffer, clearing data toggle bit
0098   0103           00435   clrw
                      00436 
                      00437 ; arms endpoint 1 IN, toggling DTS if W=(1<<DTS)
0099                  00438 arm_ep1_in
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
0099   01AD           00439   clrf  BANKED_EP1IN_CNT  ; next packet will have 0 length (unless another OUT is received)
009A   05AC           00440   andwf BANKED_EP1IN_STAT,f ; clear all bits (except DTS if bit is set in W)
009B   06AC           00441   xorwf BANKED_EP1IN_STAT,f ; update data toggle (if bit is set in W)
009C   17AC           00442   bsf BANKED_EP1IN_STAT,UOWN
009D   0008           00443   return
                      00444 
                      00445 
                      00446 
                      00447 ;;; Services a transaction on one of the CDC endpoints.
                      00448 ;;; arguments:  USTAT value in FSR1H
                      00449 ;;;   BSR=0
                      00450 ;;; returns:  none
                      00451 ;;; clobbers: W, FSR0, FSR1
009E                  00452 usb_service_cdc
009E   3040           00453   movlw (1<<DTS)
                      00454   retbfs  FSR1H,ENDP1   ; ignore endpoint 2
009F   1A07               M         btfsc   FSR1H,ENDP1
00A0   0008               M         return
                      00455   bbfs  FSR1H,DIR,arm_ep1_in  ; if endpoint 1 IN, rearm buffer
00A1   1907               M         btfsc   FSR1H,DIR
00A2   2899               M         goto    arm_ep1_in
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00A3   08A9           00456   movf  BANKED_EP1OUT_CNT,f ; test for a zero-length packet
00A4   1903 28AD      00457   bz  arm_ep1_out   ; (just ignore them and rearm the OUT buffer)
00A6   13AC           00458   bcf BANKED_EP1IN_STAT,UOWN
00A7   20B2           00459   call  bootloader_exec_cmd ; execute command; status returned in W
                      00460 
00A8   0020           00461   banksel BANKED_EP1IN_BUF
00A9   00C9           00462   movwf BANKED_EP1IN_BUF  ; copy status to IN buffer
00AA   3001           00463   movlw 1
00AB   00AD           00464   movwf BANKED_EP1IN_CNT  ; output byte count is 1
00AC   17AC           00465   bsf BANKED_EP1IN_STAT,UOWN
                      00466   ; fall through to arm_ep1_out
                      00467 
00AD                  00468 arm_ep1_out
00AD   3040           00469   movlw EP1_OUT_BUF_SIZE  ; set CNT
00AE   00A9           00470   movwf BANKED_EP1OUT_CNT
00AF   01A8           00471   clrf  BANKED_EP1OUT_STAT  ; ignore data toggle
00B0   17A8           00472   bsf BANKED_EP1OUT_STAT,UOWN ; rearm OUT buffer
00B1   0008           00473   return
                      00474 
                      00475 
                      00476 
                      00477 ;;; Executes a bootloader command.
                      00478 ;;; arguments:  command payload in EP1 OUT buffer
                      00479 ;;;     BSR=0
                      00480 ;;; returns:  status code in W
                      00481 ;;; clobbers: W, BSR, FSR0, FSR1
00B2                  00482 bootloader_exec_cmd
                      00483 ; check length of data packet
00B2   3004           00484   movlw BCMD_SET_PARAMS_LEN
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00B3   0229           00485   subwf BANKED_EP1OUT_CNT,w
00B4   1903 28C4      00486   bz  _bootloader_set_params
00B6   3040           00487   movlw BCMD_WRITE_LEN
00B7   0229           00488   subwf BANKED_EP1OUT_CNT,w
00B8   1903 28D8      00489   bz  _bootloader_write
00BA   3001           00490   movlw BCMD_RESET_LEN
00BB   0229           00491   subwf BANKED_EP1OUT_CNT,w
00BC   1903 28BF      00492   bz  _bootloader_reset
00BE   3402           00493   retlw BSTAT_INVALID_COMMAND
                      00494 
                      00495 ; Resets the device if the received byte matches the reset character.
00BF                  00496 _bootloader_reset
00BF   3052           00497   movlw BCMD_RESET_CHAR
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00C0   024A           00498   subwf BANKED_EP1OUT_BUF,w ; check received character
00C1   1D03           00499   skpz
00C2   3402           00500   retlw BSTAT_INVALID_COMMAND
                      00501 ; command is valid, reset the device
00C3   0001           00502   reset
                      00503 
                      00504 ; Sets the write address, expected checksum of the next 32 words,
                      00505 ; and erases the row at that address if the last byte of the command matches
                      00506 ; the "erase" character.
                      00507 ; BSR=0
00C4                  00508 _bootloader_set_params
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00C4   084C           00509   movfw BANKED_EP1OUT_BUF+BCMD_SET_PARAMS_CKSUM ; expected checksum
00C5   00C8           00510   movwf EXPECTED_CHECKSUM     ; save for verification during write command
00C6   084D           00511   movfw BANKED_EP1OUT_BUF+BCMD_SET_PARAMS_ERASE
00C7   0086           00512   movwf FSR1L ; temp
00C8   084A           00513   movfw BANKED_EP1OUT_BUF+BCMD_SET_PARAMS_ADRL  ; address lower bits
00C9   0087           00514   movwf FSR1H ; temp
00CA   084B           00515   movfw BANKED_EP1OUT_BUF+BCMD_SET_PARAMS_ADRH  ; address upper bits
00CB   0023           00516   banksel PMADRH
00CC   0092           00517   movwf PMADRH
00CD   0807           00518   movfw FSR1H ; bring lower bits out of temp
00CE   0091           00519   movwf PMADRL
                      00520 ; do we need to erase?
00CF   3045           00521   movlw BCMD_ERASE_CHAR
00D0   0206           00522   subwf FSR1L,w
00D1   1D03           00523   skpz
00D2   3401           00524   retlw BSTAT_OK  ; if no reset command is given, return OK
                      00525 
                      00526 ; Erases the row of flash in PMADRH:PMADRL.
                      00527 ; BSR=3
00D3                  00528 _bootloader_erase
00D3   3014           00529   movlw (1<<FREE)|(1<<WREN) ; enable write and erase to program memory
00D4   0095           00530   movwf PMCON1
00D5   2106           00531   call  flash_unlock    ; stalls until erase finishes
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
00D6   1115           00532 _wdone  bcf PMCON1,WREN   ; clear write enable flag
00D7   3401           00533   retlw BSTAT_OK
                      00534 
                      00535 ; Verifies that the checksum of the 32 words (64 bytes) in the EP1 OUT buffer
                      00536 ; matches the previously sent value. If so, the 32 bytes are then written to
                      00537 ; flash memory at the address in PMADRH:PMADRL. (set by a prior command)
                      00538 ; BSR=0
00D8                  00539 _bootloader_write
                      00540 ; The expected checksum is the two's complement of the sum of the bytes.
                      00541 ; If the data is valid, we can add the checksum to the sum of the bytes and
                      00542 ; the result will be 0. We initialize a temporary register with the expected
                      00543 ; checksum, and then add each byte to it as it's processed.
                      00544 ; If the value in the temp register is 0 after all 64 bytes have been copied
                      00545 ; to the write latches, proceed with the write.
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 0 from now on.
00D8   0848           00546   movfw EXPECTED_CHECKSUM
00D9   0086           00547   movwf FSR1L     ; use a temp for the running checksum
                      00548   ldfsr0d EP1OUT_BUF    ; set up read pointer
00DA   302A               M         movlw   low EP1OUT_BUF
00DB   0084               M         movwf   FSR0L
00DC   3020               M         movlw   (high EP1OUT_BUF) & 0x7F
00DD   0085               M         movwf   FSR0H
00DE   3024           00549   movlw (1<<LWLO)|(1<<WREN) ; write to latches only
00DF   0023           00550   banksel PMCON1
00E0   0095           00551   movwf PMCON1
                      00552 ; simultaneously compute the checksum of the 32 words and copy them to the
                      00553 ; write latches
00E1   3020           00554   movlw 32      ; number of words to write minus 1
00E2   0087           00555   movwf FSR1H     ; used for loop count
00E3   0012           00556 _wloop  moviw FSR0++      ; load lower byte
00E4   0786           00557   addwf FSR1L,f     ; add lower byte to checksum
00E5   0093           00558   movwf PMDATL      ; copy to write latch
00E6   0012           00559   moviw FSR0++      ; load upper byte
00E7   0786           00560   addwf FSR1L,f     ; add upper byte to checksum
00E8   0094           00561   movwf PMDATH      ; copy to write latch
                      00562 ; after writing the 32nd word to PMDATH:PMDATL, don't execute the unlock sequence
                      00563 ; or advance the address pointer!
00E9   0387           00564   decf  FSR1H,f     ; decrement loop count
00EA   1903 28EF      00565   bz  _wcksum     ; if 0, we're done writing to the latches
                      00566 ; still have more words to go
00EC   2106           00567   call  flash_unlock    ; execute unlock sequence
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
00ED   0A91           00568   incf  PMADRL,f    ; increment write address
00EE   28E3           00569   goto  _wloop
                      00570 ; verify the checksum
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
00EF   0195           00571 _wcksum clrf  PMCON1
00F0   0886           00572   tstf  FSR1L
00F1   1D03           00573   skpz
00F2   3403           00574   retlw BSTAT_INVALID_CHECKSUM  ; if there's a mismatch, abort the write
                      00575 ; checksum is valid, write the data
00F3   1515           00576   bsf PMCON1,WREN
00F4   2106           00577   call  flash_unlock    ; stalls until write finishes
                      00578 ; verify the write: compare each byte in the buffer to its counterpart that
                      00579 ; was just written to flash.
                      00580 ; we do this backwards so we don't waste instructions resetting the pointers.
                      00581 ; (note: PMADRH:PMADRL is already pointing at the last written word, but FSR0
                      00582 ; is pointing to one byte past the end of the buffer)
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
00F5   0195           00583   clrf  PMCON1      ; clear write enable
00F6   1687           00584   bsf FSR1H,5     ; set loop count to 32 (just need to set one bit because it's already 0)
00F7   1415           00585 _vloop  bsf PMCON1,RD   ; read word from flash
00F8   0000           00586   nop       ; 2 required nops
00F9   0000           00587   nop
00FA   0011           00588   moviw --FSR0      ; get high byte of expected word
00FB   0214           00589   subwf PMDATH,w    ; compare with high byte written to flash
00FC   1D03           00590   skpz
00FD   3404           00591   retlw BSTAT_VERIFY_FAILED
00FE   0011           00592   moviw --FSR0      ; get low byte of expected word
00FF   0213           00593   subwf PMDATL,w    ; compare with low byte written to flash
0100   1D03           00594   skpz
0101   3404           00595   retlw BSTAT_VERIFY_FAILED
0102   0391           00596   decf  PMADRL,f    ; decrement read address
0103   0B87           00597   decfsz  FSR1H,f     ; decrement loop count
0104   28F7           00598   goto  _vloop
0105   3401           00599   retlw BSTAT_OK
                      00600 
                      00601 
                      00602 ;;; Executes the flash unlock sequence, performing an erase or write.
                      00603 ;;; arguments:  PMCON1 bits CFGS, LWLO, FREE and WREN set appropriately
                      00604 ;;;   BSR=3
                      00605 ;;; returns:  none
                      00606 ;;; clobbers: W
0106                  00607 flash_unlock
0106   3055           00608   movlw 0x55
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 3 from now on.
0107   0096           00609   movwf PMCON2
0108   30AA           00610   movlw 0xAA
0109   0096           00611   movwf PMCON2
010A   1495           00612   bsf PMCON1,WR
010B   0000           00613   nop
010C   0000           00614   nop
010D   0008           00615 ret return
                      00616 
                      00617 
                      00618 
                      00619 ;;; Main function
                      00620 ;;; BSR=1 (OSCCON bank)
010E                  00621 bootloader_start
                      00622 ; Configure the oscillator (48MHz from INTOSC using 3x PLL)
010E   30FC           00623   movlw (1<<SPLLEN)|(1<<SPLLMULT)|(1<<IRCF3)|(1<<IRCF2)|(1<<IRCF1)|(1<<IRCF0)
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 1 from now on.
010F   0099           00624   movwf OSCCON
                      00625 
                      00626 ; Wait for the oscillator and PLL to stabilize
0110   3051           00627 _wosc movlw (1<<PLLRDY)|(1<<HFIOFR)|(1<<HFIOFS)
0111   051A           00628   andwf OSCSTAT,w
0112   3C51           00629   sublw (1<<PLLRDY)|(1<<HFIOFR)|(1<<HFIOFS)
0113   1D03 2910      00630   bnz _wosc
                      00631 
                      00632 ; Check for valid application code: the lower 8 bits of the first word cannot be 0xFF
0115   213C           00633   call  app_is_present
0116   1903 291F      00634   bz  _bootloader_main  ; if we have no application, enter bootloader mode
                      00635 
                      00636 ; We have a valid application? Check if the entry pin is grounded
                      00637 
                      00638 
                      00639 #if USE_RC3_SWITCH
                      00640   banksel ANSELC        ;disable analog function on pin
                      00641   bcf   ANSELC,ANSC3
                      00642 
                      00643   banksel PORTC
                      00644   btfss PORTC,RC3
                      00645   goto  _bootloader_main  ; enter bootloader mode if input is low
                      00646 #endif
                      00647 
                      00648 #if USE_RA3_SWITCH
0118   0020           00649   banksel PORTA
0119   1D8C           00650   btfss PORTA,RA3
011A   291F           00651   goto  _bootloader_main  ; enter bootloader mode if input is low
                      00652 
                      00653 ; We have a valid application and the entry pin is high. Start the application.
011B   0021           00654   banksel OPTION_REG
011C   1795           00655   bsf OPTION_REG,NOT_WPUEN  ; but first, disable weak pullups
                      00656 #endif
                      00657 
                      00658 #if USE_RC3_SWITCH
                      00659   banksel ANSELC        ;enable analog function on pin
                      00660   bsf   ANSELC,ANSC3
                      00661 #endif
                      00662 
011D   3182           00663   movlp high APP_ENTRY_POINT  ; attempt to appease certain user apps
011E   2A00           00664   goto  APP_ENTRY_POINT
                      00665 
                      00666 
                      00667 ; Not entering application code: initialize the USB interface and wait for commands.
011F                  00668 _bootloader_main
                      00669 ; Enable active clock tuning
                      00670 
                      00671   if LOGGING_ENABLED
                      00672   call  uart_init
                      00673 ; Print a power-on character
                      00674   call  log_init
                      00675   logch '^',LOG_NEWLINE
                      00676   endif
                      00677 
011F   3090           00678   movlw (1<<ACTSRC)|(1<<ACTEN)
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 7 from now on.
0120   009B           00679   movwf ACTCON    ; source = USB
                      00680 
                      00681 
                      00682 ; Initialize USB
0121   2142           00683   call  usb_init
                      00684 
                      00685 ; Attach to the bus (could be a subroutine, but inlining it saves 2 instructions)
0122                  00686 _usb_attach
                      00687   logch 'A',0
                          M         if      LOGGING_ENABLED
                          M         movlw   (((('A'-32) & b'00111111') | 0) & b'01111111')
                          M         call    log_single_byte
                          M         endif
0122   003D           00688   banksel UCON    ; reset UCON
0123   018E           00689   clrf  UCON
0124   003D           00690   banksel UCON    ; reset UCON
0125                  00691 _usben
0125   158E           00692   bsf UCON,USBEN    ; enable USB module and wait until ready
0126   1D8E           00693   btfss UCON,USBEN
0127   2925           00694   goto  _usben
                      00695   logch '!',LOG_NEWLINE
                          M         if      LOGGING_ENABLED
                          M         movlw   (((('!'-32) & b'00111111') | LOG_NEWLINE) & b'01111111')
                          M         call    log_single_byte
                          M         endif
                      00696 
                      00697 
                      00698 ;;; Idle loop. In bootloader mode, the MCU just spins here, and all USB
                      00699 ;;; communication is interrupt-driven.
                      00700 ;;; This snippet is deliberately located within the first 256 words of program
                      00701 ;;; memory, so we can easily check in the interrupt handler if the interrupt
                      00702 ;;; occurred while executing application code or bootloader code.
                      00703 ;;; (TOSH will be 0x00 when executing bootloader code, i.e. this snippet)
0128                  00704 bootloader_main_loop
                      00705 
                      00706   if LOGGING_ENABLED
                      00707 ; Print any pending characters in the log
                      00708   call  log_service
                      00709   endif
                      00710 
0128   003D           00711   banksel UIR
                      00712 ; reset?
0129   1C10           00713   btfss UIR,URSTIF
012A   292E           00714   goto  _utrans   ; not a reset? just start servicing transactions
012B   2142           00715   call  usb_init  ; if so, reset the USB interface (clears interrupts)
012C   003D           00716   banksel UIR
012D   1010           00717   bcf UIR,URSTIF  ; clear the flag
                      00718 ; service transactions
012E                  00719 _utrans
012E   003D           00720   banksel UIR
012F   1D90           00721   btfss UIR,TRNIF
0130   2928           00722   goto bootloader_main_loop
0131   080F           00723   movfw USTAT   ; stash the status in a temp register
0132   0087           00724   movwf FSR1H
0133   1190           00725   bcf UIR,TRNIF ; clear flag and advance USTAT fifo
                      00726 
0134   0020           00727   banksel BANKED_EP0OUT_STAT
0135   3978           00728   andlw b'01111000' ; check endpoint number
0136   1D03 293A      00729   bnz _ucdc   ; if not endpoint 0, it's a CDC message
0138   2006           00730   call  usb_service_ep0 ; handle the control message
0139   292E           00731   goto  _utrans
                      00732 
                      00733 
013A                  00734 _ucdc
013A   209E           00735   call  usb_service_cdc ; USTAT value is still in FSR1H
013B   292E           00736   goto  _utrans
                      00737 
                      00738 
                      00739 ;;; Determines if application code is present in flash memory.
                      00740 ;;; arguments:  none
                      00741 ;;; returns:  Z flag cleared if application code is present
                      00742 ;;; clobbers: W, FSR0
013C                  00743 app_is_present
013C   0184           00744   clrf  FSR0L
013D   3082           00745   movlw (high APP_ENTRY_POINT)|0x80 ; need to set high bit to indicate program memory
013E   0085           00746   movwf FSR0H
013F   3F00           00747   moviw 0[FSR0]
                      00748   incw        ; if W was 0xFF, it'll be 0 now
0140   3E01               M         addlw   1
0141   0008           00749   return        ; Z flag will be unset if app code is present
                      00750 
                      00751 
                      00752 
                      00753 #if ENABLE_POWER_CONFIG
                      00754 ;;; Gets the application's power config byte and stores it in APP_POWER_CONFIG.
                      00755 ;;; arguments:  none
                      00756 ;;; returns:  none
                      00757 ;;; clobbers: W, BSR, FSR0
                      00758 get_app_power_config
                      00759   banksel APP_POWER_CONFIG
                      00760   movlw 0x33      ; default value: bus-powered, max current 100 mA
                      00761   movwf APP_POWER_CONFIG
                      00762   call  app_is_present
                      00763   retz        ; if Z flag is set, we have no application, just return
                      00764   if LOGGING_ENABLED
                      00765   pagesel APP_CONFIG
                      00766   endif
                      00767   call  APP_CONFIG    ; config value returned in W
                      00768   pagesel get_app_power_config
                      00769   banksel APP_POWER_CONFIG
                      00770   movwf APP_POWER_CONFIG
                      00771   return
                      00772 #endif
                      00773 
                      00774 
                      00775 ;;; Initializes the USB system and resets all associated registers.
                      00776 ;;; arguments:  none
                      00777 ;;; returns:  none
                      00778 ;;; clobbers: W, BSR, FSR0, FSR1H
0142                  00779 usb_init
                      00780   logch 'R',LOG_NEWLINE
                          M         if      LOGGING_ENABLED
                          M         movlw   (((('R'-32) & b'00111111') | LOG_NEWLINE) & b'01111111')
                          M         call    log_single_byte
                          M         endif
                      00781 ; clear USB registers
0142   003D           00782   banksel UEIR
0143   0193           00783   clrf  UEIR
0144   0190           00784   clrf  UIR
                      00785 ; disable endpoints we won't use
0145   0199           00786   clrf  UEP1
0146   019A           00787   clrf  UEP2
0147   019B           00788   clrf  UEP3
0148   019C           00789   clrf  UEP4
0149   019D           00790   clrf  UEP5
014A   019E           00791   clrf  UEP6
014B   019F           00792   clrf  UEP7
                      00793 ; set configuration
014C   0197           00794   clrf  UEIE    ; don't need any error interrupts
014D   3014           00795   movlw (1<<UPUEN)|(1<<FSEN)
014E   0091           00796   movwf UCFG    ; enable pullups, full speed, no ping-pong buffering
014F   3009           00797   movlw (1<<TRNIE)|(1<<URSTIE)
0150   0092           00798   movwf UIE   ; only need interrupts for transaction complete and reset
                      00799 ; clear all BDT entries, variables, and buffers
0151   0184           00800   clrf  FSR0L
0152   3020           00801   movlw high BDT_START  ; BDT starts at 0x2000
0153   0085           00802   movwf FSR0H
0154   306A           00803   movlw USED_RAM_LEN
0155   0087           00804   movwf FSR1H   ; loop count
0156   3000           00805   movlw 0
0157   001A           00806 _ramclr movwi FSR0++
0158   0B87           00807   decfsz  FSR1H,f
0159   2957           00808   goto  _ramclr
                      00809 #if ENABLE_POWER_CONFIG
                      00810 ; get the app's power configuration (if it's present)
                      00811   call  get_app_power_config
                      00812 #endif
                      00813 ; reset ping-pong buffers and address
015A   003D           00814   banksel UCON
015B   170E           00815   bsf UCON,PPBRST
015C   0196           00816   clrf  UADDR
015D   120E           00817   bcf UCON,PKTDIS ; enable packet processing
015E   130E           00818   bcf UCON,PPBRST ; clear ping-pong buffer reset flag
                      00819 ; flush pending transactions
015F   1D90           00820 _tflush btfss UIR,TRNIF
0160   2964           00821   goto  _initep
0161   1190           00822   bcf UIR,TRNIF
0162   210D           00823   call  ret   ; need at least 6 cycles before checking TRNIF again
0163   295F           00824   goto  _tflush
                      00825 ; initialize endpoints:
                      00826 ; 0 for control
                      00827 ; 1 for CDC bulk data
                      00828 ; 2 for CDC notifications (though it's never actually used)
                      00829 ; my intuition was that I should wait until a SET_CONFIGURATION is received
                      00830 ; before setting up endpoints 1 and 2... but there seemed to be a timing issue
                      00831 ; when doing so, so I moved them here
0164                  00832 _initep
0164   3016           00833   movlw (1<<EPHSHK)|(1<<EPOUTEN)|(1<<EPINEN)
Message[1302]: RAM Bank undefined in this chunk of code. Ensure that bank bits are correct. Assuming bank 29 from now on.
0165   0098           00834   movwf UEP0
0166   301E           00835   movlw (1<<EPHSHK)|(1<<EPCONDIS)|(1<<EPOUTEN)|(1<<EPINEN)
0167   0099           00836   movwf UEP1
0168   301A           00837   movlw (1<<EPHSHK)|(1<<EPCONDIS)|(1<<EPINEN)
0169   009A           00838   movwf UEP2
                      00839 
                      00840 ; initialize endpoint buffers and counts
016A   0020           00841   banksel BANKED_EP0OUT_ADRL
016B   3018           00842   movlw low EP0OUT_BUF  ; set endpoint 0 OUT address low
016C   00A2           00843   movwf BANKED_EP0OUT_ADRL
016D   3020           00844   movlw low EP0IN_BUF ; set endpoint 0 IN address low
016E   00A6           00845   movwf BANKED_EP0IN_ADRL
016F   302A           00846   movlw low EP1OUT_BUF  ; set endpoint 1 OUT address low
0170   00AA           00847   movwf BANKED_EP1OUT_ADRL
0171   3029           00848   movlw low EP1IN_BUF ; set endpoint 1 IN address low
0172   00AE           00849   movwf BANKED_EP1IN_ADRL
0173   306A           00850   movlw low EP2IN_BUF ; set endpoint 2 IN address low
0174   00B6           00851   movwf BANKED_EP2IN_ADRL
0175   3020           00852   movlw EPBUF_ADRH  ; set all ADRH values
0176   00A3           00853   movwf BANKED_EP0OUT_ADRH
0177   00A7           00854   movwf BANKED_EP0IN_ADRH
0178   00AB           00855   movwf BANKED_EP1OUT_ADRH
0179   00AF           00856   movwf BANKED_EP1IN_ADRH
017A   00B7           00857   movwf BANKED_EP2IN_ADRH
                      00858 
017B   2828           00859   goto  arm_ep0_out
                      00860 
                      00861 
                      00862 
                      00863 ;;; Includes
                      00864   if LOGGING_ENABLED
                      00865   include "log.asm"
                      00866   endif
                      00867 
                      00868 
                      00869 
                      00870 ;;; Descriptors
                      00871 
                      00872 ; Place all the descriptors at the end of the bootloader region.
                      00873 ; This serves 2 purposes: 1) as long as the total length of all descriptors is
                      00874 ; less than 256, we can address them with an 8-bit pointer,
                      00875 ; and 2) the assembler will raise an error if space is exhausted.
01A1                  00876   org BOOTLOADER_SIZE-ALL_DESCS_TOTAL_LEN
  00000001            00877 DESCRIPTOR_ADRH equ high $
01A1                  00878 DEVICE_DESCRIPTOR
01A1   3412           00879   dt  DEVICE_DESC_LEN ; bLength
01A2   3401           00880   dt  0x01    ; bDescriptorType
01A3   3400 3402      00881   dt  0x00, 0x02  ; bcdUSB (USB 2.0)
01A5   3402           00882   dt  0x02    ; bDeviceClass (communication device)
01A6   3400           00883   dt  0x00    ; bDeviceSubclass
01A7   3400           00884   dt  0x00    ; bDeviceProtocol
01A8   3408           00885   dt  0x08    ; bMaxPacketSize0 (8 bytes)
01A9   3450 341D      00886   dt  low USB_VENDOR_ID, high USB_VENDOR_ID ; idVendor
01AB   34EE 34EE      00887   dt  low USB_PRODUCT_ID, high USB_PRODUCT_ID ; idProduct
01AD   3401 3400      00888   dt  0x01, 0x00  ; bcdDevice (1)
01AF   3400           00889   dt  0x00    ; iManufacturer
01B0   3400           00890   dt  0x00    ; iProduct
01B1   3401           00891   dt  0x01    ; iSerialNumber
01B2   3401           00892   dt  0x01    ; bNumConfigurations
                      00893 
01B3                  00894 CONFIGURATION_DESCRIPTOR
01B3   3409           00895   dt  0x09    ; bLength
01B4   3402           00896   dt  0x02    ; bDescriptorType
01B5   3443 3400      00897   dt  CONFIG_DESC_TOTAL_LEN, 0x00 ; wTotalLength
01B7   3402           00898   dt  0x02    ; bNumInterfaces
01B8   3401           00899   dt  0x01    ; bConfigurationValue
01B9   3400           00900   dt  0x00    ; iConfiguration
01BA   3480           00901   dt  0x80    ; bmAttributes
01BB   3411           00902   dt  0x11    ; bMaxPower
                      00903 
01BC                  00904 INTERFACE_DESCRIPTOR_0
01BC   3409           00905   dt  0x09    ; bLength
01BD   3404           00906   dt  0x04    ; bDescriptorType (INTERFACE)
01BE   3400           00907   dt  0x00    ; bInterfaceNumber
01BF                  00908 CONFIGURATION_0_CONSTANT
01BF   3400           00909   dt  0x00    ; bAlternateSetting
01C0                  00910 CONFIGURATION_1_CONSTANT
01C0   3401           00911   dt  0x01    ; bNumEndpoints
01C1   3402           00912   dt  0x02    ; bInterfaceClass (communication)
01C2   3402           00913   dt  0x02    ; bInterfaceSubclass (abstract control model)
01C3   3401           00914   dt  0x01    ; bInterfaceProtocol (V.25ter, common AT commands)
01C4   3400           00915   dt  0x00    ; iInterface
                      00916 
                      00917   if (CONFIGURATION_0_CONSTANT>>8) != (CONFIGURATION_1_CONSTANT>>8)
                      00918   error "CONSTANT_0 and CONSTANT_1 must be in the same 256-word region"
                      00919   endif
                      00920 
01C5                  00921 HEADER_FUNCTIONAL_DESCRIPTOR
01C5   3405           00922   dt  0x05    ; bFunctionLength
01C6   3424           00923   dt  0x24    ; bDescriptorType (CS_INTERFACE)
01C7   3400           00924   dt  0x00    ; bDescriptorSubtype (header functional descriptor)
01C8   3410 3401      00925   dt  0x10,0x01 ; bcdCDC (specification version, 1.1)
                      00926 
01CA                  00927 ABSTRACT_CONTROL_MANAGEMENT_FUNCTIONAL_DESCRIPTOR
01CA   3404           00928   dt  0x04    ; bFunctionLength
01CB   3424           00929   dt  0x24    ; bDescriptorType (CS_INTERFACE)
01CC   3402           00930   dt  0x02    ; bDescriptorSubtype (abstract control management functional descriptor)
01CD   3402           00931   dt  0x02    ; bmCapabilities
                      00932 
01CE                  00933 UNION_FUNCTIONAL_DESCRIPTOR
01CE   3405           00934   dt  0x05    ; bFunctionLength
01CF   3424           00935   dt  0x24    ; bDescriptorType (CS_INTERFACE)
01D0   3406           00936   dt  0x06    ; bDescriptorSubtype (union functional descriptor)
01D1   3400           00937   dt  0x00    ; bMasterInterface
01D2   3401           00938   dt  0x01    ; bSlaveInterface0
                      00939 
01D3                  00940 CALL_MANAGEMENT_FUNCTIONAL_DESCRIPTOR
01D3   3405           00941   dt  0x05    ; bFunctionLength
01D4   3424           00942   dt  0x24    ; bDescriptorType (CS_INTERFACE)
01D5   3401           00943   dt  0x01    ; bDescriptorSubtype (call management functional descriptor)
01D6   3400           00944   dt  0x00    ; bmCapabilities (doesn't handle call management)
01D7   3401           00945   dt  0x01    ; dDataInterface
                      00946 
01D8                  00947 ENDPOINT_DESCRIPTOR_2_IN
01D8   3407           00948   dt  0x07    ; bLength
01D9   3405           00949   dt  0x05    ; bDescriptorType (ENDPOINT)
01DA   3482           00950   dt  0x82    ; bEndpointAddress (2 IN)
01DB   3403           00951   dt  0x03    ; bmAttributes (transfer type: interrupt)
01DC   3408 3400      00952   dt  0x08, 0x00  ; wMaxPacketSize (8)
01DE   347F           00953   dt  0x7f    ; bInterval
                      00954 
01DF                  00955 INTERFACE_DESCRIPTOR_1
01DF   3409           00956   dt  0x09    ; bLength
01E0   3404           00957   dt  0x04    ; bDescriptorType (INTERFACE)
01E1   3401           00958   dt  0x01    ; bInterfaceNumber
01E2   3400           00959   dt  0x00    ; bAlternateSetting
01E3   3402           00960   dt  0x02    ; bNumEndpoints
01E4   340A           00961   dt  0x0a    ; bInterfaceClass (data)
01E5   3400           00962   dt  0x00    ; bInterfaceSubclass
01E6   3400           00963   dt  0x00    ; bInterfaceProtocol
01E7   3400           00964   dt  0x00    ; iInterface
                      00965 
01E8                  00966 ENDPOINT_DESCRIPTOR_1_IN
01E8   3407           00967   dt  0x07    ; bLength
01E9   3405           00968   dt  0x05    ; bDescriptorType (ENDPOINT)
01EA   3481           00969   dt  0x81    ; bEndpointAddress (1 IN)
01EB   3402           00970   dt  0x02    ; bmAttributes (transfer type: bulk)
01EC   3440 3400      00971   dt  0x40, 0x00  ; wMaxPacketSize (64)
01EE   3400           00972   dt  0x00    ; bInterval
                      00973 
01EF                  00974 ENDPOINT_DESCRIPTOR_1_OUT
01EF   3407           00975   dt  0x07    ; bLength
01F0   3405           00976   dt  0x05    ; bDescriptorType (ENDPOINT)
01F1   3401           00977   dt  0x01    ; bEndpointAddress (1 OUT)
01F2   3402           00978   dt  0x02    ; bmAttributes (transfer type: bulk)
01F3   3440 3400      00979   dt  0x40, 0x00  ; wMaxPacketSize (64)
01F5   3400           00980   dt  0x00    ; bInterval
                      00981 
                      00982 ; extract nibbles from serial number
  00000000            00983 SN1 equ (SERIAL_NUMBER>>12) & 0xF
  00000000            00984 SN2 equ (SERIAL_NUMBER>>8) & 0xF
  00000000            00985 SN3 equ (SERIAL_NUMBER>>4) & 0xF
  00000000            00986 SN4 equ SERIAL_NUMBER & 0xF
                      00987 
01F6                  00988 SERIAL_NUMBER_STRING_DESCRIPTOR
01F6   340A           00989   dt  SERIAL_NUM_DESC_LEN ; bLength
01F7   3403           00990   dt  0x03    ; bDescriptorType (STRING)
01F8   3430 3400      00991   dt  '0'+SN1+((SN1>9)*7), 0x00 ; convert hex digits to ASCII
01FA   3430 3400      00992   dt  '0'+SN2+((SN2>9)*7), 0x00
01FC   3430 3400      00993   dt  '0'+SN3+((SN3>9)*7), 0x00
01FE   3430 3400      00994   dt  '0'+SN4+((SN4>9)*7), 0x00
                      00995 
                      00996 ; Raise an error if the descriptors aren't properly aligned. (This means you
                      00997 ; changed the descriptors withouth updating the definition of ALL_DESCS_TOTAL_LEN.)
                      00998   if $!=BOOTLOADER_SIZE
                      00999   error "Descriptors must be aligned with the end of the bootloader region"
                      01000   endif
                      01001 
                      01002   end


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXX----
0180 : ---------------- ---------------- -XXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
01C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
8000 : -------XX------- ---------------- ---------------- ----------------

All other memory blocks unused.

Program Memory Words Used:   475
Program Memory Words Free:  7717


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :    28 reported,     0 suppressed

