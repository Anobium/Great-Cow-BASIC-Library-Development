'Current limitations.


'1. Packet size cannot exceed 700 bytes.
'2. Means, web page table cannot exceed 595 bytes.
'3. Web pages have to be...... wait for this one.... an odd number of bytes!! ?

'So, if things do not work....

'1. Check the TCP packet size in the terminal windows - cannot exceed 685 bytes.
'2. Check the table - cannot exceed 595
'3. Make sure the TCP packet size in the terminal window is an odd number.
'All this is sortable but for today. We are in a great place!
'A web page is max at about 633... but, the converter strips out chars not required so this will vary on the CRLF's used.
'you need the latest HTML2GCB.EXE.  I have uploaded also.
'you need the latest compiler.  I have uploaded also.
'
'lots of todos

'''A program  for GCGB and GCB.
'''A program  for GCGB and GCB.
'''--------------------------------------------------------------------------------------------------------------------------------
''' Description  :  Setup ENC28j60, then reads data from the Ethernet stream to a PC terminal.
'''
''' You NEED a PC terminal connected to the serial out on the microprocessor.
'''
'''@author    [todo]
'''@licence   GPL
'''@version   [todo]

'''@date      [todo]
'''********************************************************************************
'

#Chip 16f18877,8
#option explicit
#Config MCLRE = On
#Config WDT = Off
#Config LVP = Off
#Config BOREN = Off
#Config STVREN = Off

#startup PPSINIT, 85

    'Generated by PIC PPS Tool for Great Cow Basic
    'PPS Tool version: 0.0.5.4
    'PinManager data: 09/02/2017
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS
        UNLOCKPPS

'            'Module: EUSART
'            RC5PPS = 0x0010    'TX > RC5
'            TXPPS = 0x0015    'RC5 > TX (bi-directional)
'            SSP1CLKPPS = 0x09
'            RB1PPS = 0x14
'
'            SSP1DATPPS = 0x08
'            RB3PPS = 0x15


'           'Module: EUSART
'            RC6PPS = 0x0010    'TX > RC6
'            TXPPS = 0x0016    'RC6 > TX (bi-directional)
'            'Module: MSSP1
'            RB1PPS = 0x0014    'SCK1 > RB1
'            SSP1CLKPPS = 0x0009    'RB1 > SCK1 (bi-directional)
'            RB3PPS = 0x0015    'SDO1 > RB3

            'Module: EUSART

            RC5PPS = 0x0010    'TX > RC6
            TXPPS = 0x0015    'RC6 > TX (bi-directional)


            'Module: MSSP1
    SSP1CLKPPS = 0x09;   //RB1->MSSP1:SCK1;
    RB1PPS = 0x14;   //RB1->MSSP1:SCK1;
    SSP1DATPPS = 0x08;   //RB0->MSSP1:SDI1;
    RB3PPS = 0x15;   //RB3->MSSP1:SDO1;

        LOCKPPS
    End Sub
    'Template comment at the end of the config file


'    #include "ENC28J60.h"
'    #include "Ethernet.h"
    #include "ivalid35.htm"



    'USART settings
    #define USART_BAUD_RATE 115200
    #define USART_BLOCKING
    #define USART_TX_BLOCKING

; ----- Define Ethernet Hardware type
    #define ETHERNET_TYPE ETHERNET_TYPE_ENC28j60

; ----- Define Hardware settings
    ; ----- Constants
    #Define Ethernet_DI               Portb.0   'Connected to Device SO
    #Define Ethernet_DO               Portb.3     'Connected to Device SI
    #Define Ethernet_SCK              Portb.1     'Connected to Clock
    #Define Ethernet_CS               Porta.5     'Chip select line
    #Define Ethernet_RESET            Portb.4     'Reset line
; ----- Variables
'DIR PORTb.1 Out
'DIR PORTb.3 Out
'DIR PORTb.0 IN
'DIR Ethernet_CS OUT
'
'SPIMode MasterSlow, 0
'

; ----- Quick Command Reference:

; ----- Main body of program commences here.


'    #ifdef ENC28j60_Hserial_Supported
'        HSerPrintCRLF 2
'        HserPrint "ENC28j60 Ethernet Driver 039a" : HSerPrintCRLF
'        HSerSend 7
'    #endif

    'Do not remove this LABEL - this is required.
    Reset_Ethernet_Device:

    'Local key data:  ip address and mac address.
    ipaddr = 192,168,0,3
    macaddr = 0x00, 0x1E, 0xC0, 0x00, 0x00, 0x03

   'Details of your router
    IPRouter = 192,168,0,250
    MACaddrrouter = 0x38, 0x10, 0xd5, 0xef, 0x0e, 0xdb

    'Details of a remote server
     IPPort = 80
     IPServer = 192,168,0,106

    'Remote IP address of the SNTP server
    SntpServerAddr = 129, 6, 15, 28

    'EtherParameters
'    ENC28j60_regdump
     Ethernet_Initialise( macaddr )


do
        HserPrint "Initialised"
        HSerPrintCRLF
    #ifdef ENC28j60_Hserial_Supported
        HserPrint "Initialised"
        HSerPrintCRLF
    #endif
loop
    #ifdef ENC28j60_Lcd_Supported
        Locate (1,4)
        Print "Initialised."
    #endif


    #Define SwitchIn porta.4
    dir SwitchIn  in

    #Define ButtonDown = 1
    dim buttonstate as byte
    buttonstate = ButtonDown

          ENC28j60_writeReg( ERXFCON, 0 )

    dim myReadTime as bit
    myReadTime = 0

          ENC28j60_bitSet( ECON1 , econ1_txrst )
          ENC28j60_bitClear( ECON1 , econ1_txrst )
          ENC28j60_bitClear( EIR , EIR_TXERIF )
          ENC28j60_regdump


          ENC28j60_setfrequency ( 5 )

    dir portd.3 out

    Do forever

        if SwitchIn = buttonstate then

            if buttonstate  = ButtonDown then

                #ifdef ENC28j60_packetCounting_Supported
                  #ifdef ENC28j60_Hserial_Supported
                      HserPrint cnt
                      HserPrint ", "
                      HserPrint ENC_packetCounterOut
                      HserPrint ", "
                      HserPrint ENC_packetCounterIn
                      HSerPrintCRLF
                  #endif
                  OldENC_packetCounterIn = ENC_packetCounterIn
                  OldENC_packetCounterOut = ENC_packetCounterOut
                #endif

                #ifdef ENC28j60regdump_Supported
                  ENC28j60_regdump
                #endif

            end if

        end if

'        ENC28j60_poll 'Start the process.
        portd.3 =!portd.3

'        if myReadTime = 0 then
'                ENC28j60_sntp_get                       'get the Network Time once
'            myReadTime = 1
'        end if
    Loop


    end

'        ; ----- Support methods.  Subroutines and Functions
'
'        ' CHANGE Epoch_seconds  TO SUIT LOCAL NEEDS.. IN SECONDS!!
'        sub ENC28j60_UTC_Adjust ( in Epoch_seconds AS long )
'
'          'London time
'        '  Epoch_seconds = Epoch_seconds + 3600
'
'          'South Africa time
'          Epoch_seconds = Epoch_seconds + 7200
'
'
'        End sub
'
'
'        Sub My_udp_handler
'
'        ;  Uncomment to show UDP packet data
'        '            dim I_x as word
'        '
'        ;        Calcualte UDP packet length
'        '            I_value16_h = T_udp_len0
'        '            [byte]I_value16 = T_udp_len1
'        '            I_value16 = I_value16 - 8
'        '
'        '            For I_x = T_udp_data_pointer To ( T_udp_data_pointer + I_value16 - 1 )
'        '                HSerPrint i_x
'        '                HSerPrint "."
'        '              Next
'        '            HSerPrintCRLF
'        '
'        '            For I_x = T_udp_data_pointer To ( T_udp_data_pointer + I_value16 - 1 )
'        '              HSerPrint hex(etherbuffer(i_x))
'        '              HSerPrint ":"
'        '            Next
'        '            HSerPrintCRLF
'        '
'        '            For I_x = T_udp_data_pointer To ( T_udp_data_pointer + I_value16 - 1 )
'        '                HSerPrint chr(etherbuffer(i_x))
'        '              Next
'        '            HSerPrintCRLF
'        '            HSerPrint " -----------------------------------------------"
'        '            HSerPrintCRLF
'
'              select case T_udp_destport
'                  case 6000
'
'                      #ifdef ENC28j60_reinitialisation_Supported
'                          if T_udp_data = "R" then
'                              ENC28j60_Initialise
'                              goto Reset_ENC26j60
'                          end if
'                      #endif
'
'                      #ifdef ENC28j60regdump_Supported
'                          if T_udp_data = "D" then
'                              ENC28j60_regdump
'                          end if
'                      #endif
'
'                  case 5000
'
'                     'non-echo on PORT 5000
'                     Select Case T_udp_data
'
'                           #ifdef ENC28j60_sntp_Remote_Supported
'                               CASE "T"
'                                  HserPrint "Time...": HSerPrintCRLF
'                                  ENC28j60_sntp_get
'                           #endif
'
'                     End Select
'
'
'                  case 5002
'
'            ;        Calcualte UDP packet length
'                    I_value16_h = T_udp_len0
'                    [byte]I_value16 = T_udp_len1
'                    I_value16 = I_value16 - 8
'
'                    #ifdef ENC28j60_Lcd_Supported
'                      If  I_value16 = 2  then 'LCD Command
'
'                          select case T_udp_data0
'                              case 0
'                                'clear lcd
'                                Cls
'                              case 1
'                                Locate (0,0)
'                                Print "locate 1,0"
'                              case 2
'                                Locate (1,0)
'                                Print "locate 2,0"
'                              case 3
'                                Locate (2,0)
'                                Print "locate 3,0"
'                              case 4
'                                Locate (3,0)
'                                Print "locate 4,0"
'                          end select
'
'                       else
'
'                       'LCD string
'                          Locate (0,0)
'                          Print chr(T_udp_data0)
'                      End If
'                    #endif
'
'                     'LCD Control on PORT 5002
'                     if  I_value16 = 2  then 'LCD Command
'
'                        select case T_udp_data0
'                            case 0
'                              'clear lcd
'                              HSerPrint "CLS"
'                            case 1
'                              HSerPrint "locate 1,0"
'                            case 2
'                              HSerPrint "locate 2,0"
'                            case 3
'                              HSerPrint "locate 3,0"
'                            case 4
'                              HSerPrint "locate 4,0"
'
'                        end select
'                        HSerPrintCRLF
'
'                     else
'
'                     'LCD string
'                        HSerprint "Print "
'                        HSerSend T_udp_data0
'                        HSerPrintCRLF
'                     end if
'
'              end select
'        '
'            End Sub
'
'        ;If you want use the CALCULATED UDP checksum.  Not required typically.
'        '    #define ENC28j60_UDP_checkSum_Supported
'
'        ;If you want the ENC28j60 to respond to ICMP/Ping requests
'            #define ENC28j60_ping_Supported
'
'        ;If you want the ENC28j60 to put things on the LCD
'        '    #define ENC28j60_Lcd_Supported
'
'        ;If you want the ENC28j60 to put things on the terminal
            #define ENC28j60_Hserial_Supported
'            ;If you want to implement packet counting - you require ENC28j60_Hserial_Supported
'        '        #define ENC28j60_packetCounting_Supported
'            ;If you want to see the buffer error messages - you require ENC28j60_Hserial_Supported
'                #define ENC28j60_BufferErrorMessages_Supported
'            ;If you want to see the incoming packets
'        '        #define ReceivePacketDebug_Supported
'            ;If you want to see the HTTP packet info
'                #define ENC28j60_ShowHTTPInfo_Supported
'            ;If you want to see the HTTP header
'        '        #define ShowHTTPHeader_Supported
'            ;If you want to see the HTTP Flag status
'        '        #define ShowHTTPFlags
'
'        ;If you want the UDP protocols to be supported.  You cannot turn off UDP/ARP
'            #define ENC28j60_UDP_Supported
'            ;If you want to use UDP/Port 6000 and R to remote reset the ENC28j60 via UDP terminal application
'                #define ENC28j60_reinitialisation_Supported
'
'            ;If you want to use UDP/SNTP time. Provides lookup and terminal... but you will require ENC28j60_Hserial_Supported for the terminal!
'                #define ENC28j60_sntp_Supported
'
'            ;If you want to adjust the UDP/SNTP time. You need to define a sub called ENC28j60_UTC_Adjust ( in Epoch_seconds as Long )
'                #define ENC28j60_sntp_UTC_adjust_supported
'
'            ;If you want to call the UDP/SNTP time get time event.  Use a UDP client application on Port 5000 and "T" to call remote SNTP time.  Will display result on terminal.
'                #define ENC28j60_sntp_Remote_Supported
'
'            ;If you want to adjust the UDP/ECHO on port 7
'                #define ENC28j60_Echo7_Supported
'
'            ;If you want to support the UDP/Port 6000 and D to dump the registers from a UDP terminal application to the terminal
'                #define ENC28j60regdump_Supported
'
'        ;If you want the TCP protocols to be supported.
'            #define ENC28j60_tcp_supported
'            ;If you want the HTTP protocol to be supported.
'                #define ENC28j60_http_supported
'
'            ;If you want the Telnet protocol to be supported.
'        '        #define ENC28j60_telnet_supported
'
'
'        ;If you want to add your own UDP handler.
'        '         #define ENC28j60_Handle_udp My_udp_handler
'
'
'        '''http://www.hackshed.co.uk/lets-build-a-functional-arduino-webserver-sdcard-ethernet/
'        '#define HTTP_HANDLER userSubAJAX
'        '#define etherBufferSize 500
'        'sub userSubAJAX
'        '    HTTPPrint str(55155)
'        '
'        'end sub
'
'
'        'http://tmail.mooo.com:8080                         'shows index.htm
'        'http://tmail.mooo.com:8080/index.htm               'shows index.htm
'        'http://tmail.mooo.com:8080/?data=val1              'currently, shows port status page. This will be an AJAX call.
'                                                'This will be  tmail.mooo.com:8080/ADCPage.htm
'        'http://tmail.mooo.com:8080/?data=val1              'not operational. Will be AJAX call.
'        'http://tmail.mooo.com:8080/anyinvalidurl           'shows 403 error
'
'        '#define HTTP_HANDLER myHTTP_HANDLER
'        #define HTTP_HANDLER PortsStatus_HTM
'        #define etherBufferSize 1000
'
'        sub myHTTP_HANDLER
'
'            #ifdef ENC28j60_ShowHTTPInfo_Supported
'                HSerPrint "/"
'                HSerPrint CommandLineString
'                HSerPrintCRLF
'            #endif
'
'            if CommandLineString="index.htm" then
'              Index_HTM
'              exit Sub
'            end if
'
'            if left(CommandLineString,1)="?" then
'              PortsStatus_HTM
'              exit Sub
'            end if
'
'            'else.......
'            Error400_HTM
'            #ifdef ENC28j60_ShowHTTPInfo_Supported
'                HSerPrintCRLF
'            #endif
'
'        end sub
'
'
'        Sub PortsStatus_HTM
'            dim analogChannel as byte
'            dir porta.0 in
'            dir porta.1 in
'            dir porta.2 in
'            dir porta.3 in
'
'            'Auto refresh web page
'            HTTPPrint( "REFRESH: 5",HTTPPrintCRLF )
'            'You must close off the header by add
'            HTTPPrint( "", HTTPPrintCRLF )
'
'            HTTPPrint ( "<html><font face=helvetica>")
'            HTTPPrint ( "<img alt=""GCB Logo!"" title=""Great Cow BASIC v0.39"" ")
'            HTTPPrint ( "src=""http://goo.gl/FZ4v4e"" height=""36"" ")
'            HTTPPrint ("width=""243""><br><br />" )
'            HTTPPrint  ("&nbsp;&nbsp;Evan is ")
'
'            if ReadAD( 0 ) < 50 then
'                HTTPPrint ("not ")
'            end if
'            HTTPPrint " in the lab at the moment.."
'
'            if ReadAD( 0 ) < 50 then
'                HTTPPrint ("probably working elsewhere, having family time or even asleep!")
'            Else
'                HTTPPrint ("probably working on a Great Cow BASIC solution!")
'            end if
'
'
'            HTTPPrint "<br /><br />"
'            HTTPPrint "&nbsp;&nbsp;Analog inputs are: "
'                HTTPPrint "<br />"
'            for analogChannel = 0 to 3
'                HTTPPrint "<br />&nbsp;&nbsp;ADC"
'                HTTPPrint str(analogChannel)
'                HTTPPrint ": "
'                HTTPPrint str(ReadAD( analogChannel ))
'                HTTPPrint "<br />"
'            next
'            HTTPPrint "<br />"
'            HTTPPrint "&nbsp;&nbspPorts A:&nbsp;" + ByteToBin(porta)
'            HTTPPrint "&nbsp;&nbsp;B:&nbsp;" + ByteToBin(portb)
'            HTTPPrint "&nbsp;&nbsp;C:&nbsp;" + ByteToBin(portc)
'            HTTPPrint "&nbsp;&nbsp;E:&nbsp;" + ByteToBin(porte)
'            HTTPPrint "<br /><br />"
'            HTTPPrint "&nbsp;&nbsp;Source: " + str(T_ip_destaddr0)
'            HTTPPrint "." + str(T_ip_destaddr1)
'            HTTPPrint "." + str(T_ip_destaddr2)
'            HTTPPrint "." + str(T_ip_destaddr3)
'            HTTPPrint "<br /><br />"
'
'            HTTPPrint ( "<img alt=""Lab"" title=""Great Cow BASIC"" ")
'            if ReadAD( 0 ) < 50 then
'
'                HTTPPrint ( "src=""http://goo.gl/yNg5Tr"" height=""217"" width=""386"" ")
'            Else
'
'                HTTPPrint ( "src=""http://goo.gl/NUOFWu"" height=""424"" width=""239"" ")
'
'            end if
'            HTTPPrint ("><br><br />" )
'
'            HTTPPrint ("</html>")
'
'            HTTPSend
'        End Sub
'
'        Sub Error400_HTM
'          HTTPPrint( "", HTTPPrintCRLF )
'
'          HTTPPrint "<html><font face=helvetica>"
'          HTTPPrint ( "<img alt=""GCB"" title=""Great Cow BASIC"" ")
'          HTTPPrint ( "src=""http://goo.gl/FZ4v4e"" height=""36"" width=""243""><br>")
'          HTTPPrint "<p><b>403.</b> Forbidden:  The request was a valid "
'          HTTPPrint "request, but the server is refusing to respond "
'          HTTPPrint "to it. <br /><br /><b>403.</b> Error semantically means "
'          HTTPPrint "unauthorized"
'          HTTPPrint ", i.e. the user does not have the necessary permissions"
'          HTTPPrint "for the resource."
'          HTTPPrint "<p>URL <code>/"
'          HTTPPrint CommandLineString
'          HTTPPrint "</code> was not found.  </b></b>That is all we know."
'
'          HTTPPrint "</html>"
'
'          HTTPSend
'
'
'        end sub
'
'
'
'        sub Index_HTM
'
'          dim TableLoc as word
'          HTTPPrint( "", HTTPPrintCRLF )
'
'          For [word]TableLoc = 1 to SizeofTable1
'              ReadTable index1, TableLoc,etherBuffer(arrayloc)
'              ;Want to see the HTML? uncomment..
'        '                          HSerSend etherBuffer(arrayloc)
'              arrayloc = arrayloc +1
'          Next
'
'        end sub




''FILE:ENC28J60.h

'
'It is needed to called EtherParameters to setup the essential variables before we call any hardware specific methods.
#startup  EtherParameters 99

#define Ethernet_Initialise  ENC28j60_Init

#define ETHERNET_TYPE                 ETHERNET_TYPE_ENC28j60
#define ENC28j60_SPI_Command          SPIMode MasterSlow, 0

    #Define ENC28j60_DI     Ethernet_DI
    #Define ENC28j60_DO     Ethernet_DO
    #Define ENC28j60_SCK    Ethernet_SCK
    #Define ENC28j60_CS     Ethernet_CS
    #Define ENC28j60_RESET  Ethernet_RESET


sub ENC28j60_Init( in macaddr() )
ddebug = 0
HSerPrintCRLF

HSerPrint "ENC28j60_Init( in macaddr() )"
HSerPrintCRLF
      ''' Device ChipSelect control
      '''
      #define ENC28j60_Select         Set ENC28j60_CS off
      #define ENC28j60_Deselect       Set ENC28j60_CS on
      #define ENC28j60_Reset_CMD      Set ENC28j60_RESET on: Wait 20 ms :Set ENC28j60_RESET off: Wait 20 ms :Set ENC28j60_RESET on: Wait 20 ms


      Dir ENC28j60_DI in
      Dir ENC28j60_DO Out
      Dir ENC28j60_SCK Out
      Dir ENC28j60_CS out
      Dir ENC28j60_RESET out

      'Initial state of ports required for SW SPI
      set ENC28j60_DO off
      set ENC28j60_SCK off
      set ENC28j60_CS off



DIR PORTb.1 Out
DIR PORTb.3 Out
DIR PORTb.0 IN
DIR Ethernet_CS OUT


      'Reset the NIC
      ENC28j60_Deselect

      Repeat 5
          ENC28j60_Reset_CMD
      End Repeat

      ENC28j60_Select
      SPIMode MasterFast, 0
      FastHWSPITransfer( ENC28j60_SOFT_RESET, temp )
      lastselectedBank = 99
HSerPrint "Pre WAIT1"
HSerPrintCRLF
ddebug=1
      wait while ( (ENC28j60_ReadReg( ESTAT ) & ESTAT_CLKRDY ) <> ESTAT_CLKRDY)
HSerPrint "pOST WAIT1"
HSerPrintCRLF

      'Initialize NIC
      ENC28j60_writeReg(ECON1, 0xC1) 'Hold it in Reset
      ENC28j60_writeReg(ECON2, 0x80) 'Set the AUTOINC bit

      'Configure interrupts
      ENC28j60_writeReg(EIR, 0x00) 'Reset interrupt flags
      ENC28j60_writeReg(EIE,  0xC1)  'Interrupts: Packet reception and buffer errors
      ENC28j60_writeReg(EWOLIE, 0x00)  'Disable wake-on-lan interrupts
      ENC28j60_writeReg(EWOLIR, 0x00)  'Clear wake-on-lan interrupt flags

      'Allocate TX & RX buffers
      ENC28j60_writeReg(ETXSTL, ENC_TXBUF_STL)
      ENC28j60_writeReg(ETXSTH, ENC_TXBUF_STH)
      ENC28j60_writeReg(ETXNDL, ENC_TXBUF_NDL)
      ENC28j60_writeReg(ETXNDH, ENC_TXBUF_NDH)  'TX Buffer : 1800 bytes
      ENC28j60_writeReg(ERXSTL, ENC_RXBUF_STL)
      ENC28j60_writeReg(ERXSTH, ENC_RXBUF_STH)
      ENC28j60_writeReg(ERXNDL, ENC_RXBUF_NDL)
      ENC28j60_writeReg(ERXNDH, ENC_RXBUF_NDH)  'RX Buffer : 6390 bytes
      ENC28j60_writeReg(ERDPTL, ENC_RXBUF_STL)
      ENC28j60_writeReg(ERDPTH, ENC_RXBUF_STH)

      ENC28j60_writeReg(ERXRDPTL, ENC_RXBUF_STL)
      ENC28j60_writeReg(ERXRDPTH, ENC_RXBUF_STH) 'RX Pointers (same)

      nextpacketptr = ENC_RXBUF_ST

      'Set Receive Filters
'      ENC28j60_writeReg( ERXFCON, 0xA1) 'Receive unicasts or broadcasts


' For broadcast packets we allow only ARP packtets
' All other packets should be unicast only for our mac (MAADR)
'
' The pattern to match on is therefore
' Type     ETH.DST
' ARP      BROADCAST
' 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
' in binary these poitions are:11 0000 0011 1111
' This is hex 303F->EPMM0=0x3f,EPMM1=0x30

'      ENC28j60_writeReg( EPMCSH, 0xf7)
'      ENC28j60_writeReg( EPMCSL, 0xf9)
'      ENC28j60_writeReg( EPMM0, 0x3f)
'      ENC28j60_writeReg( EPMM1, 0x30)

'      ENC28j60_bitClear( ERXFCON, ERXFCON_ANDOR ) 'Set filter bit
'
'      Enc28j60_bitSet( ERXFCON, ERXFCON_UCEN ) 'Set filter bit
'
'      ENC28j60_bitClear( ERXFCON, ERXFCON_CRCEN ) 'Set filter bit
'
'      Enc28j60_bitSet( ERXFCON, ERXFCON_BCEN ) 'Set filter bit
'
'      ENC28j60_bitClear( ERXFCON, ERXFCON_MPEN ) 'UnSet filter bit
'
'      Enc28j60_bitSet( ERXFCON, ERXFCON_PMEN ) 'Set filter bit

'      ENC28j60_writeReg( ERXFCON, ERXFCON_UCEN | ERXFCON_MCEN | ERXFCON_BCEN | ERXFCON_PMEN)
;      Cannot get filter to Work, so use the folllowing
      ENC28j60_writeReg( ERXFCON, ERXFCON_CRCEN )

      'Miscancellous
      ENC28j60_writeReg(EFLOCON, 0x00) 'Disable flow control sending
      ENC28j60_writeReg(ECOCON, 0x00) 'Disable Clock Out pin
      ENC28j60_writeReg(EBSTCON, 0x00) 'Disable built-in self test controller

      'Wait for the MAC & PHY parts to be operational
      wait while ( (ENC28j60_ReadReg(ESTAT) & ESTAT_CLKRDY) <> ESTAT_CLKRDY)
HSerPrint "pOST WAIT2"
HSerPrintCRLF

      'Initialize MII interface
      ENC28j60_writeReg(MISTAT, 0x00)  'Clear MII status register
      ENC28j60_writeReg(MICMD, 0x00)   'Clear MII command register
'      ENC28j60_writeReg(MICON1, 0x02)  'Fast MII operation
'      ENC28j60_writeReg(MICON2, 0x00)  'Release MII interface from reset

      'Initialize MAC subsystem
      ENC28j60_writeReg(MACON1, 0b00001101 )  'Enable packet reception
'      ENC28j60_writeReg(MACON2, 0x00)  'Release the MAC subsystem from reset
'      ENC28j60_writeReg(MACON3, 0xB1)  'Auto Pad + CRC + Full Duplex
      ENC28j60_writeReg(MACON3, 0x32)  'Auto Pad to 60 bytes + CRC + Half Duplex + Check frame length
      ENC28j60_writeReg(MACON4, 0x01)  'Need valid preamble
'      ENC28j60_writeReg(MAPHSUP, b'00010000') 'Release MAC-PHY support from Reset
      ENC28j60_writeReg(MAMXFLL, 0xEE)
      ENC28j60_writeReg(MAMXFLH, 0x05)  'Maximum frame length
      ENC28j60_writeReg(MABBIPG, 0x12) 'IEEE BTB Inter Packet Gap
      ENC28j60_writeReg(MAIPGL, 0x12)
      ENC28j60_writeReg(MAIPGH, 0x0C)  'IEEE Non BTB Inter Packet Gap

      'Leave MACLCON1 and MACLCON2 to their default values
      'Set MAC Address
      ENC28j60_writeReg(MAADR0, macaddr(2))
      ENC28j60_writeReg(MAADR1, macaddr(1))
      ENC28j60_writeReg(MAADR2, macaddr(4))
      ENC28j60_writeReg(MAADR3, macaddr(3))
      ENC28j60_writeReg(MAADR4, macaddr(6))
      ENC28j60_writeReg(MAADR5, macaddr(5))

HSerPrint "pOST mac"
HSerPrintCRLF


'      'Initialize PHY subsystem
      ENC28j60_writePhyReg(PHCON1, 0x00, 0x00)  'Half duplex
HSerPrint "writePhyReg1"
HSerPrintCRLF
      ENC28j60_writePhyReg(PHCON2, 0x00, 0x00)
      ENC28j60_writePhyReg(PHLCON, 0B00000100, 0B01110110 )
      ENC28j60_writePhyReg(PHIE, 0x00, 0x00)  'Disable interrupts
HSerPrint "writePhyReg2"
HSerPrintCRLF
      'Initialization done, release the NIC from reset
      ENC28j60_writeReg(ECON1, 0B00010100 )
'      ENC28j60_writeReg(ECON1, B'00000100')
      'We are done!!
      'A real highLIGHT, a led test. If your RJ45-connector has LED's for LINK and DATA you can test them with this small line. Put it somewhere after the ENC28j60init.
      'Set address of PHY register to write
'      ENC28j60_writePhyReg ( PHLCON, 0xA2, 0x0A )
'      wait 5 s

      'Set LEDs to the normal settings
       ENC28j60_writePhyReg ( PHLCON, 0x76, 0x04 )
HSerPrint "eXIT init"
HSerPrintCRLF

End Sub





'/* Sets bits in a register */
Sub ENC28j60_bitSet( in addr,  in ENC_Outbyte as byte )
'       banktobeselected = ( addr & BANK_MASK) / 32
'        HSerPrintByteCRLF banktobeselected

        banktobeselected = ( addr & BANK_MASK)
        Repeat 5
            set c off
            rotate banktobeselected right
        end repeat
'        HSerPrintByteCRLF banktobeselected
'        HSerPrintCRLF

        if lastselectedBank <> banktobeselected then
          if ( ( addr & ADDR_MASK )  <= EIE  ) then
              ENC28j60_selectBank ( banktobeselected, addr )
          end if
        Else
          lastselectedBank = banktobeselected
        end if

        ENC28j60_Select
        FastHWSPITransfer( ENC28j60_BIT_FIELD_SET | (addr AND ADDR_MASK ), temp )
        FastHWSPITransfer( ENC_Outbyte, temp )
        ENC28j60_Deselect

end sub


Sub ENC28j60_bitClear( in addr,  in ENC_Outbyte as byte )
'       banktobeselected = ( addr & BANK_MASK) / 32
        banktobeselected = ( addr & BANK_MASK)
        Repeat 5
            set c off
            rotate banktobeselected right
        end repeat

        if lastselectedBank <> banktobeselected then
          if ( ( addr & ADDR_MASK )  <= EIE  ) then
              ENC28j60_selectBank ( banktobeselected, addr )
          end if
        Else
          lastselectedBank = banktobeselected
        end if

        ENC28j60_Select
        FastHWSPITransfer( ENC28j60_BIT_FIELD_CLR | (addr AND ADDR_MASK ), temp )
        FastHWSPITransfer( ENC_Outbyte, temp )
        ENC28j60_Deselect

end sub


Sub ENC28j60_writebuffer ( in pcktlen As Word )

    dim eth_counter as Word

    'set the write pointer to start of transmit buffer area
    ENC28j60_writeReg(ewrptl, ENC_TXBUF_STL)
    ENC28j60_writeReg(ewrpth, ENC_TXBUF_STH)

    'Send as fast as we can
    ENC28j60_Select

   'Send Read address
    Set WCOL Off
    'Put byte to send into buffer
    'Will start transfer
    SSPBUF = ENC28j60_write_buf_mem
    'Read buffer
    Wait While BF = Off
    temp = SSPBUF

    SSPBUF = 0x0E
    'Read buffer
    Wait While BF = Off
    temp = SSPBUF


    for eth_counter = 1 to pcktlen
      if eth_counter > etherBufferSize then Exit For
      SSPBUF = etherbuffer(eth_counter)
      'Read buffer
       Wait While BF = Off
       temp = SSPBUF
    next
    ENC28j60_Deselect


End Sub

; writes byte ENC_Outbyte in ENC register addr of the current bank
sub ENC28j60_writeReg( in addr,  in ENC_Outbyte as byte )
'       banktobeselected = ( addr & BANK_MASK) / 32
        banktobeselected =  ( addr & BANK_MASK)
        Repeat 5
            set c off
            rotate banktobeselected right
        end Repeat

        if lastselectedBank <> banktobeselected then
          if ( ( addr & ADDR_MASK )  <= EIE  ) then
              ENC28j60_selectBank ( banktobeselected, addr )
          end if
        Else
          lastselectedBank = banktobeselected
        end if

        ENC28j60_Select
        FastHWSPITransfer( ENC28j60_WRITE_CTRL_REG | (addr AND ADDR_MASK ), temp )
        FastHWSPITransfer( ENC_Outbyte, temp )
        ENC28j60_Deselect

end sub


sub ENC28j60_writePhyReg( in PhyRegaddr,  in ENC_Outbyte1 as byte , in ENC_Outbyte2 as byte )
HSerPrint 1
WAIT 1 S
HSerPrint "("
HSerPrint hex(MISTAT)
HSerPrint ")"

        ddebug =1
        'Wait for the MII interface to be ready
         while ((ENC28j60_ReadReg( MISTAT ) & MISTAT_BUSY ) = MISTAT_BUSY )
HSerPrint 2
        ENC28j60_writeReg( MIREGADR, PhyRegaddr )
HSerPrint 3
        ENC28j60_writeReg( MIWRL, ENC_Outbyte1 )
        ENC28j60_writeReg( MIWRH, ENC_Outbyte2 )
HSerPrint 98

HSerPrintCRLF
HSerPrint "("
HSerPrint hex(MISTAT)
HSerPrint ")"
        'Wait for the MII interface to be ready


        wait while ((ENC28j60_ReadReg( MISTAT ) & MISTAT_BUSY ) = MISTAT_BUSY )
HSerPrint 99
end sub

        dim ddebug as byte
Sub ENC28j60_regdump

#define ENC28j60_Detailed_RegDump

    dim ENC28j60_data as word alias I_checksum16_H, I_checksum16
    HSerPrintCRLF
    HSerPrint "Registerdump ENC28j60"

    ENC28j60_data = ENC28j60_ReadReg( erevid )
    HSerPrint " ENC Rev " + str( ENC28j60_data )
    HSerPrint " Build 037"
    HSerPrintCRLF

    HSerPrintCRLF

    'ok
    HSerPrint "Cntrl: ECON1 ECON2 ESTAT  EIR  EIE"
    HSerPrintCRLF
    ENC28j60_data = ENC28j60_ReadReg( econ1)
    HSerPrint "       " + Hex(ENC28j60_data)
    ;
    ENC28j60_data = ENC28j60_ReadReg( econ2)
    HSerPrint "    " + Hex(ENC28j60_data);

    ENC28j60_data = ENC28j60_ReadReg( estat)
    HSerPrint "    " + Hex(ENC28j60_data);

    ENC28j60_data = ENC28j60_ReadReg (eir)
    HSerPrint "     " + Hex(ENC28j60_data);

    ENC28j60_data = ENC28j60_ReadReg( eie)
    HSerPrint "   " + Hex(ENC28j60_data)
    HSerPrintCRLF

    'ok
    HSerPrint "MAC  : MACON1  MACON3  MACON4  MAC-Address"
    HSerPrintCRLF
    ENC28j60_data = ENC28j60_ReadReg( macon1)
    HSerPrint "       " + Hex(ENC28j60_data);
'    ENC28j60_data = ENC28j60_ReadReg( macon2)
'    HSerPrint "      " + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg( macon3)
    HSerPrint "      " + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg( macon4)
    HSerPrint "      " + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg( maadr5)
    HSerPrint "      " + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg( maadr4)
    HSerPrint "." + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg( maadr3)
    HSerPrint "." + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg( maadr2)
    HSerPrint "." + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg( maadr1)
    HSerPrint "." + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg( maadr0)
    HSerPrint "." + Hex(ENC28j60_data)
    HSerPrintCRLF

    HSerPrint "Rx   : ERXST  ERXND  ERXWRPT ERXRDPT ERXFCON EPKTCNT MAMXFL"
    HSerPrintCRLF
    ENC28j60_data = ENC28j60_ReadReg(erxsth)
    HSerPrint "       " + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg(erxstl)
    HSerPrint Hex(ENC28j60_data);

    ENC28j60_data = ENC28j60_ReadReg(erxndh)
    HSerPrint "   " + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg(erxndl)
    HSerPrint Hex(ENC28j60_data);

    ENC28j60_data_h = ENC28j60_ReadReg(erxwrpth)
    HSerPrint "   " + Hex(ENC28j60_data_h);

    ENC28j60_data = ENC28j60_ReadReg(erxwrptl)
    HSerPrint Hex(ENC28j60_data);



    ENC28j60_data_h = ENC28j60_ReadReg(erxrdpth)
    HSerPrint "    " + Hex(ENC28j60_data_h);
    ENC28j60_data = ENC28j60_ReadReg(erxrdptl)
    HSerPrint Hex(ENC28j60_data);

    'Byte value to show. The ERXFCON: ETHERNET RECEIVE FILTER CONTROL REGISTER
    ENC28j60_data = ENC28j60_ReadReg(erxfcon)
    HSerPrint "    " + Hex(ENC28j60_data);

    'Byte value to show
    ENC28j60_data = ENC28j60_ReadReg(epktcnt)
    HSerPrint "      " + Hex(ENC28j60_data);

    'Byte value to show. Maximum Frame Length hi Byte
    ENC28j60_data = ENC28j60_ReadReg(mamxflh)
    HSerPrint "      " + Hex(ENC28j60_data);

    'Byte value to show. Maximum Frame Length lo Byte
    ENC28j60_data = ENC28j60_ReadReg(mamxfll)
    HSerPrint Hex(ENC28j60_data)


    HSerPrintCRLF
    HSerPrint "Tx   : ETXST  ETXND  EWRPT  MACLCON1 MACLCON2"
    HSerPrintCRLF
    ENC28j60_data = ENC28j60_ReadReg(etxsth)
    HSerPrint "       " + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg(etxstl)
    HSerPrint Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg(etxndh)
    HSerPrint "   " + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg(etxndl)
    HSerPrint Hex(ENC28j60_data);

    ENC28j60_data = ENC28j60_ReadReg(EWRPTH)
    HSerPrint "   " +  Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg(EWRPTl)
    HSerPrint Hex(ENC28j60_data);


    ENC28j60_data = ENC28j60_ReadReg(maclcon1)
    HSerPrint "   " + Hex(ENC28j60_data);
    ENC28j60_data = ENC28j60_ReadReg(maclcon2)
    HSerPrint "       " + Hex(ENC28j60_data);

'   Capability is not valid in all devices
'    ENC28j60_data = ENC28j60_ReadReg(maphsup)
'    HSerPrint "       " + Hex(ENC28j60_data)
    HSerPrintCRLF 2


End Sub


sub ENC28j60_selectBank ( in banktobeselected, in addr )

        'Set to ENC memory bank addr
        ENC28j60_Select
        FastHWSPITransfer(BFCCMD | ECON1, temp)
        FastHWSPITransfer( 0b00000011, temp)
        ENC28j60_Deselect
        'Set to ENC memory bank addr
        ENC28j60_Select
        FastHWSPITransfer(BFSCMD | ECON1, temp)
        Select case banktobeselected
'          case 0
'
'            FastHWSPITransfer( 0b00000000 , temp)

          case 1

            FastHWSPITransfer( 0b00000001 , temp)

          case 2

            FastHWSPITransfer( 0b00000010 , temp)

          case 3

            FastHWSPITransfer( 0b00000011 , temp)

        End Select
        ENC28j60_Deselect
        lastselectedBank = banktobeselected
end sub

'COCON2:COCON0: Clock Output Configuration bits
'111 = Reserved for factory test. Do not use. Glitch prevention not assured.
'110 = Reserved for factory test. Do not use. Glitch prevention not assured.
'101 = CLKOUT outputs main clock divided by 8 (3.125 MHz)
'100 = CLKOUT outputs main clock divided by 4 (6.25 MHz)
'011 = CLKOUT outputs main clock divided by 3 (8.333333 MHz)
'010 = CLKOUT outputs main clock divided by 2 (12.5 MHz)
'001 = CLKOUT outputs main clock divided by 1 (25 MHz)
'000 = CLKOUT is disabled. The pin is driven low
sub ENC28j60_setfrequency ( in ENC_Outbyte as byte )

    'Has to be less then 5
     if ENC_Outbyte > 5 then ENC_Outbyte = 5
     ENC28j60_WriteReg( ECOCON, ENC_Outbyte )

end sub




Sub ENC28j60_readbuffer( optional in etherGetLength as word = 1 )
  dim eth_counter as Word
'ENC28j60_regdump
'  if etherGetLength  > 1518 then Exit Sub

  ' Initiate SPI command
  ENC28j60_Select
  ' Send command

  ' Read bytes
  Set WCOL Off
  'Send Read Buffer Memory command
  SSPBUF = ENC28j60_READ_BUF_MEM
  Wait While BF = Off
  'Set data result
  temp = SSPBUF


  for eth_counter = 1 to etherGetLength
    if eth_counter > etherBufferSize then
        exit for
    end if
    SSPBUF = 0
    Wait While BF = Off
    etherbuffer( eth_counter ) = SSPBUF
  next



  if etherGetLength > etherBufferSize then

    for eth_counter = etherBufferSize+1 to etherGetLength
      SSPBUF = 0
      Wait While BF = Off
      temp = SSPBUF
    next

  End if

  #ifdef debug
      HSersend 9
      HSerPrint " Rd: 0x"
      HSerPrint eth_counter
      HSersend 9
  #endif

  ' Finish SPI command
  ENC28j60_Deselect
End Sub

function ENC28j60_readReg( in addr ) as byte

    dim SSPBUFtemp1, SSPBUFtemp2  as byte
'        banktobeselected =  ( addr & BANK_MASK) / 32
        if ddebug = 1 then
HSerPrint "A)"
HSerPrint hex(addr)
HSerPrint ":*"
end if
        banktobeselected =  ( addr & BANK_MASK)
        Repeat 5
            set c off
            rotate banktobeselected right
        end repeat
        if ddebug = 1 then
HSerPrint "($"
HSerPrint banktobeselected
HSerPrint ":)"
      end if
'       'These registers (EIE, EIR, ESTAT, ECON2, ECON1)
'       'are present in all banks, no need to switch bank
        if lastselectedBank <> banktobeselected then

          if ( ( addr & ADDR_MASK ) <= EIE  ) then
              ENC28j60_selectBank ( banktobeselected, addr )
          else
              lastselectedBank = banktobeselected
          end if
        end if

        ENC28j60_Select

        #ifdef PIC
             'Send Read address
              Set WCOL Off
              'Put byte to send into buffer
              'Will start transfer
if ddebug = 1 then HSerPrint hex(ENC28j60_READ_CTRL_REG | ( addr AND ADDR_MASK ))
if ddebug = 1 then HSerPrintCRLF


              SPITransfer ( ENC28j60_READ_CTRL_REG | ( addr AND ADDR_MASK ), SSPBUFtemp1 )
              SPITransfer ( SSPBUFtemp2, SSPBUFtemp2 )
              SPITransfer ( SSPBUFtemp2, ENC28j60_ReadReg  )

              if ddebug = 1 then
                HSerPrint "<"
                HSerPrintCRLF
                HSerPrint hex(SSPBUFtemp1)
                HSerPrintCRLF
                HSerPrint hex(SSPBUFtemp2)
                HSerPrintCRLF

                HSerPrint ByteToBin(ENC28j60_ReadReg )
                HSerPrint ">"
                do
                loop
              end if
        #endif

        #ifdef aVR

        #endif
        ENC28j60_Deselect



end function




ConfigurationDetails:

'Important bit maps
#define EPKTDEC 0x40
#define DMAST   0x20
#define CSUMEN  0x10
#define TXRTS   0x08
#define MIIRD   0x01
#define BUSY    0x01
#define CLKRDY  0x01
#define RXEN    0x04

Memory_Locations_Script:
'Set ENC28j60 Memory locations
#script

' Buffer boundaries applied to internal 8K ram
' Entire available packet buffer space is allocated.
' Give TX buffer space for one full ethernet frame (~1500 bytes)
' Receive buffer gets the remainder

  TXSTART_INIT  = 0x1A00
  TXSTART_INITL = INT(TXSTART_INIT) AND 255
  TXSTART_INITH = INT( INT( TXSTART_INIT ) / 0x100 )

  ENC_TXBUF_ST = 0x1670

  ENC_TXBUF_STL = INT(ENC_TXBUF_ST) AND 255
  ENC_TXBUF_STH = INT( INT( ENC_TXBUF_ST ) / 0x100 )
  ENC_TXBUF_ND = 0x1FFF
  ENC_TXBUF_NDL = INT(ENC_TXBUF_ND) AND 255
  ENC_TXBUF_NDH = INT( INT(ENC_TXBUF_ND) / 0x100 )

  ENC_RXBUF_ST  = 0x0000
  ENC_RXBUF_STL = INT(ENC_RXBUF_ST)  AND 255
  ENC_RXBUF_STH = INT( INT( ENC_RXBUF_ST ) / 0x100 )
  ENC_RXBUF_ND  = 0x166E

  ENC_RXBUF_NDL = INT(ENC_RXBUF_ND) AND 255
  ENC_RXBUF_NDH = INT( INT(ENC_RXBUF_ND) / 0x100 )

  ENC_TX_BUF1 =  ENC_TXBUF_ST
  ENC_TX_BUF2 =  ENC_TX_BUF1 + 300
  ENC_TX_BUF3 =  ENC_TX_BUF2 + 300
  ENC_TX_BUF4 =  ENC_TX_BUF3 + 300
  ENC_TX_BUF5 =  ENC_TX_BUF4 + 300
  ENC_TX_BUF6 =  ENC_TX_BUF5 + 300
  ENC_TX_BUF7 =  ENC_TX_BUF6 + 300
  ENC_TX_BUF8 =  ENC_TX_BUF7 + 300
  ENC_TX_BUFNB = 8
#endscript


' ENC28j60 Control Registers
#define WCRCMD  b'01000000'      ; write control register
#define BFCCMD  b'10100000'      ; bit field clear
#define BFSCMD  b'10000000'      ; bit field set

' Control register definitions are a combination of address,
' bank number, and Ethernet/MAC/PHY indicator bits.
' - Register address  (bits 0-4)
' - Bank number (bits 5-6)
' - MAC/MII indicator (bit 7)
'
#define ADDR_MASK 0x1F
#define BANK_MASK 0x60
#define SPRD_MASK 0x80
'  All-bank registers'
#define BANK0   0
#define BANK1   1
#define BANK2   2
#define BANK3   3


#define EIE   0x1B
#define EIR   0x1C
#define ESTAT   0x1D
#define ECON2   0x1E
#define ECON1   0x1F
'  Bank 0 registers'
#define ERDPTL    (0x00|0x00)
#define ERDPTH    (0x01|0x00)
#define EWRPTL    (0x02|0x00)
#define EWRPTH    (0x03|0x00)
#define ETXSTL    (0x04|0x00)
#define ETXSTH    (0x05|0x00)
#define ETXNDL    (0x06|0x00)
#define ETXNDH    (0x07|0x00)
#define ERXSTL    (0x08|0x00)
#define ERXSTH    (0x09|0x00)
#define ERXNDL    (0x0A|0x00)
#define ERXNDH    (0x0B|0x00)
#define ERXRDPTL  (0x0C|0x00)
#define ERXRDPTH  (0x0D|0x00)
#define ERXWRPTL  (0x0E|0x00)
#define ERXWRPTH  (0x0F|0x00)
#define EDMASTL   (0x10|0x00)
#define EDMASTH   (0x11|0x00)
#define EDMANDL   (0x12|0x00)
#define EDMANDH   (0x13|0x00)
#define EDMADSTL  (0x14|0x00)
#define EDMADSTH  (0x15|0x00)
#define EDMACSL   (0x16|0x00)
#define EDMACSH   (0x17|0x00)
'  Bank 1 registers'
#define EHT0    (0x00|0x20)
#define EHT1    (0x01|0x20)
#define EHT2    (0x02|0x20)
#define EHT3    (0x03|0x20)
#define EHT4    (0x04|0x20)
#define EHT5    (0x05|0x20)
#define EHT6    (0x06|0x20)
#define EHT7    (0x07|0x20)
#define EPMM0   (0x08|0x20)
#define EPMM1   (0x09|0x20)
#define EPMM2   (0x0A|0x20)
#define EPMM3   (0x0B|0x20)
#define EPMM4   (0x0C|0x20)
#define EPMM5   (0x0D|0x20)
#define EPMM6   (0x0E|0x20)
#define EPMM7   (0x0F|0x20)
#define EPMCSL    (0x10|0x20)
#define EPMCSH    (0x11|0x20)
#define EPMOL   (0x14|0x20)
#define EPMOH   (0x15|0x20)
#define EWOLIE    (0x16|0x20)
#define EWOLIR    (0x17|0x20)
#define ERXFCON   (0x18|0x20)
#define EPKTCNT   (0x19|0x20)
'  Bank 2 registers'
#define MACON1    (0x00|0x40|SPRD_MASK)
'  #define MACON2 (0x01|0x40|SPRD_MASK)'
#define MACON3    (0x02|0x40|SPRD_MASK)
#define MACON4    (0x03|0x40|SPRD_MASK)
#define MABBIPG   (0x04|0x40|SPRD_MASK)
#define MAIPGL    (0x06|0x40|SPRD_MASK)
#define MAIPGH    (0x07|0x40|SPRD_MASK)
#define MACLCON1  (0x08|0x40|SPRD_MASK)
#define MACLCON2  (0x09|0x40|SPRD_MASK)
#define MAMXFLL   (0x0A|0x40|SPRD_MASK)
#define MAMXFLH   (0x0B|0x40|SPRD_MASK)
'#define MAPHSUP    (0x0D|0x40|SPRD_MASK)
'#define MICON    (0x11|0x40|SPRD_MASK)
#define MICMD   (0x12|0x40|SPRD_MASK)
#define MIREGADR  (0x14|0x40|SPRD_MASK)
#define MIWRL   (0x16|0x40|SPRD_MASK)
#define MIWRH   (0x17|0x40|SPRD_MASK)
#define MIRDL   (0x18|0x40|SPRD_MASK)
#define MIRDH   (0x19|0x40|SPRD_MASK)
'  Bank 3 registers'
#define MAADR1    (0x00|0x60|SPRD_MASK)
#define MAADR0    (0x01|0x60|SPRD_MASK)
#define MAADR3    (0x02|0x60|SPRD_MASK)
#define MAADR2    (0x03|0x60|SPRD_MASK)
#define MAADR5    (0x04|0x60|SPRD_MASK)
#define MAADR4    (0x05|0x60|SPRD_MASK)
#define EBSTSD    (0x06|0x60)
#define EBSTCON   (0x07|0x60)
#define EBSTCSL   (0x08|0x60)
#define EBSTCSH   (0x09|0x60)
#define MISTAT    (0x0A|0x60|SPRD_MASK)
#define EREVID    (0x12|0x60)
#define ECOCON    (0x15|0x60)
#define EFLOCON   (0x17|0x60)
#define EPAUSL    (0x18|0x60)
#define EPAUSH    (0x19|0x60)
'  PHY registers'
#define PHCON1    0x00
#define PHSTAT1   0x01
#define PHHID1    0x02
#define PHHID2    0x03
#define PHCON2    0x10
#define PHSTAT2   0x11
#define PHIE    0x12
#define PHIR    0x13
#define PHLCON    0x14

'  ENC28j60 EIE Register Bit Definitions'
#define EIE_INTIE 0x80
#define EIE_PKTIE 0x40
#define EIE_DMAIE 0x20
#define EIE_LINKIE  0x10
#define EIE_TXIE  0x08
'  #define EIE_WOLIE  0x04 (reserved)'
#define EIE_TXERIE  0x02
#define EIE_RXERIE  0x01
'  ENC28j60 EIR Register Bit Definitions'
#define EIR_PKTIF 0x40
#define EIR_DMAIF 0x20
#define EIR_LINKIF  0x10
#define EIR_TXIF  0x08
'  #define EIR_WOLIF  0x04 (reserved)'
#define EIR_TXERIF  0x02
#define EIR_RXERIF  0x01
'  ENC28j60 ESTAT Register Bit Definitions'
#define ESTAT_INT 0x80
#define ESTAT_LATECOL 0x10
#define ESTAT_RXBUSY  0x04
#define ESTAT_TXABRT  0x02
#define ESTAT_CLKRDY  0x01
'  ENC28j60 ECON2 Register Bit Definitions'
#define ECON2_AUTOINC 0x80
#define ECON2_PKTDEC  0x40
#define ECON2_PWRSV 0x20
#define ECON2_VRPS  0x08
'  ENC28j60 ECON1 Register Bit Definitions'
#define ECON1_TXRST 0x80
#define ECON1_RXRST 0x40
#define ECON1_DMAST 0x20
#define ECON1_CSUMEN  0x10
#define ECON1_TXRTS 0x08
#define ECON1_RXEN  0x04
#define ECON1_BSEL1 0x02
#define ECON1_BSEL0 0x01
'  ENC28j60 MACON1 Register Bit Definitions'
#define MACON1_LOOPBK 0x10
#define MACON1_TXPAUS 0x08
#define MACON1_RXPAUS 0x04
#define MACON1_PASSALL  0x02
#define MACON1_MARXEN 0x01
'  ENC28j60 MACON2 Register Bit Definitions'
#define MACON2_MARST  0x80
#define MACON2_RNDRST 0x40
#define MACON2_MARXRST  0x08
#define MACON2_RFUNRST  0x04
#define MACON2_MATXRST  0x02
#define MACON2_TFUNRST  0x01
'  ENC28j60 MACON3 Register Bit Definitions'
#define MACON3_PADCFG2  0x80
#define MACON3_PADCFG1  0x40
#define MACON3_PADCFG0  0x20
#define MACON3_TXCRCEN  0x10
#define MACON3_PHDRLEN  0x08
#define MACON3_HFRMLEN  0x04
#define MACON3_FRMLNEN  0x02
#define MACON3_FULDPX 0x01
'  ENC28j60 MICMD Register Bit Definitions'
#define MICMD_MIISCAN 0x02
#define MICMD_MIIRD 0x01
'  ENC28j60 MISTAT Register Bit Definitions'
#define MISTAT_NVALID 0x04
#define MISTAT_SCAN 0x02
#define MISTAT_BUSY 0x01
'  ENC28j60 ERXFCON Register Bit Definitions'
#define ERXFCON_UCEN  0x80
#define ERXFCON_ANDOR 0x40
#define ERXFCON_CRCEN 0x20
#define ERXFCON_PMEN  0x10
#define ERXFCON_MPEN  0x08
#define ERXFCON_HTEN  0x04
#define ERXFCON_MCEN  0x02
#define ERXFCON_BCEN  0x01

'  ENC28j60 PHY PHCON1 Register Bit Definitions'
#define PHCON1_PRST 0x8000
#define PHCON1_PLOOPBK  0x4000
#define PHCON1_PPWRSV 0x0800
#define PHCON1_PDPXMD 0x0100
'  ENC28j60 PHY PHSTAT1 Register Bit Definitions'
#define PHSTAT1_PFDPX 0x1000
#define PHSTAT1_PHDPX 0x0800
#define PHSTAT1_LLSTAT  0x0004
#define PHSTAT1_JBSTAT  0x0002
'  ENC28j60 PHY PHSTAT2 Register Bit Definitions'
#define PHSTAT2_TXSTAT  (1 << 13)
#define PHSTAT2_RXSTAT  (1 << 12)
#define PHSTAT2_COLSTAT (1 << 11)
#define PHSTAT2_LSTAT (1 << 10)
#define PHSTAT2_DPXSTAT (1 << 9)
#define PHSTAT2_PLRITY  (1 << 5)
'  ENC28j60 PHY PHCON2 Register Bit Definitions'
#define PHCON2_FRCLINK  0x4000
#define PHCON2_TXDIS  0x2000
#define PHCON2_JABBER 0x0400
#define PHCON2_HDLDIS 0x0100
'  ENC28j60 PHY PHIE Register Bit Definitions'
#define PHIE_PLNKIE (1 << 4)
#define PHIE_PGEIE  (1 << 1)
'  ENC28j60 PHY PHIR Register Bit Definitions'
#define PHIR_PLNKIF (1 << 4)
#define PHIR_PGEIF  (1 << 1)

'  ENC28j60 Packet Control Byte Bit Definitions'
#define PKTCTRL_PHUGEEN   0x08
#define PKTCTRL_PPADEN    0x04
#define PKTCTRL_PCRCEN    0x02
#define PKTCTRL_POVERRIDE 0x01

'  ENC28j60 Transmit Status Vector'
#define TSV_TXBYTECNT   0
#define TSV_TXCOLLISIONCNT  16
#define TSV_TXCRCERROR    20
#define TSV_TXLENCHKERROR 21
#define TSV_TXLENOUTOFRANGE 22
#define TSV_TXDONE    23
#define TSV_TXMULTICAST   24
#define TSV_TXBROADCAST   25
#define TSV_TXPACKETDEFER 26
#define TSV_TXEXDEFER   27
#define TSV_TXEXCOLLISION 28
#define TSV_TXLATECOLLISION 29
#define TSV_TXGIANT   30
#define TSV_TXUNDERRUN    31
#define TSV_TOTBYTETXONWIRE 32
#define TSV_TXCONTROLFRAME  48
#define TSV_TXPAUSEFRAME  49
#define TSV_BACKPRESSUREAPP 50
#define TSV_TXVLANTAGFRAME  51

#define TSV_SIZE    7
'#define TSV_BYTEOF(x)    ((x) / 8)
'#define TSV_BITMASK(x)   (1 << ((x) % 8))
'#define TSV_GETBIT(x, y) (((x)[TSV_BYTEOF(y)] & TSV_BITMASK(y)) ? 1 : 0)

'  ENC28j60 Receive Status Vector'
#define RSV_RXLONGEVDROPEV  16
#define RSV_CARRIEREV   18
#define RSV_CRCERROR    20
#define RSV_LENCHECKERR   21
#define RSV_LENOUTOFRANGE 22
#define RSV_RXOK    23
#define RSV_RXMULTICAST   24
#define RSV_RXBROADCAST   25
#define RSV_DRIBBLENIBBLE 26
#define RSV_RXCONTROLFRAME  27
#define RSV_RXPAUSEFRAME  28
#define RSV_RXUNKNOWNOPCODE 29
#define RSV_RXTYPEVLAN    30

#define RSV_SIZE    6
'#define RSV_BITMASK(x)   (1 << ((x) - 16))
'#define RSV_GETBIT(x, y) (((x) & RSV_BITMASK(y)) ? 1 : 0)


'  SPI operation codes'
#define ENC28j60_READ_CTRL_REG  0x00
#define ENC28j60_READ_BUF_MEM 0x3A
#define ENC28j60_WRITE_CTRL_REG 0x40
#define ENC28j60_WRITE_BUF_MEM  0x7A
#define ENC28j60_BIT_FIELD_SET  0x80
#define ENC28j60_BIT_FIELD_CLR  0xA0
#define ENC28j60_SOFT_RESET 0xFF


#define TXEND_INIT    0x1FFF
  #define TXEND_INIT_b    0x1F
  #define TXEND_INIT_h    0xFF

'  Put RX buffer at 0 as suggested by the Errata datasheet'
#define RXSTART_INIT    0x0000
  #define RXSTART_INIT_b    0x00
  #define RXSTART_INIT_h    0x00

#define RXEND_INIT    0x19FF
  #define RXEND_INIT_b    0xFF
  #define RXEND_INIT_h    0x19


'  maximum ethernet frame length'
#define MAX_FRAMELEN    1518

'  Preferred half duplex: LEDA: Link status LEDB: Rx/Tx activity'
#define ENC28j60_LAMPS_MODE 0x3476




''FILE:Ethernet.h
'    Ethernet setup and buffer definitions for the GCBASIC compiler
'    Copyright (C) 2017 Evan Venn

'    This library is free software; you can redistribute it and/or
'    modify it under the terms of the GNU Lesser General Public
'    License as published by the Free Software Foundation; either
'    version 2.1 of the License, or (at your option) any later version.

'    This library is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
'    Lesser General Public License for more details.

'    You should have received a copy of the GNU Lesser General Public
'    License along with this library; if not, write to the Free Software
'    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

'    Notes
'    28/03/2017 Initial release


'Ethernet Hardware types
#define ETHERNET_TYPE_ENC28j60 1



    dim macaddr(6)
    dim ipaddr(4)
    dim ipserver(4)
    dim iprouter(4)
    dim macaddrrouter(4)
    dim sntpserveraddr(4)
    dim ipport as byte
    #define etherBufferSize 730
    dim etherbuffer(etherBufferSize)
    dim nextpacketptr as word
    dim I_checksum16 as word
    dim I_value16 as word alias I_checksum16_H, I_checksum16
    Dim Ip_id As Word
    dim T_udp_destport as word
    Dim hulp2 As Word
    Dim Incoming_ack as Long
    dim commandlineString as string * 12
    dim arrayloc,TableLoc as word
    dim HTTPStandardHeaderStatusBit as Byte
    dim HTTPSentTCPPacket, lastGet as byte
    dim TCPresult16, TableStartPoint as word
    #define HTTPPrintCRLF 1
    dim lastselectedBank, banktobeselected as byte
    dim SSPBUFtemp1, SSPBUFtemp2 as byte

sub EtherParameters

        macaddr =   0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ipaddr =    0,0,0,0
        ipserver =  0,0,0,0
        ipport = 80   'set a default value

        Ip_id = 0

'an outstanding GET is a pending flag
        lastGet = 0
        TableStartPoint =1
end sub



'Recommend not to change any of this definitions.

'IP Header Size
    #define IP_HeaderSize 14


'These defines all refer to the defined array - etherbuffer
    dim etherbuffer(etherBufferSize)



'Ethernet packet destination
    #Define T_enetpacketdest0 etherbuffer(0x01)
    #Define T_enetpacketdest1 etherbuffer(0x02)
    #Define T_enetpacketdest2 etherbuffer(0x03)
    #Define T_enetpacketdest3 etherbuffer(0x04)
    #Define T_enetpacketdest4 etherbuffer(0x05)
    #Define T_enetpacketdest5 etherbuffer(0x06)

'Ethernet packet source
    #Define T_enetpacketsrc0 etherbuffer(0x07)
    #Define T_enetpacketsrc1 etherbuffer(0x08)
    #Define T_enetpacketsrc2 etherbuffer(0x09)
    #Define T_enetpacketsrc3 etherbuffer(0x0A)
    #Define T_enetpacketsrc4 etherbuffer(0x0B)
    #Define T_enetpacketsrc5 etherbuffer(0x0C)

'Ethernet packet type
    '#Define T_enetpackettype As Word
    #Define T_enetpackettype0 etherbuffer(0x0D)
    #Define T_enetpackettype1 etherbuffer(0x0E)

'ARP definitions

    #Define T_arp_hwtype1 etherbuffer(0x10)

    #Define T_arp_prttype1 etherbuffer(0x12)
    #Define T_arp_hwlen etherbuffer(0x13)
    #Define T_arp_prlen etherbuffer(0x14)
    #Define T_arp_op1 etherbuffer(0x16)

'ARP source ip address
    '#Define T_arp_sipaddr As Long
    #Define T_arp_sipaddr0 etherbuffer(0x1D)
    #Define T_arp_sipaddr1 etherbuffer(0x1E)
    #Define T_arp_sipaddr2 etherbuffer(0x1F)
    #Define T_arp_sipaddr3 etherbuffer(0x20)

'ARP target IP address
    '#Define T_arp_tipaddr As Long
    #Define T_arp_tipaddr0 etherbuffer(0x27)
    #Define T_arp_tipaddr1 etherbuffer(0x28)
    #Define T_arp_tipaddr2 etherbuffer(0x29)
    #Define T_arp_tipaddr3 etherbuffer(0x2A)


'IP header layout IP version and header length
    #Define T_ip_header_pointer0 0x0F
    #Define T_ip_header_pointer1 0x21

'IP version and hardware type
    #Define T_ip_vers_len etherbuffer(0x0F)
    #Define T_arp_hwtype0 etherbuffer(0x0F)
'ARP definitions

    #Define T_arp_prttype0 etherbuffer(0x11)
    #Define T_arp_op0 etherbuffer(0x15)

'ARP source mac address
    #Define T_arp_src_enetpacket0 etherbuffer(0x17)
    #Define T_arp_src_enetpacket1 etherbuffer(0x18)
    #Define T_arp_src_enetpacket2 etherbuffer(0x19)
    #Define T_arp_src_enetpacket3 etherbuffer(0x1A)
    #Define T_arp_src_enetpacket4 etherbuffer(0x1B)
    #Define T_arp_src_enetpacket5 etherbuffer(0x1C)
'ARP source mac address
    #Define T_arp_dest_enetpacket0 etherbuffer(0x21)
    #Define T_arp_dest_enetpacket1 etherbuffer(0x22)
    #Define T_arp_dest_enetpacket2 etherbuffer(0x23)
    #Define T_arp_dest_enetpacket3 etherbuffer(0x24)
    #Define T_arp_dest_enetpacket4 etherbuffer(0x25)
    #Define T_arp_dest_enetpacket5 etherbuffer(0x26)

'TOS
    #Define T_tos etherbuffer(0x10)

'Packet Buffer length
    #Define T_ip_pktlen0 etherbuffer(0x11)
    #Define T_ip_pktlen1 etherbuffer(0x12)

'TCP buffers size, flags, offsets and ttl
    #Define T_id0 etherbuffer(0x13)
    #Define T_id1 etherbuffer(0x14)
    #Define T_flags etherbuffer(0x15)
    #Define T_offset etherbuffer(0x16)
    #Define T_ttl etherbuffer(0x17)

'Protocol type (ICMP=1, TCP=6, UDP=11)
    #Define T_ip_proto etherbuffer(0x18)

'Header checksum
    #Define T_ip_hdr_cksum0_pointer 0x19
    #Define T_ip_hdr_cksum0 etherbuffer(0x19)
    #Define T_ip_hdr_cksum1 etherbuffer(0x1A)

    '#Define T_ip_hdr_cksum As Word

'IP address of source
    #Define T_ip_srcaddr0 etherbuffer(0x1B)
    #Define T_ip_srcaddr1 etherbuffer(0x1C)
    #Define T_ip_srcaddr2 etherbuffer(0x1D)
    #Define T_ip_srcaddr3 etherbuffer(0x1E)
    '#Define T_ip_srcaddr As Long

'IP address of destination
    #Define T_ip_destaddr0 etherbuffer(0x1F)
    #Define T_ip_destaddr1 etherbuffer(0x20)
    #Define T_ip_destaddr2 etherbuffer(0x21)
    #Define T_ip_destaddr3 etherbuffer(0x22)
    '#Define T_ip_destaddr As Long

'ICMP parameters
    #Define T_icmp_type etherbuffer(0x23)
    #Define T_icmp_code etherbuffer(0x24)
    #Define T_icmp_cksum0 etherbuffer(0x25)
    #Define T_icmp_cksum1 etherbuffer(0x26)
    '#Define T_icmp_cksum As Word

'TCP Source port
    #Define Tcp_srcporth etherbuffer(0x23)
    #Define Tcp_srcportl etherbuffer(0x24)

'TCP Destination port
    #Define Tcp_destporth etherbuffer(0x25)
    #Define Tcp_destportl etherbuffer(0x26)

'TCP Sequence number
    #Define Tcp_seqnum3 etherbuffer(0x27)
    #Define Tcp_seqnum2 etherbuffer(0x28)
    #Define Tcp_seqnum1 etherbuffer(0x29)
    #Define Tcp_seqnum0 etherbuffer(0x2A)

'TCP Acknowledge number
    #Define Tcp_acknum3 etherbuffer(0x2B)
    #Define Tcp_acknum2 etherbuffer(0x2C)
    #Define Tcp_acknum1 etherbuffer(0x2D)
    #Define Tcp_acknum0 etherbuffer(0x2E)

'TCP Headets, flags and checksum
    #Define Tcp_hdr etherbuffer(0x2F)
    #Define Tcp_flags etherbuffer(0x30)
    #Define Tcp_cksum0 etherbuffer(0x33)
    #Define Tcp_cksum1 etherbuffer(0x34)
    '#Define Tcp_cksum As Word

'UDP source port
    #Define T_udp_srcport0 etherbuffer(0x23)
    #Define T_udp_srcport1 etherbuffer(0x24)
    '#Define T_udp_srcport As Word

'UDP destination port
    #Define T_udp_destport0 etherbuffer(0x25)
    #Define T_udp_destport1 etherbuffer(0x26)
    '#Define T_udp_destport As Word

'UDP length
  #Define T_udp_len0 etherbuffer(0x27)
  #Define T_udp_len1 etherbuffer(0x28)

'UDP checksum
  #Define T_udp_chksum0 etherbuffer(0x29)
  #Define T_udp_chksum1 etherbuffer(0x2A)

'UDP Data pointer
  #Define T_udp_data_pointer 0x2B

'UDP Data Buffer
    #Define T_udp_data etherbuffer(0x2B)
    #Define T_udp_data0 etherbuffer(0x2B)
    #Define T_udp_data1 etherbuffer(0x2C)
    #Define T_udp_data2 etherbuffer(0x2D)
    #Define T_udp_data3 etherbuffer(0x2E)
    #Define T_udp_data4 etherbuffer(0x2F)
    #Define T_udp_data5 etherbuffer(0x30)
    #Define T_udp_data6 etherbuffer(0x31)
    #Define T_udp_data7 etherbuffer(0x32)
    #Define T_udp_data8 etherbuffer(0x33)
    #Define T_udp_data9 etherbuffer(0x34)
    #Define T_udp_data10 etherbuffer(0x35)
    #Define T_udp_data11 etherbuffer(0x36)
    #Define T_udp_data12 etherbuffer(0x37)
    #Define T_udp_data13 etherbuffer(0x38)
    #Define T_udp_data14 etherbuffer(0x39)
    #Define T_udp_data15 etherbuffer(0x3A)
    #Define T_udp_data16 etherbuffer(0x3B)
    #Define T_udp_data17 etherbuffer(0x3C)
    #Define T_udp_data18 etherbuffer(0x3D)
    #Define T_udp_data19 etherbuffer(0x3E)
    #Define T_udp_data20 etherbuffer(0x3F)
    #Define T_udp_data21 etherbuffer(0x40)
    #Define T_udp_data22 etherbuffer(0x41)
    #Define T_udp_data23 etherbuffer(0x42)
    #Define T_udp_data24 etherbuffer(0x43)
    #Define T_udp_data25 etherbuffer(0x44)
    #Define T_udp_data26 etherbuffer(0x45)
    #Define T_udp_data27 etherbuffer(0x46)
    #Define T_udp_data28 etherbuffer(0x47)
    #Define T_udp_data29 etherbuffer(0x48)
    #Define T_udp_data30 etherbuffer(0x49)
    #Define T_udp_data31 etherbuffer(0x4A)
    #Define T_udp_data32 etherbuffer(0x4B)
