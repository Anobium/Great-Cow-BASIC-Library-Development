'''A demonstration program for GCGB and GCB.
'''--------------------------------------------------------------------------------------------------------------------------------
'''This program is a simple GLCD demonstration of the T6963 GLCD capabilities.
'''This program will draws lines, boxes, circles and prints strings and numbers.
'''The GLCD is connected to the microprocessor as shown in the hardware section of this code.
'''@author  EvanV
'''@licence GPL
'''@version 0.9a
'''@date    3.1.19
'''********************************************************************************

  #chip 16f1939,32
  #option explicit
  #config Osc = INT, VCAPEN_OFF, MCLRE_On, PLLEN_ON, CLKOUTEN_OFF

  #include <glcd.h>
  #define GLCD_TYPE 0               ' This is the devlopment value, will be set later, leave a zero.
  #define GLCD_TYPE_T6963 0
'  #startup InitGLCD_T6963

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  #define GLCD_DATA_PORT PORTD



  #define STA0         GLCD_DATA_PORT.0   'Check command execution capability
  #define STA1         GLCD_DATA_PORT.1   'Check data read/write capability
  #define STA2         GLCD_DATA_PORT.2   'Check Auto mode data read capability
  #define STA3         GLCD_DATA_PORT.3   'Check Auto mode data write capability
  #define STA5         GLCD_DATA_PORT.5   'Check controller operation capability
  #define STA6         GLCD_DATA_PORT.6   'Error flag. Used for screen peek and screen copy
  #define STA7         GLCD_DATA_PORT.7   'Check the blink condition

  #define GLCD_CS        PORTa.7          'Chip Enable (Active Low)
  #define GLCD_CD        PORTa.0
  #define GLCD_RD        PORTA.1           'LCD Read control line  pin number
  #define GLCD_WR        PORTA.2           'LCD Write control line pin number
  #define GLCD_RESET     PORTA.3
  #define GLCD_FS        PORTA.5            'FS1 I Font Select 6x8 font: FS1=“High”=1 8x8 font FS1=“Low”=1 for GLCD_FS_SELECT
  #define GLCD_FS_SELECT 1

  '***********************************************************************************************
  '* Note    :   The T6963 controller's RAM address space from $0000 - $FFFF, total 64kbyte RAM.
  '*       It is just the RAM address set, not the actual RAM amount can be set!
  '*
  '***********************************************************************************************
  #define TEXT_HOME_ADDR      0x0000                                                         'This is specific to the GLCD display
  #define GRH_HOME_ADDR       0x3FFF                                                         'This is specific to the GLCD display
  #define CG_HOME_ADDR        0x77FF                                                        'This is specific to the GLCD display
  #define COLUMN              40    'Set column number to be 40 , 32, 30 etc.                 This is specific to the GLCD display
  #define MAX_ROW_PIXEL       64    'MAX_ROW_PIXEL the physical matrix length (y direction)   This is specific to the GLCD display
  #define MAX_COL_PIXEL       240   'MAX_COL_PIXEL the physical matrix width (x direction)    This is specific to the GLCD display



   ' Change timing for 32 mhz
   #define T6963ReadDelay    4    ; = 2 normal usage, 6 or above is OK at 32 mhz!
   #define T6963WriteDelay   1    ; = 1 normal usage you may get away with 0, 2 or above is OK at 32 mhz!
   #define T6963ClockDelay   1     ; = 1 normal usage you may get away with 0, 2 or above is OK at 32 mhz!


    Dim BYTENUMBER, CCOUNT as Byte

    CCount = 0
    dim longNumber as long
    longNumber = 4294967290 ' max value = 4294967296
    dim wordNumber as Word
    dim outString as string
    wordNumber = 0
    byteNumber = 0
#define debugc4 portc.4
dir debugc4 out

        dir GLCD_DATA_PORT out
    dir GLCD_CS        out
    dir GLCD_CD        out
    dir GLCD_RD        out
    dir GLCD_WR        out
    dir GLCD_RESET     out
    dir GLCD_FS        out

    debugc4 = 0

    InitGLCD_T6963
    GLCDCLS_T6963


'    GDispCmdSend(AUTO_WR_OFF)
'
'    GDispCmdSend(AUTO_WR_ON)
'    GDispAutoDataWr(ATTR_NORMAL)
'    GDispCmdSend(AUTO_WR_OFF)
'    GDispCmdSend(TEXT_ATTR_MODE)
'    GDispCmdSend(CURSOR_BLINK_ON)
'    GDispCmdSend(TEXT_GRH_ON)
'
'    GDispCmdSend(LINE_8_CURSOR)
'    GDispCmdSend(LINE_8_CURSOR)
'
    debugc4 = 1
'

'

dim TempSTR as String
dim TempVal as Long

'systat calculation
dim refa as long
dim refb as Long
dim answer as Long
refb =236
Tempval=2000
answer= refb*Tempval



GDispCmdAddrSend(TEXT_HOME_ADDR,ADDR_PTR_SET)
     dim myString as String
     myString = "1234567890"
     dim xloop as byte
Repeat 32

     for xloop = 1 to len(myString)
          GDispDataWr(ATTR_NORMAL)
          GDispDataWr( myString( xloop ) -0x20 )      'Adjust standard ASCII to T6963 ASCII
          GDispCmdSend(DATA_WR_INC)   'Address pointer increment ON
     next

end Repeat
WAIT 3 S
      #define pset PSet_T6963


'    GDispCmdSend(TEXT_GRH_ON)
      dim x1, y1 as word
GDispCmdSend(OR_MODE)
'for x1  = GRH_HOME_ADDR to GRH_HOME_ADDR+GRH_HOME_ADDR STEP 8

    PSET (0,0,0)
    PSET (1,1,0)

    GDispDataWr(15);


'next
    End

'      ' Prepare the static components of the screen
'      GLCDPrint ( 0,   0, "PrintStr")                                ; Print some text
'      GLCDPrint ( 64,  0, "LAT@")                                    ; Print some more text
'      GLCDPrint ( 88,  0, ChipMhz)                                   ; Print chip speed
'      GLCDPrint ( 100, 0, "Mhz")                                     ; Print some text
'      GLCDDrawString( 0,8,"DrawStr")                                 ; Draw some text
'      box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1                            ; Draw a box
'      box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1    ; Draw a box
'      Circle( 44,41,15)                                              ; Draw a circle
'      line 64,31,0,31                                                ; Draw a line
'
'      DO forever
'         for CCount = 32 to 127
'              GLCDPrint ( 64 ,  36,  hex(longNumber_E ) )                 ; Print a HEX string
'              GLCDPrint ( 76 ,  36,  hex(longNumber_U ) )                 ; Print a HEX string
'              GLCDPrint ( 88 ,  36,  hex(longNumber_H ) )                 ; Print a HEX string
'              GLCDPrint ( 100 ,  36, hex(longNumber   ) )                 ; Print a HEX string
'              GLCDPrint ( 112 ,  36, "h" )                                ; Print a HEX string
'
'
'              GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) )           ; Print a padded string
'              GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) )           ; Print a padded string
'
'
'              box (46,9,56,19)                                           ; Draw a Box
'              GLCDDrawChar(48, 9, CCount )                               ; Draw a character
'              outString = str( CCount )                                  ; Prepare a string
'              GLCDDrawString(64, 9, pad(outString,3) )                   ; Draw a string
'
'              filledbox 3,43,11,51, wordNumber                           ; Draw a filled box
'
'              FilledCircle( 44,41,9, longNumber xor 1)                   ; Draw a filled box
'              line 0,63,64,31                                            ; Draw a line
'
'                                                                         ; Do some simple maths
'              longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
'          NEXT
'      LOOP
'
'  end




Sub InitGLCD_T6963

  'Setup code for T6963 controllers
  #if GLCD_TYPE = GLCD_TYPE_T6963
'    #define T6963ReadDelay   9     ; 2 normal usage, 3 for 32 mhz!
'    #define T6963WriteDelay  1     ; 1 normal usage, 0 works
'    #define T6963ClockDelay  1     ; 1 normal usage, 0 works
'    #define GLCDDirection    0     ; 0 normal mode



    'Set pin directions
    dir GLCD_DATA_PORT out
    dir GLCD_CS        out
    dir GLCD_CD        out
    dir GLCD_RD        out
    dir GLCD_WR        out
    dir GLCD_RESET     out
    dir GLCD_FS        out
    'Reset cycle
    GLCD_RESET = 0
    GLCD_CD = 1
    GLCD_CS = 1
    GLCD_RD = 1
    GLCD_WR = 1
    GLCD_FS  = GLCD_FS_SELECT
    GLCD_DATA_PORT = 0
    wait 5 ms
    GLCD_RESET = 1

'
'***********************************************************************************************
'*                   GLOBAL CONSTANTS
'***********************************************************************************************
'
#define ENABLE              1
#define DISABLE             0
#define BLACK               1
#define WHITE               0

'
'***********************************************************************************************
'*                   DISPLAY MODE
'***********************************************************************************************
'
#define DISPLAY_OFF         0x90    '0b10010000, display off
#define CURSOR_ON_BLINK_OFF 0x92    '0b1001xx10, cursor on without blinking
#define CURSOR_BLINK_ON     0x93    '0b1001xx11, cursor on with blinking
#define TEXT_ON             0x94    '0b100101xx, text on, graphics off
#define GRAPHIC_ON          0x98    '0b100110xx, text off, graphics on
#define TEXT_GRH_ON         0x9C    '0b100111xx, text on, graphics on


'
'***********************************************************************************************
'*                     MODE
'***********************************************************************************************
'* Example:  OR_MODE|EXT_CG_MODE   ->  OR mode, external CG ram mode
'*       AND_MODE        ->  AND mode, internal CG ROM mode
'***********************************************************************************************
'
'
'***********************************************************************************************
'*   In internal CG ROM MODE (INT_CG_MODE), character codes 00h - 7Fh represent the
'*   pre-defined "internal" CG ROM characters, and codes 80h - FFh represent the
'*   users own "external" characters. In external CG ROM MODE (EXT_CG_MODE),
'*   all 256 codes from 00h - FFh can be used to represent the users own characters.
'***********************************************************************************************
'

#define INT_CG_MODE         0x80    '0b10000xxx, Internal CG ROM mode
#define EXT_CG_MODE         0x88    '0b10001xxx, External CG RAM mode
#define OR_MODE             0x80    '0b1000x000, OR mode, internal CG ROM mODE
#define XOR_MODE            0x81    '0b1000x001, XOR mode, internal CG ROM mode
#define AND_MODE            0x83    '0b1000x011, AND mode, internal CG ROM mode
#define TEXT_ATTR_MODE      0x84    '0b1000x100, text attribute mode, internal CG ROM mode



'
'***********************************************************************************************
'*                   CURSOR MODE
'***********************************************************************************************
'
#define LINE_8_CURSOR   0xA7    '8-line cursor mode
#define LINE_7_CURSOR   0xA6  '7-line cursor mode
#define LINE_6_CURSOR   0xA5  '6-line cursor mode
#define LINE_5_CURSOR   0xA4  '5-line cursor mode
#define LINE_4_CURSOR   0xA3  '4-line cursor mode
#define LINE_3_CURSOR   0xA2  '3-Line cursor mode
#define LINE_2_CURSOR   0xA1  '2-Line cursor mode
#define LINE_1_CURSOR   0xA0    '1-Line cursor mode

'
'***********************************************************************************************
'*                 TEXT ATTRIBUTE MODE
'***********************************************************************************************
'
#define ATTR_NORMAL         0x00    'Normal Display
#define ATTR_REVERSE        0x05    'Reverse Display
#define ATTR_INHIBIT        0x03    'Inhibit Display
#define ATTR_BLINK          0x08    'Blinking of Normal Display
#define ATTR_BLINK_REVERSE  0x0D    'Blinking of Reverse Display
#define ATTR_BLINK_INHIBIT  0x0B    'Blinking of Inhibit Display


#define CURSOR_PTR_SET      0x21    'Cursor Pointer Set
#define OFFSET_REG_SET      0x22    'Set Offset Command
#define ADDR_PTR_SET        0x24    'Set Address Pointer Command

#define TEXT_HOME_SET       0x40    'Text Home Address Set: Data = low, high addr
#define TEXT_AREA_SET       0x41    'Text Area Set: Data = columns, 0
#define GRAPH_HOME_SET      0x42    'Graphics Home address Set: Data = low, high addr
#define GRAPH_AREA_SET      0x43    'Graphics Area Set: Data = columns, 0
#define SCREEN_PEEK         0xE0    'Read data from screen command
#define SCREEN_COPY         0xE8    'Screen Copy

#define AUTO_WR_ON          0xB0
#define DATA_AUTO_RD        0xB1
#define AUTO_WR_OFF         0xB2

#define DATA_WR_INC         0xC0    ' Data write and increment addrespointer
#define DATA_RD_INC         0xC1    ' Data read and increment  addrespointer
#define DATA_WR_DEC         0xC2    ' Data write and decrement addrespointer
#define DATA_RD_DEC         0xC3    ' Data read and decrement  addrespointer
#define DATA_WR             0xC4    ' Data write - no addr change
#define DATA_RD             0xC5    ' Data read  - no addr change

   'Set Text Home address to TEXT_HOME_ADDR
    GLCDCmdAddrSend_T6963(TEXT_HOME_ADDR,TEXT_HOME_SET)
   'Set Graph Home address to GRH_HOME_ADDR
    GLCDCmdAddrSend_T6963(GRH_HOME_ADDR,GRAPH_HOME_SET)
   'Set Text Area to COLUMN column mode
    GLCDCmdAddrSend_T6963(COLUMN,TEXT_AREA_SET)
   'Set Graph Area to COLUMN column mode
    GLCDCmdAddrSend_T6963(COLUMN,GRAPH_AREA_SET)

   'Set Offset register to 0x0002, CG Ram start address = $1400 (CG_HOME_ADDR)
   'first character code $80 for CG Ram
    GLCDCmdAddrSend_T6963(0x0002,OFFSET_REG_SET)

'    'Set Text Home address to TEXT_HOME_ADDR
'    GLCDSendData_T6963 ( 0x00 )    'Send LSB of 'Addr' first
'    GLCDSendData_T6963 ( 0x00 )    'Send MSB of 'Addr' afterwards
'    GLCDSendCommand_T6963 ( 0x40 )
'
'    'Set Graph Home address to GRH_HOME_ADDR
'    GLCDSendData_T6963 ( 0x00 )
'    GLCDSendData_T6963 ( 0x02 )
'    GLCDSendCommand_T6963 ( 0x42 )
'
'    'Set Text Area to COLUMN column mode
'    GLCDSendData_T6963 ( 0x20 )
'    GLCDSendData_T6963 ( 0x00 )
'    GLCDSendCommand_T6963 ( 0x41 )
'
'    'Set Graph Area to COLUMN column mode
'    GLCDSendData_T6963 ( 0x20 )
'    GLCDSendData_T6963 ( 0x00 )
'    GLCDSendCommand_T6963 ( 0x43 )
'
'    'Set Offset register to 0x0002, CG Ram start address = $1400 (CG_HOME_ADDR)
'    'first character code $80 for CG Ram
'    GLCDSendData_T6963 ( 0x02 )
'    GLCDSendData_T6963 ( 0x00 )
'    GLCDSendCommand_T6963 ( 0x22 )
'
GLCDSendCommand_T6963 ( OR_MODE )
GLCDSendCommand_T6963 ( TEXT_GRH_ON )
'    wait 1 s
'    GLCDSendData_T6963 ( 0x00 )
'    GLCDSendData_T6963 ( 0x10 )
'    GLCDSendCommand_T6963 ( 0x42 )
'
'    GLCDSendData_T6963 ( 0x28 )
'    GLCDSendData_T6963 ( 0x00 )
'    GLCDSendCommand_T6963 ( 0x43 )
'
'    GLCDSendData_T6963 ( 0x00 )
'    GLCDSendData_T6963 ( 0x00 )
'    GLCDSendCommand_T6963 ( 0x40 )
'
'    GLCDSendData_T6963 ( 0x28 )
'    GLCDSendData_T6963 ( 0x00 )
'    GLCDSendCommand_T6963 ( 0x41 )

    'Colours
    GLCDBackground = 0
    GLCDForeground = 1
    GLCDFontWidth = 5
    GLCDfntDefault = 0
    GLCDfntDefaultsize = 1


  #endif

  'Clear screen
'  GLCDCLS_T6963

End Sub


'Subs
'''Clears the GLCD screen
Sub GLCDCLS_T6963
  ' initialise global variable. Required variable for Circle in all DEVICE DRIVERS- DO NOT DELETE
  GLCD_yordinate = 0

  #if GLCD_TYPE = GLCD_TYPE_T6963

    dim row_T6963, col_T6963 as word

    'Set address pointer to address (TEXT_HOME_ADDR)
    GDispCmdAddrSend(TEXT_HOME_ADDR,ADDR_PTR_SET)

    'Set Auto Write ON
    GDispCmdSend(AUTO_WR_ON)

    'row runs from 0 ... (MAX_ROW_PIXEL/8 -1), in form of a cell of (FontSize x 8) bits
    for  row_T6963 =  0 to ( MAX_ROW_PIXEL/8 ) -1
        'write blank to clear screen the first page only, col = 0...(COLUMN-1)
        for col_T6963 = 0 to COLUMN - 1

            GDispAutoDataWr ( 0 )

        next

    next
    GDispCmdSend(AUTO_WR_OFF)
    GDispCmdAddrSend(TEXT_HOME_ADDR,ADDR_PTR_SET)

    'Set address pointer to address (GRH_HOME_ADDR)
    GDispCmdAddrSend(GRH_HOME_ADDR, ADDR_PTR_SET)
    'Set Auto Write ON
    GDispCmdSend(AUTO_WR_ON)
    'Row runs from 0 ... (MAX_ROW_PIXEL-1), in form of a byte size of (FontSize x 1) bits
    for  row_T6963 =  0 to  MAX_ROW_PIXEL -1
            'write blank to clear screen the first page only, col = 0...(COLUMN-1)
        for col_T6963 = 0 to COLUMN - 1
            GDispAutoDataWr ( 0x00 )
        next
    next
    GDispCmdAddrSend(GRH_HOME_ADDR, ADDR_PTR_SET)


  #endif

End Sub



'''Draws a pixel on the GLCD
'''@param GLCDX X coordinate of pixel
'''@param GLCDY Y coordinate of pixel
'''@param GLCDColour State of pixel (0 = background, 1 = foreground )
Sub PSet_T6963(In GLCDX as word, In GLCDY as word, In GLCDColour As Word)

  #if GLCD_TYPE = GLCD_TYPE_T6963
    'Set pixel at X, Y on LCD to State
    'Origin in top left

'    #ifdef  GLCDDirection
'      if GLCDDirection=1 then
'        GLCDX=127-GLCDX
'        GLCDY=63-GLCDY
'      end if
'    #endif

    dim addr as word
    dim cmd as byte
'    addr = ( GLCDY * COLUMN ) + GLCDX + TEXT_HOME_ADDR
'    GDispCmdAddrSend( addr, ADDR_PTR_SET)

#define FontSize 8

GDispCmdSend(OR_MODE)
    addr = ( GLCDY - 1) *COLUMN + ((GLCDX-1)/FontSize) + GRH_HOME_ADDR;

    GDispCmdAddrSend(addr, ADDR_PTR_SET);

    if ( GLCDColour = 0 ) then
      cmd = (0b11111000)|(FontSize- 1 -((GLCDX-1)%FontSize))
    else
      cmd = (0b11110000)|(FontSize- 1 -((GLCDX-1)%FontSize))
    end if
    GDispCmdSend(cmd);

'
'    HSerPrint GLCDX
'    HSerSend 9
'    HSerPrint GLCDY
'    HSerSend 9
'    HSerPrint addr
'    HSerSend 9
'    HSerPrint cmd
'    HSerPrintCRLF


  #endif

End Sub

#define GDispCmdAddrSend  GLCDCmdAddrSend_T6963
sub GLCDCmdAddrSend_T6963 ( in LCDDataWord as word, In LCDCmdByte )

  GLCDSendData_T6963 ( LCDDataWord )
  GLCDSendData_T6963 ( LCDDataWord_h )
  GLCDSendCommand_T6963 ( LCDCmdByte )

end sub

#define  GDispCmdSend GLCDSendCommand_T6963
Sub GLCDSendCommand_T6963 ( In LCDCmdByte )

    GLCDBusyCheck_T6963

    GLCD_DATA_PORT = LCDCmdByte
    wait T6963ClockDelay us
    GLCD_CD = 1
    wait T6963ClockDelay us
    GLCD_WR = 0
    wait T6963ClockDelay us
    GLCD_RD = 1
    wait T6963ClockDelay us

    GLCD_CS = 0
    wait T6963WriteDelay us
    GLCD_CS = 1

End Sub



Sub GDispAutoDataWr   ( In LCDDataByte )

    GDispAutoWrChk

    GLCD_DATA_PORT = LCDDataByte
    wait T6963ClockDelay us
    GLCD_CD = 0
    wait T6963ClockDelay us
    GLCD_WR = 0
    wait T6963ClockDelay us
    GLCD_RD = 1
    wait T6963ClockDelay us

    GLCD_CS = 0
    wait T6963WriteDelay us
    GLCD_CS = 1

End Sub

#define GDispDataWr  GLCDSendData_T6963
Sub GLCDSendData_T6963 ( In LCDDataByte )

    GLCDBusyCheck_T6963

    GLCD_DATA_PORT = LCDDataByte
    wait T6963ClockDelay us
    GLCD_CD = 0
    wait T6963ClockDelay us
    GLCD_WR = 0
    wait T6963ClockDelay us
    GLCD_RD = 1
    wait T6963ClockDelay us
    GLCD_CS = 0
    wait T6963WriteDelay us
    GLCD_CS = 1

End Sub


Sub GLCDBusyCheck_T6963

    dir GLCD_DATA_PORT in

    GLCD_CD = 1
    wait T6963ClockDelay us
    GLCD_WR = 1
    wait T6963ClockDelay us
    GLCD_RD = 0
    wait T6963ClockDelay us

    GLCD_CS = 0
    wait T6963ClockDelay us
    wait while (!STA0)  'Busy Check here
    wait T6963ClockDelay us
    wait while (!STA1)
    GLCD_CS = 1
    dir GLCD_DATA_PORT out

End Sub


Sub GDispAutoWrChk

    dir GLCD_DATA_PORT in

    GLCD_CD = 1
    wait T6963ClockDelay us
    GLCD_WR = 1
    wait T6963ClockDelay us
    GLCD_RD = 0
    wait T6963ClockDelay us
    GLCD_CS = 0
    wait T6963ClockDelay us
    wait while (!STA3)  'Busy Check here
    GLCD_CS = 1
    dir GLCD_DATA_PORT out

End Sub



'      FONTSELECT VAR PORTJ.6'SET FONT SIZE PIN
'      *MD VAR PORTJ.5'I THINK THIS IS FOR SELECTING THE HALF OF DISPLAY TO WRITE TO
'      *RESET VAR PORTJ.4'RESET PIN
'      *CS VAR PORTJ.3'CHIP SELECT PIN
'      *WR VAR PORTJ.2'WRITE PIN
'      *RD VAR PORTJ.1'READ PIN
'      *CD VAR PORTJ.0'COMMAND DATA PIN
'      DATAOUT VAR PORTH 'DATA PORT
'      B0 VAR WORD
'
'      HIGH RESET
'      HIGH CS'ENABLE WRITE MODE
'      LOW CD'SET TO DATA MODE
'      HIGH WR'SET WRITE PIN TO HIGH
'      HIGH RD'SET READ PIN TO HIGH
'      HIGH FONTSELECT'SET FONT SIZE
'      HIGH MD'I THINK THIS IS FOR SELECTING THE HALF OF DISPLAY TO WRITE TO
'
'      PAUSE 1000
'
'      PULSOUT RESET,1 :PAUSE 1000
'      CD=1:DATAOUT=$80:PAUSEUS 1:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 1:CD=0:PAUSEUS 1'MODE SET
'      CD=1:DATAOUT=$94:PAUSEUS 1:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 1:CD=0:PAUSEUS 1'DISPLAY ON IN TEXT ONLY MODE
'
'      PAUSE 1000
'
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LSB
'      CD=0:DATAOUT=$10:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'MSB
'      CD=1:DATAOUT=$42:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'GRAPHIC HOME ADDRESS
'
'      CD=0:DATAOUT=$28:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LSB
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'MSB
'      CD=1:DATAOUT=$43:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'GRAPHIC AREA SET COMMAND
'
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LSB
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'MSB
'      CD=1:DATAOUT=$40:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'TEXT HOME ADDRESS
'
'      CD=0:DATAOUT=$28:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LSB
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'MSB
'      CD=1:DATAOUT=$41:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'TEXT AREA SET COMMAND
'
'      PAUSE 1000
'      GOSUB CLEARSCREEN
'      PAUSE 1000
'
'      'WRITE HELLO START OF LINE 1
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LSB
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'MSB
'      CD=1:DATAOUT=$24:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'TEXT POINTER SET(SETS WHERE TEXT IS TO START WRITING ON SCREEN)
'      CD=0:DATAOUT=$28:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER H
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'      CD=0:DATAOUT=$25:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER E
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'      CD=0:DATAOUT=$2C:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER L
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'      CD=0:DATAOUT=$2C:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER L
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'      CD=0:DATAOUT=$2F:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER O
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'
'      'WRITE WORLD START OF LINE 2
'      CD=0:DATAOUT=$28:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LSB
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'MSB
'      CD=1:DATAOUT=$24:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'TEXT POINTER SET(SETS WHERE TEXT IS TO START WRITING ON SCREEN)
'      CD=0:DATAOUT=$37:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER W
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'      CD=0:DATAOUT=$2F:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER O
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'      CD=0:DATAOUT=$32:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER R
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'      CD=0:DATAOUT=$2C:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER L
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'      CD=0:DATAOUT=$24:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LETTER D
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'
'      Q:
'      GOTO Q
'
'      CLEARSCREEN:
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'LSB
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'MSB
'      CD=1:DATAOUT=$24:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'TEXT POINTER SET(SETS WHERE TEXT IS TO START WRITING ON SCREEN)
'      FOR B0=0 TO 319
'      CD=0:DATAOUT=$00:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'SEND A SPACE
'      CD=1:DATAOUT=$C0:PAUSEUS 2:CS=0:PULSOUT WR,1:CS=1:PAUSEUS 2:CD=0:PAUSEUS 2'DATA INCREMENT
'      NEXT B0
'      RETURN
