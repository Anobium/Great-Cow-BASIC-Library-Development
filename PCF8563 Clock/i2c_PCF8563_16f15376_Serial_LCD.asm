;Program compiled by Great Cow BASIC (0.98.04 2018-10-20 (Windows 32 bit))
;Need help? See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;check the documentation or email w_cholmondeley at users dot sourceforge dot net.

;********************************************************************************

;Set up the assembler options (Chip type, clock source, other bits and pieces)
 LIST p=16F15376, r=DEC
#include <P16F15376.inc>
 __CONFIG _CONFIG1, _RSTOSC_HFINT32
 __CONFIG _CONFIG2, _MCLRE_OFF
 __CONFIG _CONFIG3, _WDTE_OFF
 __CONFIG _CONFIG4, _LVP_OFF

;********************************************************************************

;Set aside memory locations for variables
AM_PM	EQU	32
BCDTODEC	EQU	33
DATE	EQU	34
DECTOBCD	EQU	35
DELAYTEMP	EQU	112
DELAYTEMP2	EQU	113
DOW	EQU	36
DS_A_P	EQU	37
DS_DATE	EQU	38
DS_DOW	EQU	39
DS_HOUR	EQU	40
DS_MIN	EQU	41
DS_MONTH	EQU	42
DS_SEC	EQU	43
DS_VALUE	EQU	44
DS_YEAR	EQU	45
HI2CACKPOLLSTATE	EQU	46
HI2CCURRENTMODE	EQU	47
HI2CGETACK	EQU	48
HI2CWAITMSSPTIMEOUT	EQU	49
HOUR	EQU	50
I2CBYTE	EQU	51
I2C_LCD_BYTE	EQU	52
LCDBYTE	EQU	53
LCDCOLUMN	EQU	54
LCDCRSR	EQU	55
LCDLINE	EQU	56
LCDTEMP	EQU	57
LCDVALUE	EQU	58
LCDVALUETEMP	EQU	59
LCD_BACKLIGHT	EQU	60
LCD_I2C_ADDRESS_CURRENT	EQU	61
LCD_STATE	EQU	62
MIN	EQU	63
MODE	EQU	64
MONTH	EQU	65
OLDSEC	EQU	66
PRINTLEN	EQU	67
SEC	EQU	68
STR	EQU	10218
STRINGPOINTER	EQU	69
SYSBYTETEMPA	EQU	117
SYSBYTETEMPB	EQU	121
SYSBYTETEMPX	EQU	112
SYSCALCTEMPA	EQU	117
SYSCALCTEMPX	EQU	112
SYSCALCTEMPX_H	EQU	113
SYSCHARCOUNT	EQU	70
SYSDIVLOOP	EQU	116
SYSDIVMULTA	EQU	119
SYSDIVMULTA_H	EQU	120
SYSDIVMULTB	EQU	123
SYSDIVMULTB_H	EQU	124
SYSDIVMULTX	EQU	114
SYSDIVMULTX_H	EQU	115
SYSLCDTEMP	EQU	71
SYSPRINTDATAHANDLER	EQU	72
SYSPRINTDATAHANDLER_H	EQU	73
SYSPRINTTEMP	EQU	74
SYSREPEATTEMP1	EQU	75
SYSSTRDATA	EQU	76
SYSSTRINGA	EQU	119
SYSSTRINGA_H	EQU	120
SYSSTRINGLENGTH	EQU	118
SYSSTRINGPARAM1	EQU	160
SYSTEMP1	EQU	77
SYSTEMP1_H	EQU	78
SYSTEMP2	EQU	79
SYSVALTEMP	EQU	80
SYSVALTEMP_H	EQU	81
SYSWAITTEMP10US	EQU	117
SYSWAITTEMPMS	EQU	114
SYSWAITTEMPMS_H	EQU	115
SYSWAITTEMPS	EQU	116
SYSWAITTEMPUS	EQU	117
SYSWAITTEMPUS_H	EQU	118
SYSWORDTEMPA	EQU	117
SYSWORDTEMPA_H	EQU	118
SYSWORDTEMPB	EQU	121
SYSWORDTEMPB_H	EQU	122
SYSWORDTEMPX	EQU	112
SYSWORDTEMPX_H	EQU	113
VA	EQU	82
YEAR	EQU	83
_HEF_DUMMY	EQU	84

;********************************************************************************

;Alias variables
AFSR0	EQU	4
AFSR0_H	EQU	5
SYSSTR_0	EQU	3258

;********************************************************************************

;Vectors
	ORG	0
	pagesel	BASPROGRAMSTART
	goto	BASPROGRAMSTART
	ORG	4
	retfie

;********************************************************************************

;Start of program memory page 0
	ORG	5
BASPROGRAMSTART
;Call initialisation routines
	call	INITSYS
	call	INITPPS
	call	HIC2INIT
	call	INITLCD

;Start of the main program
;''A demonstration program for GCGB and GCB.
;''--------------------------------------------------------------------------------------------------------------------------------
;''This program shows the real time clock on a LCD. The LCD is driven by a LCD I2C adapter.
;''Two types of LCD are supported using this method, as shown below:
;'':        Set LCD_10 to 10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter
;'':        Set LCD_10 to 12 for the Ywmjkdz I2C adapter with pot bent over top of chip
;''The PCF8563 is attached to the I2C ports with appropiate resistors to the supply voltage.  Typically a 5k or 2.2k resistor 'pulling up' to the supply voltage can be used.
;'':
;'':    There are two pushbuttons: Mode and Set equates to Key1 and Key2. Connected to portb.0 and portb.1 resepectively.
;'':
;'':    During normal operation, the Mode button will toggle
;'':    between 12- and 24-hours modes.
;'':
;'':    This has two modes US date and UK date style.
;'':    Change ''':clocktype''': to 0 for US and 1 for UK
;'':
;'':    To set a new date and time, press the Set button
;'':    which will take you consecutively to Month, Day, Year,
;'':    Day of the Week, Hour, Minute and Second. Within each of
;'':    these, press Mode to cycle through the possible values.
;'':    You may hold the Mode button to increment automatically,
;'':    or press momentarily for a single increment. Time is
;'':    always set in 24-hour clock format.
;''@author          EvanV
;''@licence GPL
;''@version 1.2a
;''@date    23.02.15
;''********************************************************************************
;----- Configuration
;Generated by PIC PPS Tool for Great Cow Basic
;PPS Tool version: 0.0.5.22
;PinManager data: Not available (3)
;Generated for 16F15376
;
;Template comment at the start of the config file
;
;#define PPSToolPart 16F15376
;Template comment at the end of the config file
;#define DS_AddrWrite 0xA2
;#define DS_AddrRead  0xA3
;''Set up LCD
;#define LCD_IO 10
;#define LCD_I2C_Address_1 0x4C ; default to 0x4E
;You may need to use SLOW or MEDIUM if your LCD is a slower device.
;#define LCD_SPEED FAST
;You may need to invert these states. Dependent of LCD I2C adapter.
;#define LCD_Backlight_On_State  1
;#define LCD_Backlight_Off_State 0
;----- Define Hardware settings for hwi2c
;Define I2C settings - CHANGE PORTS if required for your specific device.
;#define hi2c_BAUD_RATE 100
;#define hi2c_DATA PORTb.5
;#define hi2c_CLOCK PORTb.7
;Initialise I2C Master
;I2C pins need to be input for SSP2 module
;Dir hi2c_DATA in
	bsf	TRISB,5
;Dir hi2c_CLOCK in
	bsf	TRISB,7
;----- Define Hardware settings
;dir setBut in
	bsf	TRISB,0
;dir modeBut in
	bsf	TRISB,1
;#define clocktype   1               ;0 is US or 1 is UK style
;#define debounce    50 mS            ;settling time for switches
;#define delay       150 mS          ;delay time for pushbutton
;#define pressed     1               ;flag for pressed pushbutton
;#define setBut      portb.0         ;Set pushbutton
;#define modeBut     portb.1         ;Mode pushbutton
;#define Alarm0 0x00                 ;a reference to the alarm 0
;#define Alarm1 0x01                 ;a reference to the alarm 1
;----- Variables
;Dim DAYSMAX, DAYSMAX as Byte
;dim changed as bit
;dim hour, min, sec, am_pm as byte
;dim oldsec as byte
;dim date, month, year, DOW as byte
;dim mode, Oldmode, dayMax as byte
;oldsec = 255                        ;      init value
	movlw	255
	movwf	OLDSEC
;----- Tables
;----- Program
;LCDCursor CURSOROFF
	movlw	13
	movwf	LCDCRSR
	call	LCDCURSOR
;locate 0,0
	clrf	LCDLINE
	clrf	LCDCOLUMN
	call	LOCATE
;Print "PCF8563"
	movlw	low StringTable2
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable2) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;locate 1,0
	movlw	1
	movwf	LCDLINE
	clrf	LCDCOLUMN
	call	LOCATE
;Print "Great Cow Basic"
	movlw	low StringTable3
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable3) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;wait 2 s
	movlw	2
	movwf	SysWaitTempS
	call	Delay_S
;CLS
	call	CLS
;PCF8563_SetClock( 13, 45, 0, 19,20,12, 18)
;PCF8563_ResetClock
	call	PCF8563_RESETCLOCK
;PCF8563_EnableClockout ( 1 )
	movlw	1
	movwf	DS_VALUE
	call	PCF8563_ENABLE
;PCF8563_EnableClockoutFrequency ( CLKOUT_CTRL_REG_1_Hz )
	movlw	3
	movwf	DS_VALUE
	call	PCF8563_ENABLECLOCKOUTFREQUENCY
;locate 2,0
	movlw	2
	movwf	LCDLINE
	clrf	LCDCOLUMN
	call	LOCATE
;Main body of program commences here.
;PCF8563_ReadDate(DOW, date, month, year)   ;get initial date
	call	PCF8563_READDATE
	movf	DS_DOW,W
	movwf	DOW
	movf	DS_DATE,W
	movwf	DATE
	movf	DS_MONTH,W
	movwf	MONTH
	movf	DS_YEAR,W
	movwf	YEAR
;do
SysDoLoop_S1
;updateDisp                        ;show time and date
	call	UPDATEDISP
;if setBut = pressed then
;changeSetting                   ;change time and date
;end if
;
;if modeBut = pressed then
;changeMode                      ;12 or 24 hour mode
;end if
;loop
	goto	SysDoLoop_S1
SysDoLoop_E1
;end
	goto	BASPROGRAMEND
;----- Subroutines
;-----
;-----
;-----
;-----
BASPROGRAMEND
	sleep
	goto	BASPROGRAMEND

;********************************************************************************

FN_BCDTODEC
;Convert binary coded decimal to pure decimal
;BcdToDec=( va /16)*10+ va %16
	movf	VA,W
	movwf	SysBYTETempA
	movlw	16
	movwf	SysBYTETempB
	call	SysDivSub
	movf	SysBYTETempA,W
	movwf	SysTemp1
	movwf	SysBYTETempA
	movlw	10
	movwf	SysBYTETempB
	call	SysMultSub
	movf	SysBYTETempX,W
	movwf	SysTemp2
	movf	VA,W
	movwf	SysBYTETempA
	movlw	16
	movwf	SysBYTETempB
	call	SysDivSub
	movf	SysBYTETempX,W
	addwf	SysTemp2,W
	movwf	BCDTODEC
	return

;********************************************************************************

CLS
;SET LCD_RS OFF
	bcf	SYSLCDTEMP,1
;Clear screen
;LCDWriteByte (0b00000001)
	movlw	1
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
;Wait 4 ms
	movlw	4
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;Move to start of visible DDRAM
;LCDWriteByte(0x80)
	movlw	128
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
;Wait 12 10us
	movlw	12
	movwf	SysWaitTemp10US
	goto	Delay_10US

;********************************************************************************

FN_DECTOBCD
;Convert pure decimal number to binary coded decimal
;DecToBcd=( va /10)*16+ va %10
	movf	VA,W
	movwf	SysBYTETempA
	movlw	10
	movwf	SysBYTETempB
	call	SysDivSub
	movf	SysBYTETempA,W
	movwf	SysTemp1
	movwf	SysBYTETempA
	movlw	16
	movwf	SysBYTETempB
	call	SysMultSub
	movf	SysBYTETempX,W
	movwf	SysTemp2
	movf	VA,W
	movwf	SysBYTETempA
	movlw	10
	movwf	SysBYTETempB
	call	SysDivSub
	movf	SysBYTETempX,W
	addwf	SysTemp2,W
	movwf	DECTOBCD
	return

;********************************************************************************

Delay_10US
D10US_START
	movlw	25
	movwf	DELAYTEMP
DelayUS0
	decfsz	DELAYTEMP,F
	goto	DelayUS0
	nop
	decfsz	SysWaitTemp10US, F
	goto	D10US_START
	return

;********************************************************************************

Delay_MS
	incf	SysWaitTempMS_H, F
DMS_START
	movlw	14
	movwf	DELAYTEMP2
DMS_OUTER
	movlw	189
	movwf	DELAYTEMP
DMS_INNER
	decfsz	DELAYTEMP, F
	goto	DMS_INNER
	decfsz	DELAYTEMP2, F
	goto	DMS_OUTER
	decfsz	SysWaitTempMS, F
	goto	DMS_START
	decfsz	SysWaitTempMS_H, F
	goto	DMS_START
	return

;********************************************************************************

Delay_S
DS_START
	movlw	232
	movwf	SysWaitTempMS
	movlw	3
	movwf	SysWaitTempMS_H
	call	Delay_MS
	decfsz	SysWaitTempS, F
	goto	DS_START
	return

;********************************************************************************

HI2CMODE
;#ifndef Var(SSPCON1)
;#ifdef Var(SSPCON)
;Dim SSPCON1 Alias SSPCON
;#endif
;#endif
;added to seperate from newer i2C module which does not have an MSSP
;set SSPSTAT.SMP on
	banksel	SSP1STAT
	bsf	SSP1STAT,SMP
;set SSPCON1.CKP on
	bsf	SSP1CON1,CKP
;set SSPCON1.WCOL Off
	bcf	SSP1CON1,WCOL
;Select mode and clock
;If HI2CCurrentMode = Master Then
	movlw	12
	banksel	HI2CCURRENTMODE
	subwf	HI2CCURRENTMODE,W
	btfss	STATUS, Z
	goto	ENDIF31
;set SSPCON1.SSPM3 on
	banksel	SSP1CON1
	bsf	SSP1CON1,SSPM3
;set SSPCON1.SSPM2 off
	bcf	SSP1CON1,SSPM2
;set SSPCON1.SSPM1 off
	bcf	SSP1CON1,SSPM1
;set SSPCON1.SSPM0 off
	bcf	SSP1CON1,SSPM0
;SSPADD = HI2C_BAUD_TEMP And 127
	movlw	79
	movwf	SSP1ADD
;end if
ENDIF31
;if HI2CCurrentMode = Slave then
	banksel	HI2CCURRENTMODE
	movf	HI2CCURRENTMODE,F
	btfss	STATUS, Z
	goto	ENDIF32
;set SSPCON1.SSPM3 off
	banksel	SSP1CON1
	bcf	SSP1CON1,SSPM3
;set SSPCON1.SSPM2 on
	bsf	SSP1CON1,SSPM2
;set SSPCON1.SSPM1 on
	bsf	SSP1CON1,SSPM1
;set SSPCON1.SSPM0 off
	bcf	SSP1CON1,SSPM0
;end if
ENDIF32
;if HI2CCurrentMode = Slave10 then
	movlw	3
	banksel	HI2CCURRENTMODE
	subwf	HI2CCURRENTMODE,W
	btfss	STATUS, Z
	goto	ENDIF33
;set SSPCON1.SSPM3 off
	banksel	SSP1CON1
	bcf	SSP1CON1,SSPM3
;set SSPCON1.SSPM2 on
	bsf	SSP1CON1,SSPM2
;set SSPCON1.SSPM1 on
	bsf	SSP1CON1,SSPM1
;set SSPCON1.SSPM0 on
	bsf	SSP1CON1,SSPM0
;end if
ENDIF33
;Enable I2C
;set SSPCON1.SSPEN on
	banksel	SSP1CON1
	bsf	SSP1CON1,SSPEN
	banksel	STATUS
	return

;********************************************************************************

HI2CRECEIVE
;Enable receive
;Master mode
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ELSE41_1
;if HI2CGetAck.0 = 1 then
	btfss	HI2CGETACK,0
	goto	ELSE43_1
;Acknowledge
;ACKDT = 0
	banksel	SSP1CON2
	bcf	SSP1CON2,ACKDT
;else
	goto	ENDIF43
ELSE43_1
;Not Acknowledge
;ACKDT = 1
	banksel	SSP1CON2
	bsf	SSP1CON2,ACKDT
;end if
ENDIF43
;RCEN = 1
	bsf	SSP1CON2,RCEN
;Slave mode
;Else
	goto	ENDIF41
ELSE41_1
;SET SSPSTAT.R_NOT_W ON
	banksel	SSP1STAT
	bsf	SSP1STAT,R_NOT_W
;End If
ENDIF41
;Clear Collisions
;SET SSPCON1.WCOL OFF
	bcf	SSP1CON1,WCOL
;SET SSPCON1.SSPOV Off
	bcf	SSP1CON1,SSPOV
;Wait for receive
;Wait Until SSPSTAT.BF = 1 AND SSPIF = 1
SysWaitLoop4
	clrf	SysByteTempX
	banksel	SSP1STAT
	btfsc	SSP1STAT,BF
	comf	SysByteTempX,F
	movf	SysByteTempX,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	clrf	SysByteTempX
	banksel	PIR3
	btfsc	PIR3,SSP1IF
	comf	SysByteTempX,F
	banksel	SYSTEMP1
	movf	SysTemp1,W
	andwf	SysByteTempX,W
	movwf	SysTemp2
	btfss	SysTemp2,0
	goto	SysWaitLoop4
;I2CByte = SSPBUF
	banksel	SSP1BUF
	movf	SSP1BUF,W
	banksel	I2CBYTE
	movwf	I2CBYTE
;SSPIF = 0''Support for SSPIF
	banksel	PIR3
	bcf	PIR3,SSP1IF
;ACKEN = 1; Send ACK DATA now. ' bsf SSPCON2,ACKEN
	banksel	SSP1CON2
	bsf	SSP1CON2,ACKEN
;Clear flag - this is required
;SSPSTAT.BF = 0
	bcf	SSP1STAT,BF
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;Disable receive (master mode)
;Master mode
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ELSE42_1
;Set SSPCON2.RCEN Off
	banksel	SSP1CON2
	bcf	SSP1CON2,RCEN
;Slave mode
;Else
	goto	ENDIF42
ELSE42_1
;SET SSPSTAT.R_NOT_W Off
	banksel	SSP1STAT
	bcf	SSP1STAT,R_NOT_W
;End If
ENDIF42
	banksel	STATUS
	return

;********************************************************************************

HI2CRESTART
;Master mode
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ENDIF35
;Set RSEN On
	banksel	SSP1CON2
	bsf	SSP1CON2,RSEN
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;End If
ENDIF35
	return

;********************************************************************************

HI2CSEND
RETRYHI2CSEND
;Clear WCOL
;SET SSPCON1.WCOL OFF
	banksel	SSP1CON1
	bcf	SSP1CON1,WCOL
;Load data to send
;SSPBUF = I2CByte
	banksel	I2CBYTE
	movf	I2CBYTE,W
	banksel	SSP1BUF
	movwf	SSP1BUF
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;if ACKSTAT =  1 then
	banksel	SSP1CON2
	btfss	SSP1CON2,ACKSTAT
	goto	ELSE37_1
;HI2CAckPollState = true
	movlw	255
	banksel	HI2CACKPOLLSTATE
	movwf	HI2CACKPOLLSTATE
;else
	goto	ENDIF37
ELSE37_1
;HI2CAckPollState = false
	banksel	HI2CACKPOLLSTATE
	clrf	HI2CACKPOLLSTATE
;end if
ENDIF37
;If SSPCON1.WCOL = On Then
	banksel	SSP1CON1
	btfss	SSP1CON1,WCOL
	goto	ENDIF38
;If HI2CCurrentMode <= 10 Then Goto RetryHI2CSend
	banksel	HI2CCURRENTMODE
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	RETRYHI2CSEND
ENDIF40
;End If
ENDIF38
;Release clock (only needed by slave)
;If HI2CCurrentMode <= 10 Then Set SSPCON1.CKP On
	banksel	HI2CCURRENTMODE
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfss	STATUS, C
	goto	ENDIF39
	banksel	SSP1CON1
	bsf	SSP1CON1,CKP
ENDIF39
	banksel	STATUS
	return

;********************************************************************************

HI2CSTART
;Master mode
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ELSE34_1
;Set SEN On
	banksel	SSP1CON2
	bsf	SSP1CON2,SEN
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;for device with SEN_SSP1CON2 and therefore devices including the 18FxxK40
;Slave mode
;Else
	goto	ENDIF34
ELSE34_1
;Wait Until SSPSTAT.S = On
SysWaitLoop1
	banksel	SSP1STAT
	btfss	SSP1STAT,S
	goto	SysWaitLoop1
;End If
ENDIF34
	banksel	STATUS
	return

;********************************************************************************

HI2CSTOP
;Master mode
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ELSE36_1
;set SSPIE OFF; disable SSP interrupt, tested by Anobium but not implemented.
;wait while R_NOT_W = 1   'wait for completion of activities
SysWaitLoop2
	banksel	SSP1STAT
	btfsc	SSP1STAT,R_NOT_W
	goto	SysWaitLoop2
;Set SSPCON2.PEN On
	bsf	SSP1CON2,PEN
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;Slave mode
;Else
	goto	ENDIF36
ELSE36_1
;Wait Until SSPSTAT.P = On
SysWaitLoop3
	banksel	SSP1STAT
	btfss	SSP1STAT,P
	goto	SysWaitLoop3
;End If
ENDIF36
	banksel	STATUS
	return

;********************************************************************************

HI2CWAITMSSP
;HI2CWaitMSSPTimeout = 0
	clrf	HI2CWAITMSSPTIMEOUT
HI2CWAITMSSPWAIT
;HI2CWaitMSSPTimeout++
	banksel	HI2CWAITMSSPTIMEOUT
	incf	HI2CWAITMSSPTIMEOUT,F
;if HI2CWaitMSSPTimeout < 255 then
	movlw	255
	subwf	HI2CWAITMSSPTIMEOUT,W
	btfsc	STATUS, C
	goto	ENDIF44
;'Support for SSP1IF
;if SSP1IF = 0 then goto HI2CWaitMSSPWait
	banksel	PIR3
	btfss	PIR3,SSP1IF
	goto	HI2CWAITMSSPWAIT
ENDIF45
;SSP1IF = 0
	bcf	PIR3,SSP1IF
;exit Sub
	banksel	STATUS
	return
;'Support for SSPIF
;if SSPIF = 0 then goto HI2CWaitMSSPWait
	banksel	PIR3
	btfss	PIR3,SSP1IF
	goto	HI2CWAITMSSPWAIT
ENDIF46
;SSPIF = 0
	bcf	PIR3,SSP1IF
;exit Sub
	banksel	STATUS
	return
;end if
ENDIF44
	return

;********************************************************************************

HIC2INIT
;HI2CCurrentMode = 0
	clrf	HI2CCURRENTMODE
;Initialise the I2C module
	return

;********************************************************************************

INITI2CLCD
;moved to a sub support multiple devices
;wait 15 ms
	movlw	15
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;LCDWriteByte 0x03: wait 5 ms
	movlw	3
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
	movlw	5
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;LCDWriteByte 0x03: wait 1 ms
	movlw	3
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
	movlw	1
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;LCDWriteByte 0x03: wait 1 ms
	movlw	3
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
	movlw	1
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;LCDWriteByte 0x03: wait 1 ms
	movlw	3
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
	movlw	1
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;LCDWriteByte 0x02: wait 1 ms
	movlw	2
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
	movlw	1
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;LCDWriteByte 0x28: wait 1 ms
	movlw	40
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
	movlw	1
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;LCDWriteByte 0x0c: wait 1 ms
	movlw	12
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
	movlw	1
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;LCDWriteByte 0x01: wait 15 ms
	movlw	1
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
	movlw	15
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;LCDWriteByte 0x06: wait 1 ms
	movlw	6
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
	movlw	1
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;CLS
	goto	CLS

;********************************************************************************

INITLCD
;Initialization routines based upon code examples
;in HD44780 datasheet
;Configure RS,Enable & RW pin directions
;***********************************
;I2C pcf8574 initialization routine
;***********************************
;HI2CMode Master    ;call to Master required to init I2C Baud Rate here!
	movlw	12
	movwf	HI2CCURRENTMODE
	call	HI2CMODE
;LCD_Backlight = LCD_Backlight_On_State
	movlw	1
	movwf	LCD_BACKLIGHT
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;repeat 2  ; called to ensure reset is complete.  Needed for cheap LCDs!!
	movlw	2
	movwf	SysRepeatTemp1
SysRepeatLoop1
;LCD_I2C_Address_Current = LCD_I2C_Address_1
	movlw	76
	movwf	LCD_I2C_ADDRESS_CURRENT
;initI2CLCD
	call	INITI2CLCD
;end repeat
	decfsz	SysRepeatTemp1,F
	goto	SysRepeatLoop1
SysRepeatLoopEnd1
;LCD_State = 12
	movlw	12
	movwf	LCD_STATE
	return

;********************************************************************************

INITPPS
;Module: MSSP1
;RB5PPS = 0x0016    'SDA1 > RB5
	movlw	22
	banksel	RB5PPS
	movwf	RB5PPS
;SSP1DATPPS = 0x000D    'RB5 > SDA1 (bi-directional)
	movlw	13
	banksel	SSP1DATPPS
	movwf	SSP1DATPPS
;RB7PPS = 0x0015    'SCL1 > RB7
	movlw	21
	banksel	RB7PPS
	movwf	RB7PPS
;SSP1CLKPPS = 0x000F    'RB7 > SCL1 (bi-directional)
	movlw	15
	banksel	SSP1CLKPPS
	movwf	SSP1CLKPPS
;Module: EUSART1
;RB6PPS = 0x000F    'TX1 > RB6
	movlw	15
	banksel	RB6PPS
	movwf	RB6PPS
	banksel	STATUS
	return

;********************************************************************************

INITSYS
;Set up internal oscillator
;Handle OSCCON1 register for parts that have this register
;asm showdebug OSCCON type is 100 'This is the routine to support OSCCON1 config addresss
;osccon type is 100
;OSCCON1 = 0x60 ' NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
	movlw	96
	banksel	OSCCON1
	movwf	OSCCON1
;OSCCON3 = 0x00 ' CSWHOLD may proceed; SOSCPWR Low power
	clrf	OSCCON3
;OSCEN = 0x00   ' MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
	clrf	OSCEN
;OSCTUNE = 0x00 ' HFTUN 0
	clrf	OSCTUNE
;asm showdebug OSCCON type is 102 'therefore not CHIPFamily 16
;osccon type is 102
;OSCFRQ = 0b00000110 'OSCSTAT chip.... the 16f18855 style chip
	movlw	6
	movwf	OSCFRQ
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	banksel	ADCON1
	bcf	ADCON1,ADFM
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	bcf	ADCON0,ADON
;Commence clearing any ANSEL variants in the part
;ANSELA = 0
	banksel	ANSELA
	clrf	ANSELA
;ANSELB = 0
	clrf	ANSELB
;ANSELC = 0
	clrf	ANSELC
;ANSELD = 0
	clrf	ANSELD
;ANSELE = 0
	clrf	ANSELE
;End clearing any ANSEL variants in the part
;Comparator register bits for 12F510,16F506, PIC16F1535 classes
;C2EN = 0
	banksel	CM2CON0
	bcf	CM2CON0,C2EN
;C1EN = 0
	bcf	CM1CON0,C1EN
;Turn off all ports
;PORTA = 0
	banksel	PORTA
	clrf	PORTA
;PORTB = 0
	clrf	PORTB
;PORTC = 0
	clrf	PORTC
;PORTD = 0
	clrf	PORTD
;PORTE = 0
	clrf	PORTE
	return

;********************************************************************************

LCDCURSOR
;Revised Evan Venn March 2014
;Revised William Roth Jan 2105
;Can be LCDON, LCDOFF, CURSORON, CURSOROFF, FLASHON, Or FLASHOFF
;1) FLASH is the same as FLASHON and has been retained
;for compatibility but should be considererd depricated.
;
;2) ON & OFF Have been superceded with LCDON & LCDOFF for clarity.
;However they Will still work as usual. This was done
;because LCDCURSOR(OFF | ON) was confusing and implied
;control of the cursor instead of the entire display.
;
;3) With this revision, changing one setting does not change the others.
;eg.  FlashOFF does turn off the cursor and CURSOROFF does not
;turn off Flash. Cursor and flash states are not changed when the
;display is turned OFF or ON with LCDCURSOR LCDON OR LCDCURSOR LCDOFF.
;
;4) See Help For New Commands  LCD_OFF and LCD_ON
;LCD_ON & LCD OFF are separate Subs that when called
;will also turn off the cursor and flash if they are on
;-------------------------------------------------------------------
;Set LCD_RS OFF
	bcf	SYSLCDTEMP,1
;If LCDCRSR = ON  Then LCDTemp = LCD_State OR LCDON
	decf	LCDCRSR,W
	btfss	STATUS, Z
	goto	ENDIF22
	movlw	12
	iorwf	LCD_STATE,W
	movwf	LCDTEMP
ENDIF22
;IF LCDCRSR = LCDON Then LCDTemp = LCD_State OR LCDON
	movlw	12
	subwf	LCDCRSR,W
	btfss	STATUS, Z
	goto	ENDIF23
	movlw	12
	iorwf	LCD_STATE,W
	movwf	LCDTEMP
ENDIF23
;If LCDCRSR = OFF Then LCDTemp = LCD_State AND LCDOFF
	movf	LCDCRSR,F
	btfss	STATUS, Z
	goto	ENDIF24
	movlw	11
	andwf	LCD_STATE,W
	movwf	LCDTEMP
ENDIF24
;If LCDCRSR = LCDOFF Then LCDTemp = LCD_State AND LCDOFF
	movlw	11
	subwf	LCDCRSR,W
	btfss	STATUS, Z
	goto	ENDIF25
	movlw	11
	andwf	LCD_STATE,W
	movwf	LCDTEMP
ENDIF25
;If LCDCRSR = CursorOn Then LCDTemp = LCD_State OR CursorON
	movlw	10
	subwf	LCDCRSR,W
	btfss	STATUS, Z
	goto	ENDIF26
	movlw	10
	iorwf	LCD_STATE,W
	movwf	LCDTEMP
ENDIF26
;If LCDCRSR = CursorOFF then LCDTemp = LCD_State and CursorOFF
	movlw	13
	subwf	LCDCRSR,W
	btfss	STATUS, Z
	goto	ENDIF27
	movlw	13
	andwf	LCD_STATE,W
	movwf	LCDTEMP
ENDIF27
;If LCDCRSR = FLASH  Then LCDTemp = LCD_State OR FLASHON
	movlw	9
	subwf	LCDCRSR,W
	btfss	STATUS, Z
	goto	ENDIF28
	movlw	9
	iorwf	LCD_STATE,W
	movwf	LCDTEMP
ENDIF28
;If LCDCRSR = FLASHON  Then LCDTemp = LCD_State OR FLASHON
	movlw	9
	subwf	LCDCRSR,W
	btfss	STATUS, Z
	goto	ENDIF29
	movlw	9
	iorwf	LCD_STATE,W
	movwf	LCDTEMP
ENDIF29
;If LCDCRSR = FLASHOFF then LCDTemp = LCD_State and FLASHOFF
	movlw	14
	subwf	LCDCRSR,W
	btfss	STATUS, Z
	goto	ENDIF30
	movlw	14
	andwf	LCD_STATE,W
	movwf	LCDTEMP
ENDIF30
;LCDWriteByte(LCDTemp)
	movf	LCDTEMP,W
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
;LCD_State = LCDtemp  'save last state
	movf	LCDTEMP,W
	movwf	LCD_STATE
	return

;********************************************************************************

LCDNORMALWRITEBYTE
;IF LCD_RS = 1 then
	btfss	SYSLCDTEMP,1
	goto	ELSE10_1
;i2c_lcd_rs=1;   ''' Data
	bsf	I2C_LCD_BYTE,0
;ELSE
	goto	ENDIF10
ELSE10_1
;i2c_lcd_rs=0;   ''' Command
	bcf	I2C_LCD_BYTE,0
;end if
ENDIF10
;i2c_lcd_rw  = 0;
	bcf	I2C_LCD_BYTE,1
;i2c_lcd_bl  = LCD_Backlight.0;
	bcf	I2C_LCD_BYTE,3
	btfsc	LCD_BACKLIGHT,0
	bsf	I2C_LCD_BYTE,3
ENDIF13
;HI2CStart                        ;generate a start signal
	call	HI2CSTART
;HI2CSend LCD_I2C_Address_Current   ;indicate a write
	movf	LCD_I2C_ADDRESS_CURRENT,W
	movwf	I2CBYTE
	call	HI2CSEND
;i2c_lcd_d7 = LCDByte.7
	bcf	I2C_LCD_BYTE,7
	btfsc	LCDBYTE,7
	bsf	I2C_LCD_BYTE,7
ENDIF14
;i2c_lcd_d6 = LCDByte.6
	bcf	I2C_LCD_BYTE,6
	btfsc	LCDBYTE,6
	bsf	I2C_LCD_BYTE,6
ENDIF15
;i2c_lcd_d5 = LCDByte.5
	bcf	I2C_LCD_BYTE,5
	btfsc	LCDBYTE,5
	bsf	I2C_LCD_BYTE,5
ENDIF16
;i2c_lcd_d4 = LCDByte.4
	bcf	I2C_LCD_BYTE,4
	btfsc	LCDBYTE,4
	bsf	I2C_LCD_BYTE,4
ENDIF17
;i2c_lcd_e = 0;
	bcf	I2C_LCD_BYTE,2
;HI2CSend i2c_lcd_byte
	movf	I2C_LCD_BYTE,W
	movwf	I2CBYTE
	call	HI2CSEND
;i2c_lcd_e = 1;
	bsf	I2C_LCD_BYTE,2
;HI2CSend i2c_lcd_byte
	movf	I2C_LCD_BYTE,W
	movwf	I2CBYTE
	call	HI2CSEND
;i2c_lcd_e = 0;
	bcf	I2C_LCD_BYTE,2
;HI2CSend i2c_lcd_byte
	movf	I2C_LCD_BYTE,W
	movwf	I2CBYTE
	call	HI2CSEND
;'' Send lower nibble
;i2c_lcd_d7 = LCDByte.3
	bcf	I2C_LCD_BYTE,7
	btfsc	LCDBYTE,3
	bsf	I2C_LCD_BYTE,7
ENDIF18
;i2c_lcd_d6 = LCDByte.2
	bcf	I2C_LCD_BYTE,6
	btfsc	LCDBYTE,2
	bsf	I2C_LCD_BYTE,6
ENDIF19
;i2c_lcd_d5 = LCDByte.1
	bcf	I2C_LCD_BYTE,5
	btfsc	LCDBYTE,1
	bsf	I2C_LCD_BYTE,5
ENDIF20
;i2c_lcd_d4 = LCDByte.0
	bcf	I2C_LCD_BYTE,4
	btfsc	LCDBYTE,0
	bsf	I2C_LCD_BYTE,4
ENDIF21
;i2c_lcd_e = 0;
	bcf	I2C_LCD_BYTE,2
;HI2CSend i2c_lcd_byte
	movf	I2C_LCD_BYTE,W
	movwf	I2CBYTE
	call	HI2CSEND
;i2c_lcd_e = 1;
	bsf	I2C_LCD_BYTE,2
;HI2CSend i2c_lcd_byte
	movf	I2C_LCD_BYTE,W
	movwf	I2CBYTE
	call	HI2CSEND
;i2c_lcd_e = 0;
	bcf	I2C_LCD_BYTE,2
;HI2CSend i2c_lcd_byte
	movf	I2C_LCD_BYTE,W
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CStop
	call	HI2CSTOP
;LCD_State = 12
	movlw	12
	movwf	LCD_STATE
;character delay settings
;wait fast_us us
	movlw	26
	movwf	DELAYTEMP
DelayUS1
	decfsz	DELAYTEMP,F
	goto	DelayUS1
	nop
;IF LCDByte < 16 then
	movlw	16
	subwf	LCDBYTE,W
	btfsc	STATUS, C
	goto	ENDIF11
;if LCDByte > 7 then
	movf	LCDBYTE,W
	sublw	7
	btfsc	STATUS, C
	goto	ENDIF12
;LCD_State = LCDByte
	movf	LCDBYTE,W
	movwf	LCD_STATE
;end if
ENDIF12
;END IF
ENDIF11
	return

;********************************************************************************

LOCATE
;Set LCD_RS Off
	bcf	SYSLCDTEMP,1
;If LCDLine > 1 Then
	movf	LCDLINE,W
	sublw	1
	btfsc	STATUS, C
	goto	ENDIF6
;LCDLine = LCDLine - 2
	movlw	2
	subwf	LCDLINE,F
;LCDColumn = LCDColumn + LCD_WIDTH
	movlw	20
	addwf	LCDCOLUMN,F
;End If
ENDIF6
;LCDWriteByte(0x80 or 0x40 * LCDLine + LCDColumn)
	movf	LCDLINE,W
	movwf	SysBYTETempA
	movlw	64
	movwf	SysBYTETempB
	call	SysMultSub
	movf	LCDCOLUMN,W
	addwf	SysBYTETempX,W
	movwf	SysTemp1
	movlw	128
	iorwf	SysTemp1,W
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
;wait 5 10us 'test
	movlw	5
	movwf	SysWaitTemp10US
	goto	Delay_10US

;********************************************************************************

PCF8563_ENABLE
;use DS_Sec as a temp variable
;do
SysDoLoop_S2
;HI2CReStart                          ;generate a start signal
	call	HI2CRESTART
;HI2CSend(DS_AddrWrite)                     ;inidcate a write
	movlw	162
	movwf	I2CBYTE
	call	HI2CSEND
;loop While HI2CAckPollState
	movf	hi2cackpollstate,F
	btfss	STATUS,Z
	goto	SysDoLoop_S2
SysDoLoop_E2
;HI2CSend(CLKOUT_CTRL_REG)                     ;indicate register CLKOUT_CTRL_REG
	movlw	13
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CReStart
	call	HI2CRESTART
;HI2CSend(DS_AddrRead)
	movlw	163
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CReceive(DS_Sec, NACK)       ;get the current seconds
	clrf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	DS_SEC
;if DS_Value then
	movf	DS_VALUE,F
	btfsc	STATUS,Z
	goto	ELSE3_1
;set DS_Sec.7 on              ;enables
	bsf	DS_SEC,7
;else
	goto	ENDIF3
ELSE3_1
;set DS_Sec.7 off             ;disables
	bcf	DS_SEC,7
;end if
ENDIF3
;HI2CReStart
	call	HI2CRESTART
;HI2CSend(DS_AddrWrite)
	movlw	162
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend(CLKOUT_CTRL_REG)                     ;indicate register 0
	movlw	13
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend(DS_Sec)                ;now send updated value
	movf	DS_SEC,W
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CStop
	goto	HI2CSTOP

;********************************************************************************

PCF8563_ENABLECLOCKOUTFREQUENCY
;use DS_Sec as a temp variable
;do
SysDoLoop_S3
;HI2CReStart                          ;generate a start signal
	call	HI2CRESTART
;HI2CSend(DS_AddrWrite)                     ;inidcate a write
	movlw	162
	movwf	I2CBYTE
	call	HI2CSEND
;loop While HI2CAckPollState
	movf	hi2cackpollstate,F
	btfss	STATUS,Z
	goto	SysDoLoop_S3
SysDoLoop_E3
;HI2CSend(CLKOUT_CTRL_REG)                     ;indicate register CLKOUT_CTRL_REG
	movlw	13
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CReStart
	call	HI2CRESTART
;HI2CSend(DS_AddrRead)
	movlw	163
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CReceive(DS_Sec, NACK)       ;get the current seconds
	clrf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	DS_SEC
;DS_Sec = DS_Sec and 0xFC        ;mask the lower two bits
	movlw	252
	andwf	DS_SEC,F
;DS_Sec = DS_Sec or DS_Value     ;or the lower two bits
	movf	DS_SEC,W
	iorwf	DS_VALUE,W
	movwf	DS_SEC
;HI2CReStart
	call	HI2CRESTART
;HI2CSend(DS_AddrWrite)
	movlw	162
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend(CLKOUT_CTRL_REG)                     ;indicate register 0
	movlw	13
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend(DS_Sec)                ;now send updated value
	movf	DS_SEC,W
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CStop
	goto	HI2CSTOP

;********************************************************************************

PCF8563_READDATE
;Get date only: day of week, date, month, year
;do
SysDoLoop_S6
;HI2CReStart                          ;generate a start signal
	call	HI2CRESTART
;HI2CSend(DS_AddrWrite)                     ;inidcate a write
	movlw	162
	movwf	I2CBYTE
	call	HI2CSEND
;loop While HI2CAckPollState
	movf	hi2cackpollstate,F
	btfss	STATUS,Z
	goto	SysDoLoop_S6
SysDoLoop_E6
;HI2CSend(5)                      ;begin with address 3
	movlw	5
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CReStart
	call	HI2CRESTART
;HI2CSend(DS_AddrRead)
	movlw	163
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CReceive(DS_Date, ACK)              ;get date
	movlw	255
	movwf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	DS_DATE
;DS_Date = BcdToDec(DS_Date)
	movwf	VA
	call	FN_BCDTODEC
	movf	BCDTODEC,W
	movwf	DS_DATE
;HI2CReceive(DS_DOW, ACK)             ;get dow the week
	movlw	255
	movwf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	DS_DOW
;DS_DOW = BcdToDec(DS_DOW)
	movwf	VA
	call	FN_BCDTODEC
	movf	BCDTODEC,W
	movwf	DS_DOW
;DS_DOW = ( DS_DOW and 7 ) + 1
	movlw	7
	andwf	DS_DOW,W
	movwf	SysTemp1
	incf	SysTemp1,W
	movwf	DS_DOW
;HI2CReceive(DS_Month, ACK)            ;get month
	movlw	255
	movwf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	DS_MONTH
;DS_Month.7 = 0
	bcf	DS_MONTH,7
;DS_Month = BcdToDec(DS_Month)
	movf	DS_MONTH,W
	movwf	VA
	call	FN_BCDTODEC
	movf	BCDTODEC,W
	movwf	DS_MONTH
;HI2CReceive(DS_Year, NACK)       ;get year
	clrf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	DS_YEAR
;DS_Year = BcdToDec(DS_Year)
	movwf	VA
	call	FN_BCDTODEC
	movf	BCDTODEC,W
	movwf	DS_YEAR
;HI2CStop
	goto	HI2CSTOP

;********************************************************************************

PCF8563_READTIME
;Read time only: hours, minutes, seconds, a.m. or p.m.
;do
SysDoLoop_S5
;HI2CReStart                          ;generate a start signal
	call	HI2CRESTART
;HI2CSend(DS_AddrWrite)                     ;inidcate a write
	movlw	162
	movwf	I2CBYTE
	call	HI2CSEND
;loop While HI2CAckPollState
	movf	hi2cackpollstate,F
	btfss	STATUS,Z
	goto	SysDoLoop_S5
SysDoLoop_E5
;HI2CSend(2)                      ;begin
	movlw	2
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CReStart
	call	HI2CRESTART
;HI2CSend(DS_AddrRead)
	movlw	163
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CReceive(DS_Sec, ACK)              ;get the seconds
	movlw	255
	movwf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	DS_SEC
;DS_Sec = BcdToDec(DS_Sec & 127) ;strip off CH bit
	movlw	127
	andwf	DS_SEC,W
	movwf	VA
	call	FN_BCDTODEC
	movf	BCDTODEC,W
	movwf	DS_SEC
;HI2CReceive(DS_Min, ACK)              ;get the minutes
	movlw	255
	movwf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	DS_MIN
;DS_Min = BcdToDec(DS_Min)
	movwf	VA
	call	FN_BCDTODEC
	movf	BCDTODEC,W
	movwf	DS_MIN
;HI2CReceive(DS_Hour, NACK)       ;get the hours
	clrf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	DS_HOUR
;if DS_Hour.6 then               ;12-hour mode
	btfss	DS_HOUR,6
	goto	ELSE4_1
;DS_A_P = DS_Hour.5            ;a.m. or p.m.
	clrf	DS_A_P
	btfsc	DS_HOUR,5
	incf	DS_A_P,F
ENDIF5
;DS_Hour = BcdToDec(DS_Hour & 31)
	movlw	31
	andwf	DS_HOUR,W
	movwf	VA
	call	FN_BCDTODEC
	movf	BCDTODEC,W
	movwf	DS_HOUR
;else
	goto	ENDIF4
ELSE4_1
;DS_Hour = BcdToDec(DS_Hour)   ;24-hour mode
	movf	DS_HOUR,W
	movwf	VA
	call	FN_BCDTODEC
	movf	BCDTODEC,W
	movwf	DS_HOUR
;DS_A_P = (DS_Hour > 11)       ;a.m. or p.m.
	movwf	SysBYTETempB
	movlw	11
	movwf	SysBYTETempA
	call	SysCompLessThan
	movf	SysByteTempX,W
	movwf	DS_A_P
;end if
ENDIF4
;HI2CStop
	goto	HI2CSTOP

;********************************************************************************

PCF8563_RESETCLOCK
;Reset clock to 00:00:00 Tues 01/01/18.
;Also sets 24-hour mode and enables the clock.
;do
SysDoLoop_S4
;HI2CReStart                          ;generate a start signal
	call	HI2CRESTART
;HI2CSend(DS_AddrWrite)                     ;inidcate a write
	movlw	162
	movwf	I2CBYTE
	call	HI2CSEND
;loop While HI2CAckPollState
	movf	hi2cackpollstate,F
	btfss	STATUS,Z
	goto	SysDoLoop_S4
SysDoLoop_E4
;HI2CSend(VL_SEC_REG)                      ;begin
	movlw	2
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend(0)                      ;then set the seven
	clrf	I2CBYTE
	call	HI2CSEND
;HI2CSend(0)                      ;consecutive locations
	clrf	I2CBYTE
	call	HI2CSEND
;HI2CSend(0)
	clrf	I2CBYTE
	call	HI2CSEND
;HI2CSend( DecToBcd ( 28 ) )
	movlw	28
	movwf	VA
	call	FN_DECTOBCD
	movf	DECTOBCD,W
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend( DecToBcd ( 2 ) )
	movlw	2
	movwf	VA
	call	FN_DECTOBCD
	movf	DECTOBCD,W
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend( DecToBcd ( 2 ) )
	movlw	2
	movwf	VA
	call	FN_DECTOBCD
	movf	DECTOBCD,W
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend( DecToBcd ( 18) )
	movlw	18
	movwf	VA
	call	FN_DECTOBCD
	movf	DECTOBCD,W
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CStop
	goto	HI2CSTOP

;********************************************************************************

;Overloaded signature: STRING:
PRINT129
;PrintLen = LEN(PrintData$)
;PrintLen = PrintData(0)
	movf	SysPRINTDATAHandler,W
	movwf	AFSR0
	movf	SysPRINTDATAHandler_H,W
	movwf	AFSR0_H
	movf	INDF0,W
	movwf	PRINTLEN
;If PrintLen = 0 Then Exit Sub
	movf	PRINTLEN,F
	btfsc	STATUS, Z
	return
ENDIF7
;Set LCD_RS On
	bsf	SYSLCDTEMP,1
;Write Data
;For SysPrintTemp = 1 To PrintLen
	clrf	SYSPRINTTEMP
	movlw	1
	subwf	PRINTLEN,W
	btfss	STATUS, C
	goto	SysForLoopEnd1
ENDIF8
SysForLoop1
	incf	SYSPRINTTEMP,F
;LCDWriteByte PrintData(SysPrintTemp)
	movf	SYSPRINTTEMP,W
	addwf	SysPRINTDATAHandler,W
	movwf	AFSR0
	movlw	0
	addwfc	SysPRINTDATAHandler_H,W
	movwf	AFSR0_H
	movf	INDF0,W
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
;Next
	movf	PRINTLEN,W
	subwf	SYSPRINTTEMP,W
	btfss	STATUS, C
	goto	SysForLoop1
ENDIF9
SysForLoopEnd1
	return

;********************************************************************************

;Overloaded signature: BYTE:
PRINT130
;LCDValueTemp = 0
	clrf	LCDVALUETEMP
;Set LCD_RS On
	bsf	SYSLCDTEMP,1
;IF LCDValue >= 100 Then
	movlw	100
	subwf	LCDVALUE,W
	btfss	STATUS, C
	goto	ENDIF55
;LCDValueTemp = LCDValue / 100
	movf	LCDVALUE,W
	movwf	SysBYTETempA
	movlw	100
	movwf	SysBYTETempB
	call	SysDivSub
	movf	SysBYTETempA,W
	movwf	LCDVALUETEMP
;LCDValue = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	LCDVALUE
;LCDWriteByte(LCDValueTemp + 48)
	movlw	48
	addwf	LCDVALUETEMP,W
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
;End If
ENDIF55
;If LCDValueTemp > 0 Or LCDValue >= 10 Then
	movf	LCDVALUETEMP,W
	movwf	SysBYTETempB
	clrf	SysBYTETempA
	call	SysCompLessThan
	movf	SysByteTempX,W
	movwf	SysTemp1
	movf	LCDVALUE,W
	movwf	SysBYTETempA
	movlw	10
	movwf	SysBYTETempB
	call	SysCompLessThan
	comf	SysByteTempX,F
	movf	SysTemp1,W
	iorwf	SysByteTempX,W
	movwf	SysTemp2
	btfss	SysTemp2,0
	goto	ENDIF56
;LCDValueTemp = LCDValue / 10
	movf	LCDVALUE,W
	movwf	SysBYTETempA
	movlw	10
	movwf	SysBYTETempB
	call	SysDivSub
	movf	SysBYTETempA,W
	movwf	LCDVALUETEMP
;LCDValue = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	LCDVALUE
;LCDWriteByte(LCDValueTemp + 48)
	movlw	48
	addwf	LCDVALUETEMP,W
	movwf	LCDBYTE
	call	LCDNORMALWRITEBYTE
;End If
ENDIF56
;LCDWriteByte (LCDValue + 48)
	movlw	48
	addwf	LCDVALUE,W
	movwf	LCDBYTE
	goto	LCDNORMALWRITEBYTE

;********************************************************************************

PRINTDATE
;select case DOW                   ;day of the week
;case 0:
SysSelect1Case1
	movf	DOW,F
	btfss	STATUS, Z
	goto	SysSelect1Case2
;Print "Sun."
	movlw	low StringTable9
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable9) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;case 1:
	goto	SysSelectEnd1
SysSelect1Case2
	decf	DOW,W
	btfss	STATUS, Z
	goto	SysSelect1Case3
;Print "Mon."
	movlw	low StringTable10
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable10) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;case 2:
	goto	SysSelectEnd1
SysSelect1Case3
	movlw	2
	subwf	DOW,W
	btfss	STATUS, Z
	goto	SysSelect1Case4
;Print "Tue."
	movlw	low StringTable11
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable11) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;case 3:
	goto	SysSelectEnd1
SysSelect1Case4
	movlw	3
	subwf	DOW,W
	btfss	STATUS, Z
	goto	SysSelect1Case5
;Print "Wed."
	movlw	low StringTable12
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable12) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;case 4:
	goto	SysSelectEnd1
SysSelect1Case5
	movlw	4
	subwf	DOW,W
	btfss	STATUS, Z
	goto	SysSelect1Case6
;Print "Thu."
	movlw	low StringTable13
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable13) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;case 5:
	goto	SysSelectEnd1
SysSelect1Case6
	movlw	5
	subwf	DOW,W
	btfss	STATUS, Z
	goto	SysSelect1Case7
;Print "Fri."
	movlw	low StringTable14
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable14) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;case 6:
	goto	SysSelectEnd1
SysSelect1Case7
	movlw	6
	subwf	DOW,W
	btfss	STATUS, Z
	goto	SysSelect1Case8
;Print "Sat."
	movlw	low StringTable15
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable15) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;case else
	goto	SysSelectEnd1
SysSelect1Case8
;Print str(DOW)+":"
	movf	DOW,W
	movwf	SYSVALTEMP
	clrf	SYSVALTEMP_H
	call	FN_STR
	movlw	low SYSSTRINGPARAM1
	movwf	FSR1L
	movlw	high SYSSTRINGPARAM1
	movwf	FSR1H
	clrf	SysStringLength
	movlw	low STR
	movwf	FSR0L
	movlw	high STR
	movwf	FSR0H
	call	SysCopyStringPart
	movlw	low StringTable5
	movwf	SysStringA
	movlw	(high StringTable5) & 127
	movwf	SysStringA_H
	call	SysReadStringPart
	movlw	low SYSSTRINGPARAM1
	movwf	FSR0L
	movlw	high SYSSTRINGPARAM1
	movwf	FSR0H
	movf	SysStringLength,W
	movwf	INDF0
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;end select
SysSelectEnd1
;if clocktype = 0 then
;Print date
	movf	DATE,W
	movwf	LCDVALUE
	call	PRINT130
;Print "/"
	movlw	low StringTable16
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable16) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;Print month
	movf	MONTH,W
	movwf	LCDVALUE
	call	PRINT130
;Print "/20"                       ;make four-digit year
	movlw	low StringTable17
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable17) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;if year < 10 then
	movlw	10
	subwf	YEAR,W
	btfsc	STATUS, C
	goto	ENDIF54
;Print "0"
	movlw	low StringTable4
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable4) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;end if
ENDIF54
;end if
;Print year
	movf	YEAR,W
	movwf	LCDVALUE
	call	PRINT130
;Print " "                        ;blank any garbage
	movlw	low StringTable18
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable18) | 128
	movwf	SysPRINTDATAHandler_H
	goto	PRINT129

;********************************************************************************

PRINTTIME
;if mode = 24 then
	movlw	24
	subwf	MODE,W
	btfss	STATUS, Z
	goto	ENDIF47
;if hour < 10 then               ;left pad with zero
	movlw	10
	subwf	HOUR,W
	btfsc	STATUS, C
	goto	ENDIF51
;Print "0"
	movlw	low StringTable4
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable4) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;end if
ENDIF51
;end if
ENDIF47
;Print hour
	movf	HOUR,W
	movwf	LCDVALUE
	call	PRINT130
;Print ":"
	movlw	low StringTable5
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable5) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;if min < 10 then                  ;left pad with zero
	movlw	10
	subwf	MIN,W
	btfsc	STATUS, C
	goto	ENDIF48
;Print "0"
	movlw	low StringTable4
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable4) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;end if
ENDIF48
;Print min
	movf	MIN,W
	movwf	LCDVALUE
	call	PRINT130
;Print ":"
	movlw	low StringTable5
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable5) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;if sec < 10 then                  ;left pad with zero
	movlw	10
	subwf	SEC,W
	btfsc	STATUS, C
	goto	ENDIF49
;Print "0"
	movlw	low StringTable4
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable4) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;end if
ENDIF49
;Print sec
	movf	SEC,W
	movwf	LCDVALUE
	call	PRINT130
;if mode = 12 then                 ;Print a.m or p.m
	movlw	12
	subwf	MODE,W
	btfss	STATUS, Z
	goto	ELSE50_1
;if am_pm then                   ;only in 12-hour mode
	movf	AM_PM,F
	btfsc	STATUS,Z
	goto	ELSE52_1
;Print " p.m. "
	movlw	low StringTable6
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable6) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;else
	goto	ENDIF52
ELSE52_1
;Print " a.m. "
	movlw	low StringTable7
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable7) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;end if
ENDIF52
;else
	goto	ENDIF50
ELSE50_1
;Print "     "                   ;wipe out garbage
	movlw	low StringTable8
	movwf	SysPRINTDATAHandler
	movlw	(high StringTable8) | 128
	movwf	SysPRINTDATAHandler_H
	call	PRINT129
;end if
ENDIF50
	return

;********************************************************************************

FN_STR
;SysCharCount = 0
	clrf	SYSCHARCOUNT
;Dim SysCalcTempX As Word
;Ten Thousands
;IF SysValTemp >= 10000 then
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	16
	movwf	SysWORDTempB
	movlw	39
	movwf	SysWORDTempB_H
	call	SysCompLessThan16
	comf	SysByteTempX,F
	btfss	SysByteTempX,0
	goto	ENDIF57
;SysStrData = SysValTemp / 10000
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	16
	movwf	SysWORDTempB
	movlw	39
	movwf	SysWORDTempB_H
	call	SysDivSub16
	movf	SysWORDTempA,W
	movwf	SYSSTRDATA
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;SysCharCount += 1
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	clrf	SysTemp2
	movlw	high(STR)
	addwfc	SysTemp2,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSSTRDATA,W
	movwf	INDF0
;Goto SysValThousands
	goto	SYSVALTHOUSANDS
;End If
ENDIF57
;Thousands
;IF SysValTemp >= 1000 then
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	232
	movwf	SysWORDTempB
	movlw	3
	movwf	SysWORDTempB_H
	call	SysCompLessThan16
	comf	SysByteTempX,F
	btfss	SysByteTempX,0
	goto	ENDIF58
SYSVALTHOUSANDS
;SysStrData = SysValTemp / 1000
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	232
	movwf	SysWORDTempB
	movlw	3
	movwf	SysWORDTempB_H
	call	SysDivSub16
	movf	SysWORDTempA,W
	movwf	SYSSTRDATA
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;SysCharCount += 1
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	clrf	SysTemp2
	movlw	high(STR)
	addwfc	SysTemp2,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSSTRDATA,W
	movwf	INDF0
;Goto SysValHundreds
	goto	SYSVALHUNDREDS
;End If
ENDIF58
;Hundreds
;IF SysValTemp >= 100 then
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	100
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	call	SysCompLessThan16
	comf	SysByteTempX,F
	btfss	SysByteTempX,0
	goto	ENDIF59
SYSVALHUNDREDS
;SysStrData = SysValTemp / 100
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	100
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	call	SysDivSub16
	movf	SysWORDTempA,W
	movwf	SYSSTRDATA
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;SysCharCount += 1
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	clrf	SysTemp2
	movlw	high(STR)
	addwfc	SysTemp2,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSSTRDATA,W
	movwf	INDF0
;Goto SysValTens
	goto	SYSVALTENS
;End If
ENDIF59
;Tens
;IF SysValTemp >= 10 Then
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	10
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	call	SysCompLessThan16
	comf	SysByteTempX,F
	btfss	SysByteTempX,0
	goto	ENDIF60
SYSVALTENS
;SysStrData = SysValTemp / 10
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	10
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	call	SysDivSub16
	movf	SysWORDTempA,W
	movwf	SYSSTRDATA
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;SysCharCount += 1
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	clrf	SysTemp2
	movlw	high(STR)
	addwfc	SysTemp2,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSSTRDATA,W
	movwf	INDF0
;End If
ENDIF60
;Ones
;SysCharCount += 1
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysValTemp + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	clrf	SysTemp2
	movlw	high(STR)
	addwfc	SysTemp2,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSVALTEMP,W
	movwf	INDF0
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;Str(0) = SysCharCount
	movf	SYSCHARCOUNT,W
	banksel	SYSSTR_0
	movwf	SYSSTR_0
	banksel	STATUS
	return

;********************************************************************************

SYSCOMPEQUAL16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX
;Test low, exit if false
;movf SysWordTempA, W
	movf	SYSWORDTEMPA, W
;subwf SysWordTempB, W
	subwf	SYSWORDTEMPB, W
;btfss STATUS, Z
	btfss	STATUS, Z
;return
	return
;Test high, exit if false
;movf SysWordTempA_H, W
	movf	SYSWORDTEMPA_H, W
;subwf SysWordTempB_H, W
	subwf	SYSWORDTEMPB_H, W
;btfss STATUS, Z
	btfss	STATUS, Z
;return
	return
;comf SysByteTempX,F
	comf	SYSBYTETEMPX,F
	return

;********************************************************************************

SYSCOMPLESSTHAN
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX
;bsf STATUS, C
	bsf	STATUS, C
;movf SysByteTempB, W
	movf	SYSBYTETEMPB, W
;subwf SysByteTempA, W
	subwf	SYSBYTETEMPA, W
;btfss STATUS, C
	btfss	STATUS, C
;comf SysByteTempX,F
	comf	SYSBYTETEMPX,F
	return

;********************************************************************************

SYSCOMPLESSTHAN16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX
;Test High, exit if more
;movf SysWordTempA_H,W
	movf	SYSWORDTEMPA_H,W
;subwf SysWordTempB_H,W
	subwf	SYSWORDTEMPB_H,W
;btfss STATUS,C
	btfss	STATUS,C
;return
	return
;Test high, exit true if less
;movf SysWordTempB_H,W
	movf	SYSWORDTEMPB_H,W
;subwf SysWordTempA_H,W
	subwf	SYSWORDTEMPA_H,W
;btfss STATUS,C
	btfss	STATUS,C
;goto SCLT16True
	goto	SCLT16TRUE
;Test Low, exit if more or equal
;movf SysWordTempB,W
	movf	SYSWORDTEMPB,W
;subwf SysWordTempA,W
	subwf	SYSWORDTEMPA,W
;btfsc STATUS,C
	btfsc	STATUS,C
;return
	return
SCLT16TRUE
;comf SysByteTempX,F
	comf	SYSBYTETEMPX,F
	return

;********************************************************************************

SYSCOPYSTRING
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;Get and copy length
;movf INDF0, W
	movf	INDF0, W
;movwf SysCalcTempA
	movwf	SYSCALCTEMPA
;movwf INDF1
	movwf	INDF1
;goto SysCopyStringCheck
	goto	SYSCOPYSTRINGCHECK
;When appending, add length to counter
SYSCOPYSTRINGPART
;movf INDF0, W
	movf	INDF0, W
;movwf SysCalcTempA
	movwf	SYSCALCTEMPA
;addwf SysStringLength, F
	addwf	SYSSTRINGLENGTH, F
SYSCOPYSTRINGCHECK
;Exit if length = 0
;movf SysCalcTempA,F
	movf	SYSCALCTEMPA,F
;btfsc STATUS,Z
	btfsc	STATUS,Z
;return
	return
SYSSTRINGCOPY
;Increment pointers
;addfsr 0, 1
	addfsr	0, 1
;addfsr 1, 1
	addfsr	1, 1
;Copy character
;movf INDF0, W
	movf	INDF0, W
;movwf INDF1
	movwf	INDF1
;decfsz SysCalcTempA, F
	decfsz	SYSCALCTEMPA, F
;goto SysStringCopy
	goto	SYSSTRINGCOPY
	return

;********************************************************************************

SYSDIVSUB
;dim SysByteTempA as byte
;dim SysByteTempB as byte
;dim SysByteTempX as byte
;Check for div/0
;movf SysByteTempB, F
	movf	SYSBYTETEMPB, F
;btfsc STATUS, Z
	btfsc	STATUS, Z
;return
	return
;Main calc routine
;SysByteTempX = 0
	clrf	SYSBYTETEMPX
;SysDivLoop = 8
	movlw	8
	movwf	SYSDIVLOOP
SYSDIV8START
;bcf STATUS, C
	bcf	STATUS, C
;rlf SysByteTempA, F
	rlf	SYSBYTETEMPA, F
;rlf SysByteTempX, F
	rlf	SYSBYTETEMPX, F
;movf SysByteTempB, W
	movf	SYSBYTETEMPB, W
;subwf SysByteTempX, F
	subwf	SYSBYTETEMPX, F
;bsf SysByteTempA, 0
	bsf	SYSBYTETEMPA, 0
;btfsc STATUS, C
	btfsc	STATUS, C
;goto Div8NotNeg
	goto	DIV8NOTNEG
;bcf SysByteTempA, 0
	bcf	SYSBYTETEMPA, 0
;movf SysByteTempB, W
	movf	SYSBYTETEMPB, W
;addwf SysByteTempX, F
	addwf	SYSBYTETEMPX, F
DIV8NOTNEG
;decfsz SysDivLoop, F
	decfsz	SYSDIVLOOP, F
;goto SysDiv8Start
	goto	SYSDIV8START
	return

;********************************************************************************

SYSDIVSUB16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;dim SysDivMultA as word
;dim SysDivMultB as word
;dim SysDivMultX as word
;SysDivMultA = SysWordTempA
	movf	SYSWORDTEMPA,W
	movwf	SYSDIVMULTA
	movf	SYSWORDTEMPA_H,W
	movwf	SYSDIVMULTA_H
;SysDivMultB = SysWordTempB
	movf	SYSWORDTEMPB,W
	movwf	SYSDIVMULTB
	movf	SYSWORDTEMPB_H,W
	movwf	SYSDIVMULTB_H
;SysDivMultX = 0
	clrf	SYSDIVMULTX
	clrf	SYSDIVMULTX_H
;Avoid division by zero
;if SysDivMultB = 0 then
	movf	SYSDIVMULTB,W
	movwf	SysWORDTempA
	movf	SYSDIVMULTB_H,W
	movwf	SysWORDTempA_H
	clrf	SysWORDTempB
	clrf	SysWORDTempB_H
	call	SysCompEqual16
	btfss	SysByteTempX,0
	goto	ENDIF61
;SysWordTempA = 0
	clrf	SYSWORDTEMPA
	clrf	SYSWORDTEMPA_H
;exit sub
	return
;end if
ENDIF61
;Main calc routine
;SysDivLoop = 16
	movlw	16
	movwf	SYSDIVLOOP
SYSDIV16START
;set C off
	bcf	STATUS,C
;Rotate SysDivMultA Left
	rlf	SYSDIVMULTA,F
	rlf	SYSDIVMULTA_H,F
;Rotate SysDivMultX Left
	rlf	SYSDIVMULTX,F
	rlf	SYSDIVMULTX_H,F
;SysDivMultX = SysDivMultX - SysDivMultB
	movf	SYSDIVMULTB,W
	subwf	SYSDIVMULTX,F
	movf	SYSDIVMULTB_H,W
	subwfb	SYSDIVMULTX_H,F
;Set SysDivMultA.0 On
	bsf	SYSDIVMULTA,0
;If C Off Then
	btfsc	STATUS,C
	goto	ENDIF62
;Set SysDivMultA.0 Off
	bcf	SYSDIVMULTA,0
;SysDivMultX = SysDivMultX + SysDivMultB
	movf	SYSDIVMULTB,W
	addwf	SYSDIVMULTX,F
	movf	SYSDIVMULTB_H,W
	addwfc	SYSDIVMULTX_H,F
;End If
ENDIF62
;decfsz SysDivLoop, F
	decfsz	SYSDIVLOOP, F
;goto SysDiv16Start
	goto	SYSDIV16START
;SysWordTempA = SysDivMultA
	movf	SYSDIVMULTA,W
	movwf	SYSWORDTEMPA
	movf	SYSDIVMULTA_H,W
	movwf	SYSWORDTEMPA_H
;SysWordTempX = SysDivMultX
	movf	SYSDIVMULTX,W
	movwf	SYSWORDTEMPX
	movf	SYSDIVMULTX_H,W
	movwf	SYSWORDTEMPX_H
	return

;********************************************************************************

SYSMULTSUB
;dim SysByteTempA as byte
;dim SysByteTempB as byte
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX
MUL8LOOP
;movf SysByteTempA, W
	movf	SYSBYTETEMPA, W
;btfsc SysByteTempB, 0
	btfsc	SYSBYTETEMPB, 0
;addwf SysByteTempX, F
	addwf	SYSBYTETEMPX, F
;bcf STATUS, C
	bcf	STATUS, C
;rrf SysByteTempB, F
	rrf	SYSBYTETEMPB, F
;bcf STATUS, C
	bcf	STATUS, C
;rlf SysByteTempA, F
	rlf	SYSBYTETEMPA, F
;movf SysByteTempB, F
	movf	SYSBYTETEMPB, F
;btfss STATUS, Z
	btfss	STATUS, Z
;goto MUL8LOOP
	goto	MUL8LOOP
	return

;********************************************************************************

SYSREADSTRING
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;Get length
;call SysStringTables
	call	SYSSTRINGTABLES
;movwf SysCalcTempA
	movwf	SYSCALCTEMPA
;movwf INDF1
	movwf	INDF1
;goto SysStringReadCheck
	goto	SYSSTRINGREADCHECK
SYSREADSTRINGPART
;Get length
;call SysStringTables
	call	SYSSTRINGTABLES
;movwf SysCalcTempA
	movwf	SYSCALCTEMPA
;addwf SysStringLength,F
	addwf	SYSSTRINGLENGTH,F
;Check length
SYSSTRINGREADCHECK
;If length is 0, exit
;movf SysCalcTempA,F
	movf	SYSCALCTEMPA,F
;btfsc STATUS,Z
	btfsc	STATUS,Z
;return
	return
;Copy
SYSSTRINGREAD
;Get char
;call SysStringTables
	call	SYSSTRINGTABLES
;Set char
;addfsr 1,1
	addfsr	1,1
;movwf INDF1
	movwf	INDF1
;decfsz SysCalcTempA, F
	decfsz	SYSCALCTEMPA, F
;goto SysStringRead
	goto	SYSSTRINGREAD
	return

;********************************************************************************

SysStringTables
	movf	SysStringA_H,W
	movwf	PCLATH
	movf	SysStringA,W
	incf	SysStringA,F
	btfsc	STATUS,Z
	incf	SysStringA_H,F
	movwf	PCL

StringTable2
	retlw	7
	retlw	80	;P
	retlw	67	;C
	retlw	70	;F
	retlw	56	;8
	retlw	53	;5
	retlw	54	;6
	retlw	51	;3


StringTable3
	retlw	15
	retlw	71	;G
	retlw	114	;r
	retlw	101	;e
	retlw	97	;a
	retlw	116	;t
	retlw	32	; 
	retlw	67	;C
	retlw	111	;o
	retlw	119	;w
	retlw	32	; 
	retlw	66	;B
	retlw	97	;a
	retlw	115	;s
	retlw	105	;i
	retlw	99	;c


StringTable4
	retlw	1
	retlw	48	;0


StringTable5
	retlw	1
	retlw	58	;:


StringTable6
	retlw	6
	retlw	32	; 
	retlw	112	;p
	retlw	46	;.
	retlw	109	;m
	retlw	46	;.
	retlw	32	; 


StringTable7
	retlw	6
	retlw	32	; 
	retlw	97	;a
	retlw	46	;.
	retlw	109	;m
	retlw	46	;.
	retlw	32	; 


StringTable8
	retlw	5
	retlw	32	; 
	retlw	32	; 
	retlw	32	; 
	retlw	32	; 
	retlw	32	; 


StringTable9
	retlw	4
	retlw	83	;S
	retlw	117	;u
	retlw	110	;n
	retlw	46	;.


StringTable10
	retlw	4
	retlw	77	;M
	retlw	111	;o
	retlw	110	;n
	retlw	46	;.


StringTable11
	retlw	4
	retlw	84	;T
	retlw	117	;u
	retlw	101	;e
	retlw	46	;.


StringTable12
	retlw	4
	retlw	87	;W
	retlw	101	;e
	retlw	100	;d
	retlw	46	;.


StringTable13
	retlw	4
	retlw	84	;T
	retlw	104	;h
	retlw	117	;u
	retlw	46	;.


StringTable14
	retlw	4
	retlw	70	;F
	retlw	114	;r
	retlw	105	;i
	retlw	46	;.


StringTable15
	retlw	4
	retlw	83	;S
	retlw	97	;a
	retlw	116	;t
	retlw	46	;.


StringTable16
	retlw	1
	retlw	47	;/


StringTable17
	retlw	3
	retlw	47	;/
	retlw	50	;2
	retlw	48	;0


StringTable18
	retlw	1
	retlw	32	; 


;********************************************************************************

UPDATEDISP
;for best efficiency, date is only updated once a day
;PCF8563_ReadTime(hour, min, sec, am_pm)
	call	PCF8563_READTIME
	movf	DS_HOUR,W
	movwf	HOUR
	movf	DS_MIN,W
	movwf	MIN
	movf	DS_SEC,W
	movwf	SEC
	movf	DS_A_P,W
	movwf	AM_PM
;if oldsec <> sec then
	movf	SEC,W
	subwf	OLDSEC,W
	btfsc	STATUS, Z
	goto	ENDIF1
;if !(hour | min | sec) then       ;time to update
	movf	HOUR,W
	iorwf	MIN,W
	movwf	SysTemp1
	iorwf	SEC,W
	movwf	SysTemp2
	comf	SysTemp2,W
	movwf	SysTemp1
	btfss	SysTemp1,0
	goto	ENDIF2
;PCF8563_ReadDate(DOW, date, month, year)
	call	PCF8563_READDATE
	movf	DS_DOW,W
	movwf	DOW
	movf	DS_DATE,W
	movwf	DATE
	movf	DS_MONTH,W
	movwf	MONTH
	movf	DS_YEAR,W
	movwf	YEAR
;end if
ENDIF2
;locate 0,0                        ;home the cursor
	clrf	LCDLINE
	clrf	LCDCOLUMN
	call	LOCATE
;printTime                         ;show time
	call	PRINTTIME
;locate 1,0                        ;show the date
	movlw	1
	movwf	LCDLINE
	clrf	LCDCOLUMN
	call	LOCATE
;printDate
	call	PRINTDATE
;oldsec =  sec
	movf	SEC,W
	movwf	OLDSEC
;end if
ENDIF1
	return

;********************************************************************************

;Start of program memory page 1
	ORG	2048
;Start of program memory page 2
	ORG	4096
;Start of program memory page 3
	ORG	6144
;Start of program memory page 4
	ORG	8192
;Start of program memory page 5
	ORG	10240
;Start of program memory page 6
	ORG	12288
;Start of program memory page 7
	ORG	14336

 END
