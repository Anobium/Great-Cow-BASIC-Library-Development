;Program compiled by Great Cow BASIC (0.98.<<>> 2020-04-09 (Windows 32 bit))
;Need help? See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;check the documentation or email w_cholmondeley at users dot sourceforge dot net.

;********************************************************************************

;Set up the assembler options (Chip type, clock source, other bits and pieces)
 LIST p=16F18855, r=DEC
#include <P16F18855.inc>
 __CONFIG _CONFIG1, _CLKOUTEN_OFF & _RSTOSC_HFINT32 & _FEXTOSC_OFF
 __CONFIG _CONFIG2, _MCLRE_OFF
 __CONFIG _CONFIG3, _WDTE_OFF
 __CONFIG _CONFIG4, _LVP_OFF
 __CONFIG _CONFIG5, _CPD_OFF & _CP_OFF

;********************************************************************************

;Set aside memory locations for variables
CCOUNT	EQU	32
CHARCODE	EQU	33
CHARCOL	EQU	34
CHARCOLS	EQU	36
CHARCOL_H	EQU	35
CHARLOCX	EQU	37
CHARLOCX_H	EQU	38
CHARLOCY	EQU	39
CHARLOCY_H	EQU	40
CHARROW	EQU	41
CHARROWS	EQU	43
CHARROW_H	EQU	42
COL	EQU	44
CURRCHARCOL	EQU	45
CURRCHARROW	EQU	46
CURRCHARVAL	EQU	47
DELAYTEMP	EQU	112
DELAYTEMP2	EQU	113
FEATHERWINGREGISTER	EQU	48
FEATHERWINGREGISTER_E	EQU	51
FEATHERWINGREGISTER_H	EQU	49
FEATHERWINGREGISTER_U	EQU	50
GLCDBACKGROUND	EQU	52
GLCDBACKGROUND_H	EQU	53
GLCDCOLOUR	EQU	54
GLCDCOLOUR_H	EQU	55
GLCDDEVICEHEIGHT	EQU	56
GLCDDEVICEHEIGHT_H	EQU	57
GLCDDEVICEWIDTH	EQU	58
GLCDDEVICEWIDTH_H	EQU	59
GLCDFNTDEFAULT	EQU	60
GLCDFNTDEFAULTHEIGHT	EQU	61
GLCDFNTDEFAULTSIZE	EQU	62
GLCDFONTWIDTH	EQU	63
GLCDFOREGROUND	EQU	64
GLCDFOREGROUND_H	EQU	65
GLCDPRINTLEN	EQU	66
GLCDPRINTLOC	EQU	67
GLCDPRINTLOC_H	EQU	68
GLCDPRINT_STRING_COUNTER	EQU	69
GLCDROTATESTATE	EQU	70
GLCDX	EQU	71
GLCDY	EQU	72
GLCD_YORDINATE	EQU	73
GLCD_YORDINATE_H	EQU	74
HEX	EQU	9190
HI2CACKPOLLSTATE	EQU	75
HI2CCURRENTMODE	EQU	76
HI2CGETACK	EQU	77
HI2CWAITMSSPTIMEOUT	EQU	78
I2CBYTE	EQU	79
LINECOLOUR	EQU	80
LINECOLOUR_H	EQU	81
OLDFEATHERWINGREGISTER	EQU	82
OLDFEATHERWINGREGISTER_E	EQU	85
OLDFEATHERWINGREGISTER_H	EQU	83
OLDFEATHERWINGREGISTER_U	EQU	84
PRINTLOCX	EQU	86
PRINTLOCX_H	EQU	87
PRINTLOCY	EQU	88
PRINTLOCY_H	EQU	89
READMINITFT	EQU	90
READMINITFT_E	EQU	93
READMINITFT_H	EQU	91
READMINITFT_U	EQU	92
ROW	EQU	94
ST7735ADDRESSTYPE	EQU	95
ST7735END	EQU	96
ST7735END_H	EQU	97
ST7735SENDBYTE	EQU	98
ST7735SENDWORD	EQU	99
ST7735SENDWORD_H	EQU	100
ST7735START	EQU	101
ST7735START_H	EQU	102
STR	EQU	9194
STRINGPOINTER	EQU	103
SYSBYTETEMPA	EQU	117
SYSBYTETEMPB	EQU	121
SYSBYTETEMPX	EQU	112
SYSCALCTEMPX	EQU	112
SYSCALCTEMPX_H	EQU	113
SYSCHARCOUNT	EQU	104
SYSDIVLOOP	EQU	116
SYSDIVMULTA	EQU	119
SYSDIVMULTA_H	EQU	120
SYSDIVMULTB	EQU	123
SYSDIVMULTB_H	EQU	124
SYSDIVMULTX	EQU	114
SYSDIVMULTX_H	EQU	115
SYSLCDPRINTDATAHANDLER	EQU	105
SYSLCDPRINTDATAHANDLER_H	EQU	106
SYSREPEATTEMP1	EQU	107
SYSREPEATTEMP2	EQU	108
SYSREPEATTEMP3	EQU	109
SYSREPEATTEMP3_H	EQU	110
SYSREPEATTEMP4	EQU	111
SYSSTRDATA	EQU	160
SYSSTRINGA	EQU	119
SYSSTRINGA_H	EQU	120
SYSSTRINGTEMP	EQU	161
SYSTEMP1	EQU	162
SYSTEMP2	EQU	163
SYSTEMP2_H	EQU	164
SYSVALTEMP	EQU	165
SYSVALTEMP_H	EQU	166
SYSWAITTEMPMS	EQU	114
SYSWAITTEMPMS_H	EQU	115
SYSWAITTEMPS	EQU	116
SYSWAITTEMPUS	EQU	117
SYSWAITTEMPUS_H	EQU	118
SYSWORDTEMPA	EQU	117
SYSWORDTEMPA_H	EQU	118
SYSWORDTEMPB	EQU	121
SYSWORDTEMPB_H	EQU	122
SYSWORDTEMPX	EQU	112
SYSWORDTEMPX_H	EQU	113

;********************************************************************************

;Alias variables
AFSR0	EQU	4
AFSR0_H	EQU	5
SYSHEX_0	EQU	1606
SYSHEX_1	EQU	1607
SYSHEX_2	EQU	1608
SYSSTR_0	EQU	1610

;********************************************************************************

;Vectors
	ORG	0
	pagesel	BASPROGRAMSTART
	goto	BASPROGRAMSTART
	ORG	4
	retfie

;********************************************************************************

;Start of program memory page 0
	ORG	5
BASPROGRAMSTART
;Call initialisation routines
	call	INITSYS
	call	INITPPS
	call	HIC2INIT
	call	INITGLCD_ST7735
	call	INITGLCD_ST7735R
	pagesel	$

;Start of the main program
;Generated by PIC PPS Tool for Great Cow Basic
;PPS Tool version: 0.0.5.2
;PinManager data: 09/02/2017
;
;Template comment at the start of the config file
;
;----- Define Hardware settings for hwi2c
;Define I2C settings - CHANGE PORTS if required for your specific device.
;#DEFINE hi2c_BAUD_RATE 400
;#DEFINE hi2c_DATA PORTC.3
;#DEFINE hi2c_CLOCK PORTC.4
;Initialise I2C Master
;I2C pins need to be input for SSP2 module
;Dir hi2c_DATA In
	bsf	TRISC,3
;Dir hi2c_CLOCK In
	bsf	TRISC,4
;HI2CMode Master
	movlw	12
	movwf	HI2CCURRENTMODE
	call	HI2CMODE
;Pin mappings for ADAFruit_mini_colorTFT_joystick_featherwing - you cannot use hwspi.  Only use software SPI
;#define GLCD_DC         portC.2              'Data/Command select
;#define GLCD_CS         portB.2              'CS Chip select
;#define GLCD_RESET      portB.1              'RESET
;#define GLCD_DO         portB.5              'SPI SDO (MOSI)
;#define GLCD_DI         portB.4              'SPI SDI (MISO)  assume bi-directional DO/DI
;#define GLCD_SCK        portB.3              'SPI SCK
;GLCDRotate ( Landscape )
;
;GLCDPrint (4, 0, "Great", TFT_YELLOW )
;GLCDForeground = TFT_GREEN
;GLCDPrintString (" Cow")
;GLCDForeground = TFT_WHITE
;GLCDPrintString ( " BASIC 2020" )
;Circle  80,40, 10
;FilledCircle  80,40, 9, TFT_RED
;Wait 2 s
;GLCDCLS
;Set up some variables using in this program
;dim FeatherWingRegister, oldFeatherWingRegister as long
;oldFeatherWingRegister = 0xffff
	movlw	255
	movwf	OLDFEATHERWINGREGISTER
	movwf	OLDFEATHERWINGREGISTER_H
	clrf	OLDFEATHERWINGREGISTER_U
	clrf	OLDFEATHERWINGREGISTER_E
;dim ccount as byte
;ccount = 0
	clrf	CCOUNT
;box 0, 5, 158, 79
;GLCDPrint(4, 16, "Button A", TFT_RED )
	movlw	4
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	16
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	movlw	low StringTable1
	movwf	SysLCDPRINTDATAHandler
	movlw	(high StringTable1) | 128
	movwf	SysLCDPRINTDATAHandler_H
	clrf	LINECOLOUR
	movlw	248
	movwf	LINECOLOUR_H
	pagesel	GLCDPRINT6
	call	GLCDPRINT6
	pagesel	$
;GLCDPrint(4, 24, "Button B", TFT_RED )
	movlw	4
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	24
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	movlw	low StringTable2
	movwf	SysLCDPRINTDATAHandler
	movlw	(high StringTable2) | 128
	movwf	SysLCDPRINTDATAHandler_H
	clrf	LINECOLOUR
	movlw	248
	movwf	LINECOLOUR_H
	pagesel	GLCDPRINT6
	call	GLCDPRINT6
	pagesel	$
;GLCDPrint(4, 32, "Select", TFT_GREEN )
	movlw	4
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	32
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	movlw	low StringTable3
	movwf	SysLCDPRINTDATAHandler
	movlw	(high StringTable3) | 128
	movwf	SysLCDPRINTDATAHandler_H
	movlw	224
	movwf	LINECOLOUR
	movlw	7
	movwf	LINECOLOUR_H
	pagesel	GLCDPRINT6
	call	GLCDPRINT6
	pagesel	$
;GLCDPrint(4, 40, "Up  ", TFT_GREEN )
	movlw	4
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	40
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	movlw	low StringTable4
	movwf	SysLCDPRINTDATAHandler
	movlw	(high StringTable4) | 128
	movwf	SysLCDPRINTDATAHandler_H
	movlw	224
	movwf	LINECOLOUR
	movlw	7
	movwf	LINECOLOUR_H
	pagesel	GLCDPRINT6
	call	GLCDPRINT6
	pagesel	$
;GLCDPrint(4, 48, "Left  ", TFT_GREEN )
	movlw	4
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	48
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	movlw	low StringTable5
	movwf	SysLCDPRINTDATAHandler
	movlw	(high StringTable5) | 128
	movwf	SysLCDPRINTDATAHandler_H
	movlw	224
	movwf	LINECOLOUR
	movlw	7
	movwf	LINECOLOUR_H
	pagesel	GLCDPRINT6
	call	GLCDPRINT6
	pagesel	$
;GLCDPrint(4, 56, "Down", TFT_GREEN )
	movlw	4
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	56
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	movlw	low StringTable6
	movwf	SysLCDPRINTDATAHandler
	movlw	(high StringTable6) | 128
	movwf	SysLCDPRINTDATAHandler_H
	movlw	224
	movwf	LINECOLOUR
	movlw	7
	movwf	LINECOLOUR_H
	pagesel	GLCDPRINT6
	call	GLCDPRINT6
	pagesel	$
;GLCDPrint(4, 64, "Right  ", TFT_GREEN )
	movlw	4
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	64
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	movlw	low StringTable7
	movwf	SysLCDPRINTDATAHandler
	movlw	(high StringTable7) | 128
	movwf	SysLCDPRINTDATAHandler_H
	movlw	224
	movwf	LINECOLOUR
	movlw	7
	movwf	LINECOLOUR_H
	pagesel	GLCDPRINT6
	call	GLCDPRINT6
	pagesel	$
;filledbox 5,1,154,7, GLCDBackground
;GLCDPrint( 7, 1, "ADAFRUIT MINICOLORTFT", TFT_WHITE )
;GLCDPrint( 10, 9,  "JOYSTICK FEATHERWING", TFT_WHITE )
;DO
SysDoLoop_S1
;Read the ReadMiniTFT registers
;exposes the following states
;Minitft_Button_A, Minitft_Button_B, Minitft_Joy_Select, and Minitft_Joy_Up, Minitft_Joy_Down, Minitft_Joy_Left and Minitft_Joy_Right as 0 or 1 bits
;FeatherWingRegister = ReadMiniTFT()
	pagesel	FN_READMINITFT
	call	FN_READMINITFT
	pagesel	$
	movf	READMINITFT,W
	movwf	FEATHERWINGREGISTER
	movf	READMINITFT_H,W
	movwf	FEATHERWINGREGISTER_H
	movf	READMINITFT_U,W
	movwf	FEATHERWINGREGISTER_U
	movf	READMINITFT_E,W
	movwf	FEATHERWINGREGISTER_E
;if [word]FeatherWingRegister <>  [word]oldFeatherWingRegister then
	movf	FEATHERWINGREGISTER,W
	movwf	SysWORDTempA
	movf	FEATHERWINGREGISTER_H,W
	movwf	SysWORDTempA_H
	movf	OLDFEATHERWINGREGISTER,W
	movwf	SysWORDTempB
	movf	OLDFEATHERWINGREGISTER_H,W
	movwf	SysWORDTempB_H
	pagesel	SysCompEqual16
	call	SysCompEqual16
	pagesel	$
	comf	SysByteTempX,F
	btfss	SysByteTempX,0
	goto	ENDIF1
;Button A
;GLCDLocateString 66, 3
	movlw	66
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	3
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	pagesel	GLCDLOCATESTRING
	call	GLCDLOCATESTRING
	pagesel	$
;GLCDPrintString str(Minitft_Button_A)
	banksel	SYSVALTEMP
	clrf	SYSVALTEMP
	clrf	SYSVALTEMP_H
	banksel	READMINITFT_H
	btfss	READMINITFT_H,2
	goto	ENDIF2
	banksel	SYSVALTEMP
	incf	SYSVALTEMP,F
ENDIF2
	banksel	STATUS
	call	FN_STR
	movlw	low STR
	movwf	SysLCDPRINTDATAHandler
	movlw	high STR
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;Button B
;GLCDLocateString 66, 4
	movlw	66
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	4
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	pagesel	GLCDLOCATESTRING
	call	GLCDLOCATESTRING
	pagesel	$
;GLCDPrintString str(Minitft_Button_B)
	banksel	SYSVALTEMP
	clrf	SYSVALTEMP
	clrf	SYSVALTEMP_H
	banksel	READMINITFT_H
	btfss	READMINITFT_H,1
	goto	ENDIF3
	banksel	SYSVALTEMP
	incf	SYSVALTEMP,F
ENDIF3
	banksel	STATUS
	call	FN_STR
	movlw	low STR
	movwf	SysLCDPRINTDATAHandler
	movlw	high STR
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;Select
;GLCDLocateString 66, 5
	movlw	66
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	5
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	pagesel	GLCDLOCATESTRING
	call	GLCDLOCATESTRING
	pagesel	$
;GLCDPrintString str(Minitft_Joy_Select)
	banksel	SYSVALTEMP
	clrf	SYSVALTEMP
	clrf	SYSVALTEMP_H
	banksel	READMINITFT_H
	btfss	READMINITFT_H,3
	goto	ENDIF4
	banksel	SYSVALTEMP
	incf	SYSVALTEMP,F
ENDIF4
	banksel	STATUS
	call	FN_STR
	movlw	low STR
	movwf	SysLCDPRINTDATAHandler
	movlw	high STR
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;GLCDLocateString 66, 6
	movlw	66
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	6
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	pagesel	GLCDLOCATESTRING
	call	GLCDLOCATESTRING
;GLCDPrintString str(Minitft_Joy_Up)
	pagesel	FN_READMINITFT
	call	FN_READMINITFT
	pagesel	$
	banksel	SYSVALTEMP
	clrf	SYSVALTEMP
	clrf	SYSVALTEMP_H
	banksel	READMINITFT
	btfss	READMINITFT,2
	goto	ENDIF5
	banksel	SYSVALTEMP
	incf	SYSVALTEMP,F
ENDIF5
	banksel	STATUS
	call	FN_STR
	movlw	low STR
	movwf	SysLCDPRINTDATAHandler
	movlw	high STR
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;GLCDLocateString 66, 7
	movlw	66
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	7
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	pagesel	GLCDLOCATESTRING
	call	GLCDLOCATESTRING
;GLCDPrintString str(Minitft_Joy_Left)
	pagesel	FN_READMINITFT
	call	FN_READMINITFT
	pagesel	$
	banksel	SYSVALTEMP
	clrf	SYSVALTEMP
	clrf	SYSVALTEMP_H
	banksel	READMINITFT
	btfss	READMINITFT,3
	goto	ENDIF6
	banksel	SYSVALTEMP
	incf	SYSVALTEMP,F
ENDIF6
	banksel	STATUS
	call	FN_STR
	movlw	low STR
	movwf	SysLCDPRINTDATAHandler
	movlw	high STR
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;GLCDLocateString 66, 8
	movlw	66
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	8
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	pagesel	GLCDLOCATESTRING
	call	GLCDLOCATESTRING
;GLCDPrintString str(Minitft_Joy_Down)
	pagesel	FN_READMINITFT
	call	FN_READMINITFT
	pagesel	$
	banksel	SYSVALTEMP
	clrf	SYSVALTEMP
	clrf	SYSVALTEMP_H
	banksel	READMINITFT
	btfss	READMINITFT,4
	goto	ENDIF7
	banksel	SYSVALTEMP
	incf	SYSVALTEMP,F
ENDIF7
	banksel	STATUS
	call	FN_STR
	movlw	low STR
	movwf	SysLCDPRINTDATAHandler
	movlw	high STR
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;GLCDLocateString 66, 9
	movlw	66
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	9
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	pagesel	GLCDLOCATESTRING
	call	GLCDLOCATESTRING
;GLCDPrintString str(Minitft_Joy_Right)
	pagesel	FN_READMINITFT
	call	FN_READMINITFT
	pagesel	$
	banksel	SYSVALTEMP
	clrf	SYSVALTEMP
	clrf	SYSVALTEMP_H
	banksel	READMINITFT
	btfss	READMINITFT,7
	goto	ENDIF8
	banksel	SYSVALTEMP
	incf	SYSVALTEMP,F
ENDIF8
	banksel	STATUS
	call	FN_STR
	movlw	low STR
	movwf	SysLCDPRINTDATAHandler
	movlw	high STR
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;Optionally show the number of reads
;FilledBox 100,66, 130, 78, GLCDBackground
;GLCDPrint 100,66, ccount
;ccount++
;Optionally, show the register values
;GLCDPrint(100, 16, hex(FeatherWingRegister_E) )
	movlw	100
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	16
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	movf	FEATHERWINGREGISTER_E,W
	banksel	SYSVALTEMP
	movwf	SYSVALTEMP
	banksel	STATUS
	pagesel	FN_HEX
	call	FN_HEX
	pagesel	$
	movlw	low HEX
	movwf	SysLCDPRINTDATAHandler
	movlw	high HEX
	movwf	SysLCDPRINTDATAHandler_H
	call	GLCDPRINT5
;GLCDPrintString hex(FeatherWingRegister_U)
	movf	FEATHERWINGREGISTER_U,W
	banksel	SYSVALTEMP
	movwf	SYSVALTEMP
	banksel	STATUS
	pagesel	FN_HEX
	call	FN_HEX
	pagesel	$
	movlw	low HEX
	movwf	SysLCDPRINTDATAHandler
	movlw	high HEX
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;GLCDPrintString hex(FeatherWingRegister_h)
	movf	FEATHERWINGREGISTER_H,W
	banksel	SYSVALTEMP
	movwf	SYSVALTEMP
	banksel	STATUS
	pagesel	FN_HEX
	call	FN_HEX
	pagesel	$
	movlw	low HEX
	movwf	SysLCDPRINTDATAHandler
	movlw	high HEX
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;GLCDPrintString hex(FeatherWingRegister)
	movf	FEATHERWINGREGISTER,W
	banksel	SYSVALTEMP
	movwf	SYSVALTEMP
	banksel	STATUS
	pagesel	FN_HEX
	call	FN_HEX
	pagesel	$
	movlw	low HEX
	movwf	SysLCDPRINTDATAHandler
	movlw	high HEX
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;GLCDPrint(100, 25, hex(oldFeatherWingRegister_E) )
	movlw	100
	movwf	PRINTLOCX
	clrf	PRINTLOCX_H
	movlw	25
	movwf	PRINTLOCY
	clrf	PRINTLOCY_H
	movf	OLDFEATHERWINGREGISTER_E,W
	banksel	SYSVALTEMP
	movwf	SYSVALTEMP
	banksel	STATUS
	pagesel	FN_HEX
	call	FN_HEX
	pagesel	$
	movlw	low HEX
	movwf	SysLCDPRINTDATAHandler
	movlw	high HEX
	movwf	SysLCDPRINTDATAHandler_H
	call	GLCDPRINT5
;GLCDPrintString hex(oldFeatherWingRegister_U)
	movf	OLDFEATHERWINGREGISTER_U,W
	banksel	SYSVALTEMP
	movwf	SYSVALTEMP
	banksel	STATUS
	pagesel	FN_HEX
	call	FN_HEX
	pagesel	$
	movlw	low HEX
	movwf	SysLCDPRINTDATAHandler
	movlw	high HEX
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;GLCDPrintString hex(oldFeatherWingRegister_h)
	movf	OLDFEATHERWINGREGISTER_H,W
	banksel	SYSVALTEMP
	movwf	SYSVALTEMP
	banksel	STATUS
	pagesel	FN_HEX
	call	FN_HEX
	pagesel	$
	movlw	low HEX
	movwf	SysLCDPRINTDATAHandler
	movlw	high HEX
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;GLCDPrintString hex(oldFeatherWingRegister)
	movf	OLDFEATHERWINGREGISTER,W
	banksel	SYSVALTEMP
	movwf	SYSVALTEMP
	banksel	STATUS
	pagesel	FN_HEX
	call	FN_HEX
	pagesel	$
	movlw	low HEX
	movwf	SysLCDPRINTDATAHandler
	movlw	high HEX
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINTSTRING
	call	GLCDPRINTSTRING
	pagesel	$
;oldFeatherWingRegister = [word]FeatherWingRegister
	movf	FEATHERWINGREGISTER,W
	movwf	OLDFEATHERWINGREGISTER
	movf	FEATHERWINGREGISTER_H,W
	movwf	OLDFEATHERWINGREGISTER_H
	clrf	OLDFEATHERWINGREGISTER_U
	clrf	OLDFEATHERWINGREGISTER_E
;End if
ENDIF1
;LOOP
	goto	SysDoLoop_S1
SysDoLoop_E1
BASPROGRAMEND
	sleep
	goto	BASPROGRAMEND

;********************************************************************************

GLCDCHARCOL3
	movlw	113
	subwf	SysStringA, W
	btfsc	STATUS, C
	retlw	0
	movf	SysStringA, W
	addlw	low TableGLCDCHARCOL3
	movwf	SysStringA
	movlw	(high TableGLCDCHARCOL3) & 127
	btfsc	STATUS, C
	addlw	1
	movwf	PCLATH
	movf	SysStringA, W
	movwf	PCL
TableGLCDCHARCOL3
	retlw	112
	retlw	0
	retlw	16
	retlw	12
	retlw	10
	retlw	136
	retlw	34
	retlw	56
	retlw	32
	retlw	8
	retlw	32
	retlw	16
	retlw	16
	retlw	128
	retlw	128
	retlw	64
	retlw	4
	retlw	0
	retlw	0
	retlw	0
	retlw	40
	retlw	72
	retlw	70
	retlw	108
	retlw	0
	retlw	0
	retlw	0
	retlw	40
	retlw	16
	retlw	0
	retlw	16
	retlw	0
	retlw	64
	retlw	124
	retlw	0
	retlw	132
	retlw	130
	retlw	48
	retlw	78
	retlw	120
	retlw	6
	retlw	108
	retlw	12
	retlw	0
	retlw	0
	retlw	16
	retlw	40
	retlw	0
	retlw	4
	retlw	100
	retlw	248
	retlw	254
	retlw	124
	retlw	254
	retlw	254
	retlw	254
	retlw	124
	retlw	254
	retlw	0
	retlw	64
	retlw	254
	retlw	254
	retlw	254
	retlw	254
	retlw	124
	retlw	254
	retlw	124
	retlw	254
	retlw	76
	retlw	2
	retlw	126
	retlw	62
	retlw	126
	retlw	198
	retlw	14
	retlw	194
	retlw	0
	retlw	4
	retlw	0
	retlw	8
	retlw	128
	retlw	0
	retlw	64
	retlw	254
	retlw	112
	retlw	112
	retlw	112
	retlw	16
	retlw	16
	retlw	254
	retlw	0
	retlw	64
	retlw	254
	retlw	0
	retlw	248
	retlw	248
	retlw	112
	retlw	248
	retlw	16
	retlw	248
	retlw	144
	retlw	16
	retlw	120
	retlw	56
	retlw	120
	retlw	136
	retlw	24
	retlw	136
	retlw	0
	retlw	0
	retlw	0
	retlw	32
	retlw	120

;********************************************************************************

GLCDCHARCOL4
	movlw	113
	subwf	SysStringA, W
	btfsc	STATUS, C
	retlw	0
	movf	SysStringA, W
	addlw	low TableGLCDCHARCOL4
	movwf	SysStringA
	movlw	(high TableGLCDCHARCOL4) & 127
	btfsc	STATUS, C
	addlw	1
	movwf	PCLATH
	movf	SysStringA, W
	movwf	PCL
TableGLCDCHARCOL4
	retlw	112
	retlw	254
	retlw	56
	retlw	10
	retlw	6
	retlw	204
	retlw	102
	retlw	124
	retlw	112
	retlw	4
	retlw	64
	retlw	16
	retlw	56
	retlw	136
	retlw	162
	retlw	112
	retlw	28
	retlw	0
	retlw	0
	retlw	14
	retlw	254
	retlw	84
	retlw	38
	retlw	146
	retlw	10
	retlw	56
	retlw	130
	retlw	16
	retlw	16
	retlw	160
	retlw	16
	retlw	192
	retlw	32
	retlw	162
	retlw	132
	retlw	194
	retlw	130
	retlw	40
	retlw	138
	retlw	148
	retlw	2
	retlw	146
	retlw	146
	retlw	108
	retlw	172
	retlw	40
	retlw	40
	retlw	130
	retlw	2
	retlw	146
	retlw	36
	retlw	146
	retlw	130
	retlw	130
	retlw	146
	retlw	18
	retlw	130
	retlw	16
	retlw	130
	retlw	128
	retlw	16
	retlw	128
	retlw	4
	retlw	8
	retlw	130
	retlw	18
	retlw	130
	retlw	18
	retlw	146
	retlw	2
	retlw	128
	retlw	64
	retlw	128
	retlw	40
	retlw	16
	retlw	162
	retlw	254
	retlw	8
	retlw	130
	retlw	4
	retlw	128
	retlw	2
	retlw	168
	retlw	144
	retlw	136
	retlw	136
	retlw	168
	retlw	252
	retlw	168
	retlw	16
	retlw	144
	retlw	128
	retlw	32
	retlw	130
	retlw	8
	retlw	16
	retlw	136
	retlw	40
	retlw	40
	retlw	16
	retlw	168
	retlw	124
	retlw	128
	retlw	64
	retlw	128
	retlw	80
	retlw	160
	retlw	200
	retlw	16
	retlw	0
	retlw	130
	retlw	16
	retlw	68

;********************************************************************************

GLCDCHARCOL5
	movlw	113
	subwf	SysStringA, W
	btfsc	STATUS, C
	retlw	0
	movf	SysStringA, W
	addlw	low TableGLCDCHARCOL5
	movwf	SysStringA
	movlw	(high TableGLCDCHARCOL5) & 127
	btfsc	STATUS, C
	addlw	1
	movwf	PCLATH
	movf	SysStringA, W
	movwf	PCL
TableGLCDCHARCOL5
	retlw	112
	retlw	124
	retlw	124
	retlw	0
	retlw	0
	retlw	238
	retlw	238
	retlw	124
	retlw	168
	retlw	254
	retlw	254
	retlw	84
	retlw	84
	retlw	148
	retlw	148
	retlw	124
	retlw	124
	retlw	0
	retlw	158
	retlw	0
	retlw	40
	retlw	254
	retlw	16
	retlw	170
	retlw	6
	retlw	68
	retlw	68
	retlw	124
	retlw	124
	retlw	96
	retlw	16
	retlw	192
	retlw	16
	retlw	146
	retlw	254
	retlw	162
	retlw	138
	retlw	36
	retlw	138
	retlw	146
	retlw	226
	retlw	146
	retlw	146
	retlw	108
	retlw	108
	retlw	68
	retlw	40
	retlw	68
	retlw	162
	retlw	242
	retlw	34
	retlw	146
	retlw	130
	retlw	130
	retlw	146
	retlw	18
	retlw	146
	retlw	16
	retlw	254
	retlw	130
	retlw	40
	retlw	128
	retlw	24
	retlw	16
	retlw	130
	retlw	18
	retlw	162
	retlw	50
	retlw	146
	retlw	254
	retlw	128
	retlw	128
	retlw	112
	retlw	16
	retlw	224
	retlw	146
	retlw	130
	retlw	16
	retlw	130
	retlw	2
	retlw	128
	retlw	4
	retlw	168
	retlw	136
	retlw	136
	retlw	136
	retlw	168
	retlw	18
	retlw	168
	retlw	8
	retlw	250
	retlw	136
	retlw	80
	retlw	254
	retlw	240
	retlw	8
	retlw	136
	retlw	40
	retlw	40
	retlw	8
	retlw	168
	retlw	144
	retlw	128
	retlw	128
	retlw	96
	retlw	32
	retlw	160
	retlw	168
	retlw	108
	retlw	254
	retlw	108
	retlw	16
	retlw	66

;********************************************************************************

;Source: glcd_st7735.h (672)
GLCDDRAWCHAR_ST7735
;This has got a tad complex
;We have three major pieces
;1 The preamble - this just adjusted color and the input character
;2 The code that deals with GCB fontset
;3 The code that deals with OLED fontset
;
;You can make independent change to section 2 and 3 but they are mutual exclusive with many common pieces
;dim CharCol, CharRow, GLCDTemp as word
;CharCode -= 15
	movlw	15
	subwf	CHARCODE,F
;CharCol=0
	clrf	CHARCOL
	clrf	CHARCOL_H
;if CharCode>=178 and CharCode<=202 then
	movf	CHARCODE,W
	movwf	SysBYTETempA
	movlw	178
	movwf	SysBYTETempB
	pagesel	SysCompLessThan
	call	SysCompLessThan
	pagesel	$
	comf	SysByteTempX,F
	movf	SysByteTempX,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	banksel	CHARCODE
	movf	CHARCODE,W
	movwf	SysBYTETempB
	movlw	202
	movwf	SysBYTETempA
	pagesel	SysCompLessThan
	call	SysCompLessThan
	pagesel	$
	comf	SysByteTempX,F
	banksel	SYSTEMP1
	movf	SysTemp1,W
	andwf	SysByteTempX,W
	movwf	SysTemp2
	btfss	SysTemp2,0
	goto	ENDIF16
;CharLocY=CharLocY-1
	movlw	1
	banksel	CHARLOCY
	subwf	CHARLOCY,F
	movlw	0
	subwfb	CHARLOCY_H,F
;end if
ENDIF16
;For CurrCharCol = 1 to 5
	banksel	CURRCHARCOL
	clrf	CURRCHARCOL
SysForLoop3
	incf	CURRCHARCOL,F
;Select Case CurrCharCol
;Case 1: ReadTable GLCDCharCol3, CharCode, CurrCharVal
SysSelect1Case1
	decf	CURRCHARCOL,W
	btfss	STATUS, Z
	goto	SysSelect1Case2
	movf	CHARCODE,W
	movwf	SYSSTRINGA
	call	GLCDCHARCOL3
	movwf	CURRCHARVAL
;Case 2: ReadTable GLCDCharCol4, CharCode, CurrCharVal
	goto	SysSelectEnd1
SysSelect1Case2
	movlw	2
	subwf	CURRCHARCOL,W
	btfss	STATUS, Z
	goto	SysSelect1Case3
	movf	CHARCODE,W
	movwf	SYSSTRINGA
	call	GLCDCHARCOL4
	movwf	CURRCHARVAL
;Case 3: ReadTable GLCDCharCol5, CharCode, CurrCharVal
	goto	SysSelectEnd1
SysSelect1Case3
	movlw	3
	subwf	CURRCHARCOL,W
	btfss	STATUS, Z
	goto	SysSelect1Case4
	movf	CHARCODE,W
	movwf	SYSSTRINGA
	call	GLCDCHARCOL5
	movwf	CURRCHARVAL
;Case 4: ReadTable GLCDCharCol6, CharCode, CurrCharVal
	goto	SysSelectEnd1
SysSelect1Case4
	movlw	4
	subwf	CURRCHARCOL,W
	btfss	STATUS, Z
	goto	SysSelect1Case5
	movf	CHARCODE,W
	movwf	SYSSTRINGA
	pagesel	GLCDCHARCOL6
	call	GLCDCHARCOL6
	pagesel	$
	movwf	CURRCHARVAL
;Case 5: ReadTable GLCDCharCol7, CharCode, CurrCharVal
	goto	SysSelectEnd1
SysSelect1Case5
	movlw	5
	subwf	CURRCHARCOL,W
	btfss	STATUS, Z
	goto	SysSelectEnd1
	movf	CHARCODE,W
	movwf	SYSSTRINGA
	pagesel	GLCDCHARCOL7
	call	GLCDCHARCOL7
	pagesel	$
	movwf	CURRCHARVAL
;End Select
SysSelectEnd1
;CharRow=0
	clrf	CHARROW
	clrf	CHARROW_H
;For CurrCharRow = 1 to 8
	clrf	CURRCHARROW
SysForLoop4
	incf	CURRCHARROW,F
;CharColS=0
	clrf	CHARCOLS
;For Col=1 to GLCDfntDefaultsize
	clrf	COL
	movlw	1
	subwf	GLCDFNTDEFAULTSIZE,W
	btfss	STATUS, C
	goto	SysForLoopEnd5
SysForLoop5
	incf	COL,F
;CharColS +=1
	incf	CHARCOLS,F
;CharRowS=0
	clrf	CHARROWS
;For Row=1 to GLCDfntDefaultsize
	clrf	ROW
	movlw	1
	subwf	GLCDFNTDEFAULTSIZE,W
	btfss	STATUS, C
	goto	SysForLoopEnd6
SysForLoop6
	incf	ROW,F
;CharRowS +=1
	incf	CHARROWS,F
;if CurrCharVal.0=1 then
	btfss	CURRCHARVAL,0
	goto	ELSE19_1
;PSet [word]CharLocX + CharCol+ CharColS, [word]CharLocY + CharRow+CharRowS, LineColour
	movf	CHARCOL,W
	addwf	CHARLOCX,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	banksel	CHARCOLS
	movf	CHARCOLS,W
	banksel	SYSTEMP1
	addwf	SysTemp1,W
	banksel	GLCDX
	movwf	GLCDX
	movf	CHARROW,W
	addwf	CHARLOCY,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	banksel	CHARROWS
	movf	CHARROWS,W
	banksel	SYSTEMP1
	addwf	SysTemp1,W
	banksel	GLCDY
	movwf	GLCDY
	movf	LINECOLOUR,W
	movwf	GLCDCOLOUR
	movf	LINECOLOUR_H,W
	movwf	GLCDCOLOUR_H
	pagesel	PSET_ST7735R
	call	PSET_ST7735R
	pagesel	$
;Else
	goto	ENDIF19
ELSE19_1
;PSet [word]CharLocX + CharCol+ CharColS, [word]CharLocY + CharRow+CharRowS, GLCDBackground
	movf	CHARCOL,W
	addwf	CHARLOCX,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	banksel	CHARCOLS
	movf	CHARCOLS,W
	banksel	SYSTEMP1
	addwf	SysTemp1,W
	banksel	GLCDX
	movwf	GLCDX
	movf	CHARROW,W
	addwf	CHARLOCY,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	banksel	CHARROWS
	movf	CHARROWS,W
	banksel	SYSTEMP1
	addwf	SysTemp1,W
	banksel	GLCDY
	movwf	GLCDY
	movf	GLCDBACKGROUND,W
	movwf	GLCDCOLOUR
	movf	GLCDBACKGROUND_H,W
	movwf	GLCDCOLOUR_H
	pagesel	PSET_ST7735R
	call	PSET_ST7735R
	pagesel	$
;End if
ENDIF19
;Next Row
	movf	GLCDFNTDEFAULTSIZE,W
	subwf	ROW,W
	btfss	STATUS, C
	goto	SysForLoop6
SysForLoopEnd6
;Next Col
	movf	GLCDFNTDEFAULTSIZE,W
	subwf	COL,W
	btfss	STATUS, C
	goto	SysForLoop5
SysForLoopEnd5
;Rotate CurrCharVal Right
	rrf	CURRCHARVAL,F
;CharRow +=GLCDfntDefaultsize
	movf	GLCDFNTDEFAULTSIZE,W
	addwf	CHARROW,F
	movlw	0
	addwfc	CHARROW_H,F
;Next
	movlw	8
	subwf	CURRCHARROW,W
	btfss	STATUS, C
	goto	SysForLoop4
SysForLoopEnd4
;CharCol +=GLCDfntDefaultsize
	movf	GLCDFNTDEFAULTSIZE,W
	addwf	CHARCOL,F
	movlw	0
	addwfc	CHARCOL_H,F
;Next
	movlw	5
	subwf	CURRCHARCOL,W
	btfss	STATUS, C
	goto	SysForLoop3
SysForLoopEnd3
	return

;********************************************************************************

;Overloaded signature: WORD:WORD:STRING:, Source: glcd.h (932)
GLCDPRINT5
;GLCD.h Sub GLCDPrint
;Dim GLCDPrintLoc  as word
;Dim GLCDPrint_String_Counter, GLCDPrintLen as byte
;GLCDPrintLen = LCDPrintData(0)
	movf	SysLCDPRINTDATAHandler,W
	movwf	AFSR0
	movf	SysLCDPRINTDATAHandler_H,W
	movwf	AFSR0_H
	movf	INDF0,W
	movwf	GLCDPRINTLEN
;If GLCDPrintLen = 0 Then Exit Sub
	movf	GLCDPRINTLEN,F
	btfsc	STATUS, Z
	return
;GLCDPrintLoc = PrintLocX
	movf	PRINTLOCX,W
	movwf	GLCDPRINTLOC
	movf	PRINTLOCX_H,W
	movwf	GLCDPRINTLOC_H
;Write Data
;For GLCDPrint_String_Counter = 1 To GLCDPrintLen
	clrf	GLCDPRINT_STRING_COUNTER
	movlw	1
	subwf	GLCDPRINTLEN,W
	btfss	STATUS, C
	goto	SysForLoopEnd1
SysForLoop1
	incf	GLCDPRINT_STRING_COUNTER,F
;GLCDDrawChar  GLCDPrintLoc, PrintLocY, LCDPrintData(GLCDPrint_String_Counter)
	movf	GLCDPRINTLOC,W
	movwf	CHARLOCX
	movf	GLCDPRINTLOC_H,W
	movwf	CHARLOCX_H
	movf	PRINTLOCY,W
	movwf	CHARLOCY
	movf	PRINTLOCY_H,W
	movwf	CHARLOCY_H
	movf	GLCDPRINT_STRING_COUNTER,W
	addwf	SysLCDPRINTDATAHandler,W
	movwf	AFSR0
	movlw	0
	addwfc	SysLCDPRINTDATAHandler_H,W
	movwf	AFSR0_H
	movf	INDF0,W
	movwf	CHARCODE
	movf	GLCDFOREGROUND,W
	movwf	LINECOLOUR
	movf	GLCDFOREGROUND_H,W
	movwf	LINECOLOUR_H
	call	GLCDDRAWCHAR_ST7735
;GLCDPrintIncrementPixelPositionMacro
;Macro Source: glcd.h (1170)
;GLCDPrintLoc = GLCDPrintLoc + ( GLCDFontWidth * GLCDfntDefaultsize )+1
	movf	GLCDFONTWIDTH,W
	movwf	SysBYTETempA
	movf	GLCDFNTDEFAULTSIZE,W
	movwf	SysBYTETempB
	pagesel	SysMultSub
	call	SysMultSub
	pagesel	$
	movf	SysBYTETempX,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	banksel	GLCDPRINTLOC
	addwf	GLCDPRINTLOC,W
	banksel	SYSTEMP2
	movwf	SysTemp2
	movlw	0
	banksel	GLCDPRINTLOC_H
	addwfc	GLCDPRINTLOC_H,W
	banksel	SYSTEMP2_H
	movwf	SysTemp2_H
	movlw	1
	addwf	SysTemp2,W
	banksel	GLCDPRINTLOC
	movwf	GLCDPRINTLOC
	movlw	0
	banksel	SYSTEMP2_H
	addwfc	SysTemp2_H,W
	banksel	GLCDPRINTLOC_H
	movwf	GLCDPRINTLOC_H
;Next
	movf	GLCDPRINTLEN,W
	subwf	GLCDPRINT_STRING_COUNTER,W
	btfss	STATUS, C
	goto	SysForLoop1
SysForLoopEnd1
;Update the current X position for GLCDPrintString
;PrintLocX = GLCDPrintLoc
	movf	GLCDPRINTLOC,W
	movwf	PRINTLOCX
	movf	GLCDPRINTLOC_H,W
	movwf	PRINTLOCX_H
	return

;********************************************************************************

;Source: hwi2c.h (246)
HI2CMODE
;asm showdebug  This method sets the variable `HI2CCurrentMode`, and, if required, sets the SSPCON1.bits
;this method sets the variable `hi2ccurrentmode`, &, if required, sets the ssp1con1.bits
;#ifdef var(SSPCON1) added to separate from newer i2C module which does not have an SSPCON1
;set SSPSTAT.SMP on
	banksel	SSP1STAT
	bsf	SSP1STAT,SMP
;set SSPCON1.CKP on
	bsf	SSP1CON1,CKP
;set SSPCON1.WCOL Off
	bcf	SSP1CON1,WCOL
;Select mode and clock
;If HI2CCurrentMode = Master Then
	movlw	12
	banksel	HI2CCURRENTMODE
	subwf	HI2CCURRENTMODE,W
	btfss	STATUS, Z
	goto	ENDIF35
;set SSPCON1.SSPM3 on
	banksel	SSP1CON1
	bsf	SSP1CON1,SSPM3
;set SSPCON1.SSPM2 off
	bcf	SSP1CON1,SSPM2
;set SSPCON1.SSPM1 off
	bcf	SSP1CON1,SSPM1
;set SSPCON1.SSPM0 off
	bcf	SSP1CON1,SSPM0
;SSPADD = HI2C_BAUD_TEMP and 127
	movlw	19
	movwf	SSP1ADD
;end if
ENDIF35
;if HI2CCurrentMode = Slave then
	banksel	HI2CCURRENTMODE
	movf	HI2CCURRENTMODE,F
	btfss	STATUS, Z
	goto	ENDIF36
;set SSPCON1.SSPM3 off
	banksel	SSP1CON1
	bcf	SSP1CON1,SSPM3
;set SSPCON1.SSPM2 on
	bsf	SSP1CON1,SSPM2
;set SSPCON1.SSPM1 on
	bsf	SSP1CON1,SSPM1
;set SSPCON1.SSPM0 off
	bcf	SSP1CON1,SSPM0
;end if
ENDIF36
;if HI2CCurrentMode = Slave10 then
	movlw	3
	banksel	HI2CCURRENTMODE
	subwf	HI2CCURRENTMODE,W
	btfss	STATUS, Z
	goto	ENDIF37
;set SSPCON1.SSPM3 off
	banksel	SSP1CON1
	bcf	SSP1CON1,SSPM3
;set SSPCON1.SSPM2 on
	bsf	SSP1CON1,SSPM2
;set SSPCON1.SSPM1 on
	bsf	SSP1CON1,SSPM1
;set SSPCON1.SSPM0 on
	bsf	SSP1CON1,SSPM0
;end if
ENDIF37
;Enable I2C
;set SSPCON1.SSPEN on
	banksel	SSP1CON1
	bsf	SSP1CON1,SSPEN
	banksel	STATUS
	return

;********************************************************************************

;Source: hwi2c.h (695)
HIC2INIT
;asm showdebug  This method sets the variable `HI2CCurrentMode`, and, if required calls the method `SI2CInit` to set up new MSSP modules - aka K42s family chips
;this method sets the variable `hi2ccurrentmode`, &, if required calls the method `si2cinit` to set up new mssp modules - aka k42s family chips
;HI2CCurrentMode = 0
	clrf	HI2CCURRENTMODE
;Initialise the I2C module
	return

;********************************************************************************

;Source: glcd_st7735.h (238)
INITGLCD_ST7735
;This method is called when the about GLCD types are selected.
;Why? This is a shared library and therefore this INIT is called, but, this will be empty. Cannot avoid this.
	return

;********************************************************************************

;Source: glcd_st7735r.h (54)
INITGLCD_ST7735R
;Setup code for GLCD_TYPE_ST7735R  or GLCD_TYPE_ST7735R_160_80
;mapped to global variable
;dim GLCDDeviceWidth, GLCDDeviceHeight as byte
;dim GLCDForeground, GLCDBackground as word
;Pin directions
;Dir ST7735_CS Out
	bcf	TRISB,2
;Dir ST7735_DC Out
	bcf	TRISC,2
;Dir ST7735_RST Out
	bcf	TRISB,1
;Dir ST7735_DO Out
	bcf	TRISB,5
;Dir ST7735_SCK Out
	bcf	TRISB,3
;Reset display
;Set ST7735_RST On
	bsf	LATB,1
;Wait 150 ms
	movlw	150
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;Reset sequence (lower line for at least 10 us)
;Set ST7735_RST Off
	bcf	LATB,1
;Wait 150 us
	movlw	1
	movwf	DELAYTEMP2
DelayUSO1
	clrf	DELAYTEMP
DelayUS1
	decfsz	DELAYTEMP,F
	goto	DelayUS1
	decfsz	DELAYTEMP2,F
	goto	DelayUSO1
	movlw	142
	movwf	DELAYTEMP
DelayUS2
	decfsz	DELAYTEMP,F
	goto	DelayUS2
	nop
;Set ST7735_RST On
	bsf	LATB,1
;Wait 150 ms
	movlw	150
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;Software reset
;SendCommand_ST7735 ST7735_SWRESET
	movlw	1
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;Wait 150 ms
	movlw	150
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;Software reset
;SendCommand_ST7735 ST7735_SWRESET
	movlw	1
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;Wait 150 ms
	movlw	150
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;Out of sleep mode
;SendCommand_ST7735 ST7735_SLPOUT
	movlw	17
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;Wait 1 s
	movlw	1
	movwf	SysWaitTempS
	pagesel	Delay_S
	call	Delay_S
	pagesel	$
;asm showdebug _GLCD_TYPE_ST7735R_160_80
;_glcd_type_st7735r_160_80
;SendCommand_ST7735(ST7735_FRMCTR1)
	movlw	177
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x01)
	movlw	1
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2C)
	movlw	44
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2D)
	movlw	45
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;Wait 10 ms
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_FRMCTR2)
	movlw	178
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x01)
	movlw	1
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2C)
	movlw	44
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2D)
	movlw	45
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;Wait 10 ms
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_FRMCTR3)
	movlw	179
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x01)
	movlw	1
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2C)
	movlw	44
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2D)
	movlw	45
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x01)
	movlw	1
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2C)
	movlw	44
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2D)
	movlw	45
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;Wait 10 ms
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_INVCTR)
	movlw	180
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x07)
	movlw	7
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 10 ms;
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_PWCTR1)
	movlw	192
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0xA2)
	movlw	162
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x02)
	movlw	2
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x84)
	movlw	132
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 10 ms;
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_PWCTR2)
	movlw	193
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0xC5)
	movlw	197
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 10 ms;
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_PWCTR3)
	movlw	194
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x0A)
	movlw	10
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x00)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 10 ms;
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_PWCTR4)
	movlw	195
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x8A)
	movlw	138
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2A)
	movlw	42
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 10 ms;
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_PWCTR5)
	movlw	196
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x8A)
	movlw	138
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0xEE)
	movlw	238
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 10 ms;
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_VMCTR1)
	movlw	197
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x0E)
	movlw	14
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 10 ms;
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_INVOFF)
	movlw	32
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;wait 10 ms;
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_MADCTL)
	movlw	54
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0xC8)     'row address/col address, bottom to top refresh/GBR.
	movlw	200
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 20 ms
	movlw	20
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_COLMOD)
	movlw	58
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x05)
	movlw	5
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendCommand_ST7735(ST7735_CASET)
	movlw	42
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;GreenTab
;SendData_ST7735(0x00)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x00+ST7735_CASET_ADJUSTMENT)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x00)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(GLCD_WIDTH -1 +ST7735_CASET_ADJUSTMENT)
	movlw	79
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 20 ms
	movlw	20
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_RASET)
	movlw	43
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;GreenTab
;SendData_ST7735(0x00)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x00+ST7735_RASET_ADJUSTMENT)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x00)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(GLCD_HEIGHT -1 +ST7735_RASET_ADJUSTMENT)
	movlw	159
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 20 ms
	movlw	20
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_GMCTRP1)
	movlw	224
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x02)
	movlw	2
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x1c)
	movlw	28
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x07)
	movlw	7
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x12)
	movlw	18
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x37)
	movlw	55
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x32)
	movlw	50
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x29)
	movlw	41
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2d)
	movlw	45
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x29)
	movlw	41
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x25)
	movlw	37
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2b)
	movlw	43
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x39)
	movlw	57
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x00)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x01)
	movlw	1
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x03)
	movlw	3
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x10)
	movlw	16
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 10 ms
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;SendCommand_ST7735(ST7735_GMCTRN1)
	movlw	225
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;SendData_ST7735(0x03)
	movlw	3
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x1d)
	movlw	29
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x07)
	movlw	7
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x06)
	movlw	6
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2e)
	movlw	46
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2c)
	movlw	44
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x29)
	movlw	41
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2d)
	movlw	45
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2e)
	movlw	46
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x2e)
	movlw	46
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x37)
	movlw	55
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x37)
	movlw	55
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x00)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x00)
	clrf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x02)
	movlw	2
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;SendData_ST7735(0x10)
	movlw	16
	movwf	ST7735SENDBYTE
	pagesel	SENDDATA_ST7735
	call	SENDDATA_ST7735
	pagesel	$
;wait 10 ms
	movlw	10
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;Display on
;SendCommand_ST7735 ST7735_NORON
	movlw	19
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;Wait 100 ms
	movlw	100
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;Display on
;SendCommand_ST7735 ST7735_DISPON
	movlw	41
	movwf	ST7735SENDBYTE
	pagesel	SENDCOMMAND_ST7735
	call	SENDCOMMAND_ST7735
	pagesel	$
;Wait 100 ms
	movlw	100
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	pagesel	Delay_MS
	call	Delay_MS
	pagesel	$
;Colours
;GLCDForeground = TFT_WHITE
	movlw	255
	movwf	GLCDFOREGROUND
	movwf	GLCDFOREGROUND_H
;Default Colours
;GLCDBackground = TFT_BLACK
	clrf	GLCDBACKGROUND
	clrf	GLCDBACKGROUND_H
;Variables required for device
;GLCDDeviceWidth = GLCD_WIDTH - 1
	movlw	79
	movwf	GLCDDEVICEWIDTH
	clrf	GLCDDEVICEWIDTH_H
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	159
	movwf	GLCDDEVICEHEIGHT
	clrf	GLCDDEVICEHEIGHT_H
;GLCDFontWidth = 6
	movlw	6
	movwf	GLCDFONTWIDTH
;GLCDfntDefault = 0
	clrf	GLCDFNTDEFAULT
;GLCDfntDefaultsize = 1
	movlw	1
	movwf	GLCDFNTDEFAULTSIZE
;GLCDfntDefaultHeight = 8
	movlw	8
	movwf	GLCDFNTDEFAULTHEIGHT
;GLCDRotate ( Landscape )
	movlw	1
	movwf	GLCDROTATESTATE
	pagesel	GLCDROTATE_ST7735
	call	GLCDROTATE_ST7735
	pagesel	$
;Clear screen
;GLCDCLS
	pagesel	GLCDCLS_ST7735
	goto	GLCDCLS_ST7735

;********************************************************************************

;Source: FeatherLite002.gcb (12)
INITPPS
;Module: MSSP1
;RC3 > SDA1
;SSP1DATPPS = 0x0013
	movlw	19
	banksel	SSP1DATPPS
	movwf	SSP1DATPPS
;SDA1 > RC3 (bi-directional)
;RC3PPS = 0x0015
	movlw	21
	banksel	RC3PPS
	movwf	RC3PPS
;SCL1 > RC4
;RC4PPS = 0x0014
	movlw	20
	movwf	RC4PPS
;RC4 > SCL1 (bi-directional)
;SSP1CLKPPS = 0x0014
	movlw	20
	banksel	SSP1CLKPPS
	movwf	SSP1CLKPPS
	banksel	STATUS
	return

;********************************************************************************

;Source: system.h (111)
INITSYS
;asm showdebug This code block sets the internal oscillator to ChipMHz
;this code block sets the internal oscillator to 32
;asm showdebug Default settings for microcontrollers with _OSCCON1_
;default settings for microcontrollers with _osccon1_
;Default OSCCON1 typically, NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
;asm showdebug OSCCON type is default
;osccon type is default
;OSCCON1 = 0x60
	movlw	96
	banksel	OSCCON1
	movwf	OSCCON1
;Default value typically, CSWHOLD may proceed; SOSCPWR Low power
;OSCCON3 = 0x00
	clrf	OSCCON3
;Default value typically, MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
;OSCEN = 0x00
	clrf	OSCEN
;Default value
;OSCTUNE = 0x00
	clrf	OSCTUNE
;asm showdebug The MCU is a chip family ChipFamily
;the mcu is a chip family 15
;asm showdebug OSCCON type is 102
;osccon type is 102
;Set OSCFRQ values for MCUs with OSCSTAT... the 16F18855 MCU family
;OSCFRQ = 0b00000110
	movlw	6
	movwf	OSCFRQ
;asm showdebug _Complete_the_chip_setup_of_BSR,ADCs,ANSEL_and_other_key_setup_registers_or_register_bits
;_complete_the_chip_setup_of_bsr,adcs,ansel_and_other_key_setup_registers_or_register_bits
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	banksel	ADCON0
	bcf	ADCON0,ADFRM0
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	bcf	ADCON0,ADON
;Commence clearing any ANSELx variants in the part, if the ANSEL regsier/bit exists
;ANSELA = 0
	banksel	ANSELA
	clrf	ANSELA
;ANSELB = 0
	clrf	ANSELB
;ANSELC = 0
	clrf	ANSELC
;End  clearing ANSEL
;Set comparator register bits for many MCUs with register CM2CON0
;C2ON = 0
	banksel	CM2CON0
	bcf	CM2CON0,C2ON
;C1ON = 0
	bcf	CM1CON0,C1ON
;Turn off all ports
;PORTA = 0
	banksel	PORTA
	clrf	PORTA
;PORTB = 0
	clrf	PORTB
;PORTC = 0
	clrf	PORTC
;PORTE = 0
	clrf	PORTE
	return

;********************************************************************************

;Source: string.h (75)
FN_STR
;SysCharCount = 0
	clrf	SYSCHARCOUNT
;Dim SysCalcTempX As Word
;Ten Thousands
;IF SysValTemp >= 10000 then
	banksel	SYSVALTEMP
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	16
	movwf	SysWORDTempB
	movlw	39
	movwf	SysWORDTempB_H
	banksel	STATUS
	pagesel	SysCompLessThan16
	call	SysCompLessThan16
	pagesel	$
	comf	SysByteTempX,F
	btfss	SysByteTempX,0
	goto	ENDIF28
;SysStrData = SysValTemp / 10000
	banksel	SYSVALTEMP
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	16
	movwf	SysWORDTempB
	movlw	39
	movwf	SysWORDTempB_H
	banksel	STATUS
	pagesel	SysDivSub16
	call	SysDivSub16
	pagesel	$
	movf	SysWORDTempA,W
	banksel	SYSSTRDATA
	movwf	SYSSTRDATA
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;SysCharCount += 1
	banksel	SYSCHARCOUNT
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	movlw	0
	banksel	SYSTEMP1
	movwf	SysTemp1
	movlw	high(STR)
	addwfc	SysTemp1,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSSTRDATA,W
	movwf	INDF0
;Goto SysValThousands
	goto	SYSVALTHOUSANDS
;End If
ENDIF28
;Thousands
;IF SysValTemp >= 1000 then
	banksel	SYSVALTEMP
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	232
	movwf	SysWORDTempB
	movlw	3
	movwf	SysWORDTempB_H
	banksel	STATUS
	pagesel	SysCompLessThan16
	call	SysCompLessThan16
	pagesel	$
	comf	SysByteTempX,F
	btfss	SysByteTempX,0
	goto	ENDIF29
SYSVALTHOUSANDS
;SysStrData = SysValTemp / 1000
	banksel	SYSVALTEMP
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	232
	movwf	SysWORDTempB
	movlw	3
	movwf	SysWORDTempB_H
	banksel	STATUS
	pagesel	SysDivSub16
	call	SysDivSub16
	pagesel	$
	movf	SysWORDTempA,W
	banksel	SYSSTRDATA
	movwf	SYSSTRDATA
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;SysCharCount += 1
	banksel	SYSCHARCOUNT
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	movlw	0
	banksel	SYSTEMP1
	movwf	SysTemp1
	movlw	high(STR)
	addwfc	SysTemp1,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSSTRDATA,W
	movwf	INDF0
;Goto SysValHundreds
	goto	SYSVALHUNDREDS
;End If
ENDIF29
;Hundreds
;IF SysValTemp >= 100 then
	banksel	SYSVALTEMP
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	100
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	banksel	STATUS
	pagesel	SysCompLessThan16
	call	SysCompLessThan16
	pagesel	$
	comf	SysByteTempX,F
	btfss	SysByteTempX,0
	goto	ENDIF30
SYSVALHUNDREDS
;SysStrData = SysValTemp / 100
	banksel	SYSVALTEMP
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	100
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	banksel	STATUS
	pagesel	SysDivSub16
	call	SysDivSub16
	pagesel	$
	movf	SysWORDTempA,W
	banksel	SYSSTRDATA
	movwf	SYSSTRDATA
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;SysCharCount += 1
	banksel	SYSCHARCOUNT
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	movlw	0
	banksel	SYSTEMP1
	movwf	SysTemp1
	movlw	high(STR)
	addwfc	SysTemp1,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSSTRDATA,W
	movwf	INDF0
;Goto SysValTens
	goto	SYSVALTENS
;End If
ENDIF30
;Tens
;IF SysValTemp >= 10 Then
	banksel	SYSVALTEMP
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	10
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	banksel	STATUS
	pagesel	SysCompLessThan16
	call	SysCompLessThan16
	pagesel	$
	comf	SysByteTempX,F
	btfss	SysByteTempX,0
	goto	ENDIF31
SYSVALTENS
;SysStrData = SysValTemp / 10
	banksel	SYSVALTEMP
	movf	SYSVALTEMP,W
	movwf	SysWORDTempA
	movf	SYSVALTEMP_H,W
	movwf	SysWORDTempA_H
	movlw	10
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	banksel	STATUS
	pagesel	SysDivSub16
	call	SysDivSub16
	pagesel	$
	movf	SysWORDTempA,W
	banksel	SYSSTRDATA
	movwf	SYSSTRDATA
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;SysCharCount += 1
	banksel	SYSCHARCOUNT
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysStrData + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	movlw	0
	banksel	SYSTEMP1
	movwf	SysTemp1
	movlw	high(STR)
	addwfc	SysTemp1,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSSTRDATA,W
	movwf	INDF0
;End If
ENDIF31
;Ones
;SysCharCount += 1
	banksel	SYSCHARCOUNT
	incf	SYSCHARCOUNT,F
;Str(SysCharCount) = SysValTemp + 48
	movlw	low(STR)
	addwf	SYSCHARCOUNT,W
	movwf	AFSR0
	movlw	0
	banksel	SYSTEMP1
	movwf	SysTemp1
	movlw	high(STR)
	addwfc	SysTemp1,W
	movwf	AFSR0_H
	movlw	48
	addwf	SYSVALTEMP,W
	movwf	INDF0
;SysValTemp = SysCalcTempX
	movf	SYSCALCTEMPX,W
	movwf	SYSVALTEMP
	movf	SYSCALCTEMPX_H,W
	movwf	SYSVALTEMP_H
;Str(0) = SysCharCount
	banksel	SYSCHARCOUNT
	movf	SYSCHARCOUNT,W
	banksel	SYSSTR_0
	movwf	SYSSTR_0
	banksel	STATUS
	return

;********************************************************************************

;Start of program memory page 1
	ORG	2048
Delay_MS
	incf	SysWaitTempMS_H, F
DMS_START
	movlw	14
	movwf	DELAYTEMP2
DMS_OUTER
	movlw	189
	movwf	DELAYTEMP
DMS_INNER
	decfsz	DELAYTEMP, F
	goto	DMS_INNER
	decfsz	DELAYTEMP2, F
	goto	DMS_OUTER
	decfsz	SysWaitTempMS, F
	goto	DMS_START
	decfsz	SysWaitTempMS_H, F
	goto	DMS_START
	return

;********************************************************************************

Delay_S
DS_START
	movlw	232
	movwf	SysWaitTempMS
	movlw	3
	movwf	SysWaitTempMS_H
	call	Delay_MS
	decfsz	SysWaitTempS, F
	goto	DS_START
	return

;********************************************************************************

GLCDCHARCOL6
	movlw	113
	subwf	SysStringA, W
	btfsc	STATUS, C
	retlw	0
	movf	SysStringA, W
	addlw	low TableGLCDCHARCOL6
	movwf	SysStringA
	movlw	(high TableGLCDCHARCOL6) & 127
	btfsc	STATUS, C
	addlw	1
	movwf	PCLATH
	movf	SysStringA, W
	movwf	PCL
TableGLCDCHARCOL6
	retlw	112
	retlw	56
	retlw	254
	retlw	12
	retlw	10
	retlw	204
	retlw	102
	retlw	124
	retlw	32
	retlw	4
	retlw	64
	retlw	56
	retlw	16
	retlw	162
	retlw	136
	retlw	112
	retlw	28
	retlw	0
	retlw	0
	retlw	14
	retlw	254
	retlw	84
	retlw	200
	retlw	68
	retlw	0
	retlw	130
	retlw	56
	retlw	16
	retlw	16
	retlw	0
	retlw	16
	retlw	0
	retlw	8
	retlw	138
	retlw	128
	retlw	146
	retlw	150
	retlw	254
	retlw	138
	retlw	146
	retlw	18
	retlw	146
	retlw	82
	retlw	0
	retlw	0
	retlw	130
	retlw	40
	retlw	40
	retlw	18
	retlw	130
	retlw	36
	retlw	146
	retlw	130
	retlw	68
	retlw	146
	retlw	18
	retlw	146
	retlw	16
	retlw	130
	retlw	126
	retlw	68
	retlw	128
	retlw	4
	retlw	32
	retlw	130
	retlw	18
	retlw	66
	retlw	82
	retlw	146
	retlw	2
	retlw	128
	retlw	64
	retlw	128
	retlw	40
	retlw	16
	retlw	138
	retlw	130
	retlw	32
	retlw	254
	retlw	4
	retlw	128
	retlw	8
	retlw	168
	retlw	136
	retlw	136
	retlw	144
	retlw	168
	retlw	2
	retlw	168
	retlw	8
	retlw	128
	retlw	122
	retlw	136
	retlw	128
	retlw	8
	retlw	8
	retlw	136
	retlw	40
	retlw	48
	retlw	8
	retlw	168
	retlw	128
	retlw	64
	retlw	64
	retlw	128
	retlw	80
	retlw	160
	retlw	152
	retlw	130
	retlw	0
	retlw	16
	retlw	32
	retlw	68

;********************************************************************************

GLCDCHARCOL7
	movlw	113
	subwf	SysStringA, W
	btfsc	STATUS, C
	retlw	0
	movf	SysStringA, W
	addlw	low TableGLCDCHARCOL7
	movwf	SysStringA
	movlw	(high TableGLCDCHARCOL7) & 127
	btfsc	STATUS, C
	addlw	1
	movwf	PCLATH
	movf	SysStringA, W
	movwf	PCL
TableGLCDCHARCOL7
	retlw	112
	retlw	16
	retlw	0
	retlw	10
	retlw	6
	retlw	136
	retlw	34
	retlw	56
	retlw	62
	retlw	8
	retlw	32
	retlw	16
	retlw	16
	retlw	128
	retlw	128
	retlw	64
	retlw	4
	retlw	0
	retlw	0
	retlw	0
	retlw	40
	retlw	36
	retlw	196
	retlw	160
	retlw	0
	retlw	0
	retlw	0
	retlw	40
	retlw	16
	retlw	0
	retlw	16
	retlw	0
	retlw	4
	retlw	124
	retlw	0
	retlw	140
	retlw	98
	retlw	32
	retlw	114
	retlw	96
	retlw	14
	retlw	108
	retlw	60
	retlw	0
	retlw	0
	retlw	0
	retlw	40
	retlw	16
	retlw	12
	retlw	124
	retlw	248
	retlw	108
	retlw	68
	retlw	56
	retlw	130
	retlw	2
	retlw	244
	retlw	254
	retlw	0
	retlw	2
	retlw	130
	retlw	128
	retlw	254
	retlw	254
	retlw	124
	retlw	12
	retlw	188
	retlw	140
	retlw	100
	retlw	2
	retlw	126
	retlw	62
	retlw	126
	retlw	198
	retlw	14
	retlw	134
	retlw	0
	retlw	64
	retlw	0
	retlw	8
	retlw	128
	retlw	0
	retlw	240
	retlw	112
	retlw	64
	retlw	254
	retlw	48
	retlw	4
	retlw	120
	retlw	240
	retlw	0
	retlw	0
	retlw	0
	retlw	0
	retlw	240
	retlw	240
	retlw	112
	retlw	16
	retlw	248
	retlw	16
	retlw	64
	retlw	64
	retlw	248
	retlw	56
	retlw	120
	retlw	136
	retlw	120
	retlw	136
	retlw	0
	retlw	0
	retlw	0
	retlw	16
	retlw	120

;********************************************************************************

;Source: glcd_st7735.h (602)
GLCDCLS_ST7735
;initialise global variable. Required variable for Circle in all DEVICE DRIVERS- DO NOT DELETE
;GLCD_yordinate = 0
	clrf	GLCD_YORDINATE
	clrf	GLCD_YORDINATE_H
;Dim PrintLocX, PrintLocY as word
;PrintLocX = 0
	clrf	PRINTLOCX
	clrf	PRINTLOCX_H
;PrintLocY = 0
	clrf	PRINTLOCY
	clrf	PRINTLOCY_H
;SetAddress_ST7735 ST7735_COLUMN, 0, GLCDDeviceWidth
	movlw	42
	movwf	ST7735ADDRESSTYPE
	clrf	ST7735START
	clrf	ST7735START_H
	movf	GLCDDEVICEWIDTH,W
	movwf	ST7735END
	movf	GLCDDEVICEWIDTH_H,W
	movwf	ST7735END_H
	call	SETADDRESS_ST7735
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;SetAddress_ST7735 ST7735_ROW, 0, GLCDDeviceHeight
	movlw	43
	movwf	ST7735ADDRESSTYPE
	clrf	ST7735START
	clrf	ST7735START_H
	movf	GLCDDEVICEHEIGHT,W
	movwf	ST7735END
	movf	GLCDDEVICEHEIGHT_H,W
	movwf	ST7735END_H
	call	SETADDRESS_ST7735
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;SendCommand_ST7735 ST7735_RAMWR
	movlw	44
	movwf	ST7735SENDBYTE
	call	SENDCOMMAND_ST7735
;wait 2 ms
	movlw	2
	movwf	SysWaitTempMS
	clrf	SysWaitTempMS_H
	call	Delay_MS
;Repeat [word] GLCD_WIDTH * GLCD_HEIGHT
	clrf	SYSREPEATTEMP3
	movlw	50
	movwf	SYSREPEATTEMP3_H
	movf	SYSREPEATTEMP3,W
	movwf	SysWORDTempA
	movf	SYSREPEATTEMP3_H,W
	movwf	SysWORDTempA_H
	movlw	1
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0
	goto	SysRepeatLoopEnd3
	movf	SYSREPEATTEMP3,F
	btfss	STATUS, Z
	incf	SysRepeatTemp3_H,F
SysRepeatLoop3
;SendWord_ST7735 GLCDBackground
	movf	GLCDBACKGROUND,W
	movwf	ST7735SENDWORD
	movf	GLCDBACKGROUND_H,W
	movwf	ST7735SENDWORD_H
	call	SENDWORD_ST7735
;End Repeat
	decfsz	SysRepeatTemp3,F
	goto	SysRepeatLoop3
	decfsz	SysRepeatTemp3_H,F
	goto	SysRepeatLoop3
SysRepeatLoopEnd3
	return

;********************************************************************************

;Source: glcd.h (1211)
GLCDLOCATESTRING
;dim PrintLocY as word
;if PrintLocY < 2 then
	movf	PRINTLOCY,W
	movwf	SysWORDTempA
	movf	PRINTLOCY_H,W
	movwf	SysWORDTempA_H
	movlw	2
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	call	SysCompLessThan16
	btfss	SysByteTempX,0
	goto	ELSE15_1
;PrintLocY = 0
	clrf	PRINTLOCY
	clrf	PRINTLOCY_H
;else
	goto	ENDIF15
ELSE15_1
;PrintLocY--
	movlw	1
	subwf	PRINTLOCY,F
	movlw	0
	subwfb	PRINTLOCY_H,F
;PrintLocY = ( PrintLocY * ( GLCDfntDefaultHeight * GLCDfntDefaultSize ) ) mod GLCD_HEIGHT
	movf	GLCDFNTDEFAULTHEIGHT,W
	movwf	SysBYTETempA
	movf	GLCDFNTDEFAULTSIZE,W
	movwf	SysBYTETempB
	call	SysMultSub
	movf	SysBYTETempX,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	banksel	PRINTLOCY
	movf	PRINTLOCY,W
	movwf	SysWORDTempA
	movf	PRINTLOCY_H,W
	movwf	SysWORDTempA_H
	banksel	SYSTEMP1
	movf	SysTemp1,W
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	banksel	STATUS
	call	SysMultSub16
	movf	SysWORDTempX,W
	banksel	SYSTEMP2
	movwf	SysTemp2
	movf	SysWORDTempX_H,W
	movwf	SysTemp2_H
	movf	SysTemp2,W
	movwf	SysWORDTempA
	movf	SysTemp2_H,W
	movwf	SysWORDTempA_H
	movlw	160
	movwf	SysWORDTempB
	clrf	SysWORDTempB_H
	banksel	STATUS
	call	SysDivSub16
	movf	SysWORDTempX,W
	movwf	PRINTLOCY
	movf	SysWORDTempX_H,W
	movwf	PRINTLOCY_H
;end if
ENDIF15
	return

;********************************************************************************

;Overloaded signature: WORD:WORD:STRING:WORD:, Source: glcd.h (961)
GLCDPRINT6
;Dim GLCDPrintLoc as word
;GLCDPrintLen = LCDPrintData(0)
	movf	SysLCDPRINTDATAHandler,W
	movwf	AFSR0
	movf	SysLCDPRINTDATAHandler_H,W
	movwf	AFSR0_H
	movf	INDF0,W
	movwf	GLCDPRINTLEN
;If GLCDPrintLen = 0 Then Exit Sub
	movf	GLCDPRINTLEN,F
	btfsc	STATUS, Z
	return
;GLCDPrintLoc = PrintLocX
	movf	PRINTLOCX,W
	movwf	GLCDPRINTLOC
	movf	PRINTLOCX_H,W
	movwf	GLCDPRINTLOC_H
;Write Data
;For GLCDPrint_String_Counter = 1 To GLCDPrintLen
	clrf	GLCDPRINT_STRING_COUNTER
	movlw	1
	subwf	GLCDPRINTLEN,W
	btfss	STATUS, C
	goto	SysForLoopEnd2
SysForLoop2
	incf	GLCDPRINT_STRING_COUNTER,F
;GLCDDrawChar GLCDPrintLoc, PrintLocY, LCDPrintData(GLCDPrint_String_Counter), LineColour
	movf	GLCDPRINTLOC,W
	movwf	CHARLOCX
	movf	GLCDPRINTLOC_H,W
	movwf	CHARLOCX_H
	movf	PRINTLOCY,W
	movwf	CHARLOCY
	movf	PRINTLOCY_H,W
	movwf	CHARLOCY_H
	movf	GLCDPRINT_STRING_COUNTER,W
	addwf	SysLCDPRINTDATAHandler,W
	movwf	AFSR0
	movlw	0
	addwfc	SysLCDPRINTDATAHandler_H,W
	movwf	AFSR0_H
	movf	INDF0,W
	movwf	CHARCODE
	pagesel	GLCDDRAWCHAR_ST7735
	call	GLCDDRAWCHAR_ST7735
	pagesel	$
;GLCDPrintIncrementPixelPositionMacro
;Macro Source: glcd.h (1170)
;GLCDPrintLoc = GLCDPrintLoc + ( GLCDFontWidth * GLCDfntDefaultsize )+1
	movf	GLCDFONTWIDTH,W
	movwf	SysBYTETempA
	movf	GLCDFNTDEFAULTSIZE,W
	movwf	SysBYTETempB
	call	SysMultSub
	movf	SysBYTETempX,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	banksel	GLCDPRINTLOC
	addwf	GLCDPRINTLOC,W
	banksel	SYSTEMP2
	movwf	SysTemp2
	movlw	0
	banksel	GLCDPRINTLOC_H
	addwfc	GLCDPRINTLOC_H,W
	banksel	SYSTEMP2_H
	movwf	SysTemp2_H
	movlw	1
	addwf	SysTemp2,W
	banksel	GLCDPRINTLOC
	movwf	GLCDPRINTLOC
	movlw	0
	banksel	SYSTEMP2_H
	addwfc	SysTemp2_H,W
	banksel	GLCDPRINTLOC_H
	movwf	GLCDPRINTLOC_H
;Next
	movf	GLCDPRINTLEN,W
	subwf	GLCDPRINT_STRING_COUNTER,W
	btfss	STATUS, C
	goto	SysForLoop2
SysForLoopEnd2
;Update the current X position for GLCDPrintString
;PrintLocX = GLCDPrintLoc
	movf	GLCDPRINTLOC,W
	movwf	PRINTLOCX
	movf	GLCDPRINTLOC_H,W
	movwf	PRINTLOCX_H
	return

;********************************************************************************

;Source: glcd.h (1183)
GLCDPRINTSTRING
;dim PrintLocX as word
;Print at the current X and Y post
;GLCDPrint( PrintLocX , PrintLocY , LCDPrintData )
	movf	SysLCDPRINTDATAHandler,W
	movwf	SysLCDPRINTDATAHandler
	movf	SysLCDPRINTDATAHandler_H,W
	movwf	SysLCDPRINTDATAHandler_H
	pagesel	GLCDPRINT5
	goto	GLCDPRINT5

;********************************************************************************

;Source: glcd_st7735.h (1060)
GLCDROTATE_ST7735
;SendCommand_ST7735 ( ST7735_MADCTL )
	movlw	54
	movwf	ST7735SENDBYTE
	call	SENDCOMMAND_ST7735
;select case GLCDRotateState
;case LANDSCAPE
SysSelect2Case1
	decf	GLCDROTATESTATE,W
	btfss	STATUS, Z
	goto	SysSelect2Case2
;IF ST7735TABCOLOR = ST7735_BLACKTAB or ST7735TABCOLOR = ST7735_MINI160x80 or GLCD_TYPE = GLCD_TYPE_ST7735R_160_80 then
;SendData_ST7735( ST7735_MADCTL_MX | ST7735_MADCTL_MV |  ST7735_MADCTL_RGB )
	movlw	96
	movwf	ST7735SENDBYTE
	call	SENDDATA_ST7735
;else
;GLCDDeviceWidth = GLCD_HEIGHT - 1
	movlw	159
	movwf	GLCDDEVICEWIDTH
	clrf	GLCDDEVICEWIDTH_H
;GLCDDeviceHeight = GLCD_WIDTH - 1
	movlw	79
	movwf	GLCDDEVICEHEIGHT
	clrf	GLCDDEVICEHEIGHT_H
;case PORTRAIT_REV
	goto	SysSelectEnd2
SysSelect2Case2
	movlw	2
	subwf	GLCDROTATESTATE,W
	btfss	STATUS, Z
	goto	SysSelect2Case3
;GLCDDeviceWidth = GLCD_WIDTH - 1
	movlw	79
	movwf	GLCDDEVICEWIDTH
	clrf	GLCDDEVICEWIDTH_H
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	159
	movwf	GLCDDEVICEHEIGHT
	clrf	GLCDDEVICEHEIGHT_H
;IF ST7735TABCOLOR = ST7735_BLACKTAB or ST7735TABCOLOR = ST7735_MINI160x80 or GLCD_TYPE = GLCD_TYPE_ST7735R_160_80 then
;SendData_ST7735( ST7735_MADCTL_RGB )
	clrf	ST7735SENDBYTE
	call	SENDDATA_ST7735
;else
;case LANDSCAPE_REV
	goto	SysSelectEnd2
SysSelect2Case3
	movlw	3
	subwf	GLCDROTATESTATE,W
	btfss	STATUS, Z
	goto	SysSelect2Case4
;IF ST7735TABCOLOR = ST7735_BLACKTAB or ST7735TABCOLOR = ST7735_MINI160x80 or GLCD_TYPE = GLCD_TYPE_ST7735R_160_80 then
;SendData_ST7735( ST7735_MADCTL_MV | ST7735_MADCTL_MY | ST7735_MADCTL_RGB )
	movlw	160
	movwf	ST7735SENDBYTE
	call	SENDDATA_ST7735
;else
;GLCDDeviceWidth = GLCD_HEIGHT - 1
	movlw	159
	movwf	GLCDDEVICEWIDTH
	clrf	GLCDDEVICEWIDTH_H
;GLCDDeviceHeight = GLCD_WIDTH - 1
	movlw	79
	movwf	GLCDDEVICEHEIGHT
	clrf	GLCDDEVICEHEIGHT_H
;case PORTRAIT
	goto	SysSelectEnd2
SysSelect2Case4
	movlw	4
	subwf	GLCDROTATESTATE,W
	btfss	STATUS, Z
	goto	SysSelect2Case5
;GLCDDeviceWidth = GLCD_WIDTH - 1
	movlw	79
	movwf	GLCDDEVICEWIDTH
	clrf	GLCDDEVICEWIDTH_H
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	159
	movwf	GLCDDEVICEHEIGHT
	clrf	GLCDDEVICEHEIGHT_H
;IF ST7735TABCOLOR = ST7735_BLACKTAB or ST7735TABCOLOR = ST7735_MINI160x80 or GLCD_TYPE = GLCD_TYPE_ST7735R_160_80 then
;SendData_ST7735( ST7735_MADCTL_MX | ST7735_MADCTL_MY | ST7735_MADCTL_RGB )
	movlw	192
	movwf	ST7735SENDBYTE
	call	SENDDATA_ST7735
;else
;case else
	goto	SysSelectEnd2
SysSelect2Case5
;GLCDDeviceWidth = GLCD_WIDTH - 1
	movlw	79
	movwf	GLCDDEVICEWIDTH
	clrf	GLCDDEVICEWIDTH_H
;GLCDDeviceHeight = GLCD_HEIGHT - 1
	movlw	159
	movwf	GLCDDEVICEHEIGHT
	clrf	GLCDDEVICEHEIGHT_H
;IF ST7735TABCOLOR = ST7735_BLACKTAB or ST7735TABCOLOR = ST7735_MINI160x80 or GLCD_TYPE = GLCD_TYPE_ST7735R_160_80 then
;SendData_ST7735( ST7735_MADCTL_MX | ST7735_MADCTL_MY | ST7735_MADCTL_RGB )
	movlw	192
	movwf	ST7735SENDBYTE
	call	SENDDATA_ST7735
;else
;end select
SysSelectEnd2
	return

;********************************************************************************

;Source: string.h (335)
FN_HEX
;Hex(0) = 2
	movlw	2
	banksel	SYSHEX_0
	movwf	SYSHEX_0
;Low nibble
;SysStringTemp = SysValTemp And 0x0F
	movlw	15
	banksel	SYSVALTEMP
	andwf	SYSVALTEMP,W
	movwf	SYSSTRINGTEMP
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
	sublw	9
	btfsc	STATUS, C
	goto	ENDIF32
	movlw	7
	addwf	SYSSTRINGTEMP,F
ENDIF32
;Hex(2) = SysStringTemp + 48
	movlw	48
	addwf	SYSSTRINGTEMP,W
	banksel	SYSHEX_2
	movwf	SYSHEX_2
;Get high nibble
;For SysStringTemp = 1 to 4
	banksel	SYSSTRINGTEMP
	clrf	SYSSTRINGTEMP
SysForLoop7
	incf	SYSSTRINGTEMP,F
;Rotate SysValTemp Right
	rrf	SYSVALTEMP,F
;Next
	movlw	4
	subwf	SYSSTRINGTEMP,W
	btfss	STATUS, C
	goto	SysForLoop7
SysForLoopEnd7
;SysStringTemp = SysValTemp And 0x0F
	movlw	15
	andwf	SYSVALTEMP,W
	movwf	SYSSTRINGTEMP
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
	sublw	9
	btfsc	STATUS, C
	goto	ENDIF34
	movlw	7
	addwf	SYSSTRINGTEMP,F
ENDIF34
;Hex(1) = SysStringTemp + 48
	movlw	48
	addwf	SYSSTRINGTEMP,W
	banksel	SYSHEX_1
	movwf	SYSHEX_1
	banksel	STATUS
	return

;********************************************************************************

;Source: hwi2c.h (441)
HI2CRECEIVE
;Enable receive
;Master_mode
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ELSE45_1
;if HI2CGetAck.0 = 1 then
	btfss	HI2CGETACK,0
	goto	ELSE47_1
;Acknowledge
;ACKDT = 0
	banksel	SSP1CON2
	bcf	SSP1CON2,ACKDT
;else
	goto	ENDIF47
ELSE47_1
;Not Acknowledge
;ACKDT = 1
	banksel	SSP1CON2
	bsf	SSP1CON2,ACKDT
;end if
ENDIF47
;RCEN = 1
	bsf	SSP1CON2,RCEN
;Slave mode
;Else
	goto	ENDIF45
ELSE45_1
;SET SSPSTAT.R_NOT_W ON
	banksel	SSP1STAT
	bsf	SSP1STAT,R_NOT_W
;End If
ENDIF45
;Clear Collisions
;SET SSPCON1.WCOL OFF
	bcf	SSP1CON1,WCOL
;SET SSPCON1.SSPOV Off
	bcf	SSP1CON1,SSPOV
;Wait for receive
;Wait Until SSPSTAT.BF = 1 AND SSPIF = 1
SysWaitLoop4
	clrf	SysByteTempX
	banksel	SSP1STAT
	btfsc	SSP1STAT,BF
	comf	SysByteTempX,F
	movf	SysByteTempX,W
	banksel	SYSTEMP1
	movwf	SysTemp1
	clrf	SysByteTempX
	banksel	PIR3
	btfsc	PIR3,SSP1IF
	comf	SysByteTempX,F
	banksel	SYSTEMP1
	movf	SysTemp1,W
	andwf	SysByteTempX,W
	movwf	SysTemp2
	btfss	SysTemp2,0
	goto	SysWaitLoop4
;I2CByte = SSPBUF
	banksel	SSP1BUF
	movf	SSP1BUF,W
	banksel	I2CBYTE
	movwf	I2CBYTE
;SSPIF = 0''Support for SSPIF
	banksel	PIR3
	bcf	PIR3,SSP1IF
;ACKEN = 1; Send ACK DATA now. ' bsf SSPCON2,ACKEN
	banksel	SSP1CON2
	bsf	SSP1CON2,ACKEN
;Clear flag - this is required
;SSPSTAT.BF = 0
	bcf	SSP1STAT,BF
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;Disable receive (Master_mode)
;Master_mode
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ELSE46_1
;Set SSPCON2.RCEN Off
	banksel	SSP1CON2
	bcf	SSP1CON2,RCEN
;Slave mode
;Else
	goto	ENDIF46
ELSE46_1
;SET SSPSTAT.R_NOT_W Off
	banksel	SSP1STAT
	bcf	SSP1STAT,R_NOT_W
;End If
ENDIF46
	banksel	STATUS
	return

;********************************************************************************

;Source: hwi2c.h (331)
HI2CRESTART
;asm showdebug  This method sets the registers and register bits to generate the I2C  RESTART signal
;this method sets the registers & register bits to generate the i2c restart signal
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ENDIF39
;Master_mode operational
;Set RSEN On
	banksel	SSP1CON2
	bsf	SSP1CON2,RSEN
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;End If
ENDIF39
	return

;********************************************************************************

;Source: hwi2c.h (413)
HI2CSEND
;asm showdebug  This method sets the registers and register bits to send I2C data
;this method sets the registers & register bits to send i2c data
RETRYHI2CSEND
;Clear WCOL
;SET SSPCON1.WCOL OFF
	banksel	SSP1CON1
	bcf	SSP1CON1,WCOL
;Load data to send
;SSPBUF = I2CByte
	banksel	I2CBYTE
	movf	I2CBYTE,W
	banksel	SSP1BUF
	movwf	SSP1BUF
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;if ACKSTAT =  1 then
	banksel	SSP1CON2
	btfss	SSP1CON2,ACKSTAT
	goto	ELSE41_1
;HI2CAckPollState = true
	movlw	255
	banksel	HI2CACKPOLLSTATE
	movwf	HI2CACKPOLLSTATE
;else
	goto	ENDIF41
ELSE41_1
;HI2CAckPollState = false
	banksel	HI2CACKPOLLSTATE
	clrf	HI2CACKPOLLSTATE
;end if
ENDIF41
;If SSPCON1.WCOL = On Then
	banksel	SSP1CON1
	btfss	SSP1CON1,WCOL
	goto	ENDIF42
;If HI2CCurrentMode <= 10 Then Goto RetryHI2CSend
	banksel	HI2CCURRENTMODE
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	RETRYHI2CSEND
;End If
ENDIF42
;Release clock (only needed by slave)
;If HI2CCurrentMode <= 10 Then Set SSPCON1.CKP On
	banksel	HI2CCURRENTMODE
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfss	STATUS, C
	goto	ENDIF43
	banksel	SSP1CON1
	bsf	SSP1CON1,CKP
ENDIF43
	banksel	STATUS
	return

;********************************************************************************

;Source: hwi2c.h (301)
HI2CSTART
;asm showdebug  This method sets the registers and register bits to generate the I2C  START signal
;this method sets the registers & register bits to generate the i2c start signal
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ELSE38_1
;Master_mode operational
;Set SEN On
	banksel	SSP1CON2
	bsf	SSP1CON2,SEN
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;for device with SEN_SSP1CON2 and therefore devices including the 18FxxK40
;Else
	goto	ENDIF38
ELSE38_1
;Slave mode operational
;Wait Until SSPSTAT.S = On
SysWaitLoop1
	banksel	SSP1STAT
	btfss	SSP1STAT,S
	goto	SysWaitLoop1
;End If
ENDIF38
	banksel	STATUS
	return

;********************************************************************************

;Source: hwi2c.h (348)
HI2CSTOP
;Master_mode
;If HI2CCurrentMode > 10 Then
	movf	HI2CCURRENTMODE,W
	sublw	10
	btfsc	STATUS, C
	goto	ELSE40_1
;set SSPIE OFF; disable SSP interrupt, tested by Anobium but not implemented.
;wait while R_NOT_W = 1   'wait for completion of activities
SysWaitLoop2
	banksel	SSP1STAT
	btfsc	SSP1STAT,R_NOT_W
	goto	SysWaitLoop2
;Set SSPCON2.PEN On
	bsf	SSP1CON2,PEN
;HI2CWaitMSSP
	banksel	STATUS
	call	HI2CWAITMSSP
;Slave mode
;Else
	goto	ENDIF40
ELSE40_1
;Wait Until SSPSTAT.P = On
SysWaitLoop3
	banksel	SSP1STAT
	btfss	SSP1STAT,P
	goto	SysWaitLoop3
;End If
ENDIF40
	banksel	STATUS
	return

;********************************************************************************

;Source: hwi2c.h (499)
HI2CWAITMSSP
;HI2CWaitMSSPTimeout = 0
	clrf	HI2CWAITMSSPTIMEOUT
HI2CWAITMSSPWAIT
;HI2CWaitMSSPTimeout++
	banksel	HI2CWAITMSSPTIMEOUT
	incf	HI2CWAITMSSPTIMEOUT,F
;if HI2CWaitMSSPTimeout < 255 then
	movlw	255
	subwf	HI2CWAITMSSPTIMEOUT,W
	btfsc	STATUS, C
	goto	ENDIF48
;'Support for SSP1IF
;if SSP1IF = 0 then goto HI2CWaitMSSPWait
	banksel	PIR3
	btfss	PIR3,SSP1IF
	goto	HI2CWAITMSSPWAIT
;SSP1IF = 0
	bcf	PIR3,SSP1IF
;exit Sub
	banksel	STATUS
	return
;'Support for SSPIF
;if SSPIF = 0 then goto HI2CWaitMSSPWait
	banksel	PIR3
	btfss	PIR3,SSP1IF
	goto	HI2CWAITMSSPWAIT
;SSPIF = 0
	bcf	PIR3,SSP1IF
;exit Sub
	banksel	STATUS
	return
;end if
ENDIF48
	return

;********************************************************************************

;Source: glcd_st7735r.h (583)
PSET_ST7735R
;SetAddress_ST7735 ST7735_COLUMN, GLCDX, GLCDX
	movlw	42
	movwf	ST7735ADDRESSTYPE
	movf	GLCDX,W
	movwf	ST7735START
	clrf	ST7735START_H
	movf	GLCDX,W
	movwf	ST7735END
	clrf	ST7735END_H
	call	SETADDRESS_ST7735
;SetAddress_ST7735 ST7735_ROW, GLCDY, GLCDY
	movlw	43
	movwf	ST7735ADDRESSTYPE
	movf	GLCDY,W
	movwf	ST7735START
	clrf	ST7735START_H
	movf	GLCDY,W
	movwf	ST7735END
	clrf	ST7735END_H
	call	SETADDRESS_ST7735
;SendCommand_ST7735 0x2C
	movlw	44
	movwf	ST7735SENDBYTE
	call	SENDCOMMAND_ST7735
;SendWord_ST7735 GLCDColour
	movf	GLCDCOLOUR,W
	movwf	ST7735SENDWORD
	movf	GLCDCOLOUR_H,W
	movwf	ST7735SENDWORD_H
	goto	SENDWORD_ST7735

;********************************************************************************

;Source: ADAFruit_mini_colorTFT_joystick_featherwing.h (47)
FN_READMINITFT
;Button B problem occurs AFTER it prints "Button B" on the GLCD.  i.e. it happens after the HI2C WRITES or READ. The LCD still works properly.
;HI2CStart
	call	HI2CSTART
;HI2CSend MINITFT_WRITEADDR
	movlw	188
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_MODULE_BASE_ADDRESS_GPIO
	movlw	1
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_DIRCLR_GPIO
	movlw	3
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_4_DEFAULT ;Writing a 1 to any bit in this register sets the direction of the corresponding pin to INPUT.
	movlw	211
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_3_DEFAULT ;Writing zeros to this register has no effect.
	movlw	195
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_2_DEFAULT ;PA15:PA08 = 1100 1111 - Pin 12 to Pin 7
	movlw	207
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_1_DEFAULT ;PA07:PA02 = 1101 1100 - Pin 6 to Pin 1   LSB
	movlw	220
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CStop
;HI2CStart
	call	HI2CSTART
;HI2CSend MINITFT_WRITEADDR
	movlw	188
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_MODULE_BASE_ADDRESS_GPIO ;Writing a 1 to any bit in this register enables the internal pullup or pulldown on the corresponding pin. The pull direction
	movlw	1
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_PULLENSET_GPIO ;(up/down) is determined by the GPIO (output) value - if the corresponding GPIO register bit is low, its a pulldown. High, its a pullup.
	movlw	11
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_4_DEFAULT
	movlw	211
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_3_DEFAULT
	movlw	195
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_2_DEFAULT
	movlw	207
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_1_DEFAULT
	movlw	220
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CStop
;HI2CStart
	call	HI2CSTART
;HI2CSend MINITFT_WRITEADDR
	movlw	188
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_MODULE_BASE_ADDRESS_GPIO ;Writing a 1 to any bit in this register writes the corresponding pin HIGH.  Writing zeros to this register has no effect.
	movlw	1
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_SET_FUNCTIONREG
	movlw	5
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_4_DEFAULT
	movlw	211
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_3_DEFAULT
	movlw	195
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_2_DEFAULT
	movlw	207
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_REGISTER_1_DEFAULT
	movlw	220
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CStop
;HI2CStart
	call	HI2CSTART
;HI2CSend MINITFT_WRITEADDR
	movlw	188
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_MODULE_BASE_ADDRESS_GPIO
	movlw	1
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CSend MINITFT_GPIO_BULK ;Reading this register reads all pins on PORTA of the seesaw device.
	movlw	4
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CRestart
	call	HI2CRESTART
;HI2CSend MINITFT_READADDR
	movlw	189
	movwf	I2CBYTE
	call	HI2CSEND
;HI2CReceive [BYTE]ReadMiniTFT_E         ;Bits [31:24] MSB      Seems like BIG_ENDIAN is being used - Data sheet says LITTLE_ENDIAN ????????????
	movlw	1
	movwf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	READMINITFT_E
;HI2CReceive [BYTE]ReadMiniTFT_U         ;Bits [23:16]         I show bit order as if it is BIG ENDIAN
	movlw	1
	movwf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	READMINITFT_U
;HI2CReceive [BYTE]ReadMiniTFT_H         ;Bits [15:8]
	movlw	1
	movwf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	READMINITFT_H
;HI2CReceive [BYTE]ReadMiniTFT, Nack     ;Bits [7:0] LSB
	clrf	HI2CGETACK
	call	HI2CRECEIVE
	movf	I2CBYTE,W
	movwf	READMINITFT
;HI2CStop
	goto	HI2CSTOP

;********************************************************************************

;Source: glcd_st7735.h (925)
SENDCOMMAND_ST7735
;set ST7735_CS OFF;
	bcf	LATB,2
;set ST7735_DC OFF;
	bcf	LATC,2
;repeat 8
	movlw	8
	movwf	SysRepeatTemp1
SysRepeatLoop1
;if ST7735SendByte.7 = ON  then
	btfss	ST7735SENDBYTE,7
	goto	ELSE51_1
;set ST7735_DO ON;
	bsf	LATB,5
;else
	goto	ENDIF51
ELSE51_1
;set ST7735_DO OFF;
	bcf	LATB,5
;end if
ENDIF51
;SET GLCD_SCK OFF;
	bcf	LATB,3
;rotate ST7735SendByte left
	rlf	ST7735SENDBYTE,F
;set GLCD_SCK ON;
	bsf	LATB,3
;end repeat
	decfsz	SysRepeatTemp1,F
	goto	SysRepeatLoop1
SysRepeatLoopEnd1
;set ST7735_CS ON;
	bsf	LATB,2
	return

;********************************************************************************

;Source: glcd_st7735.h (959)
SENDDATA_ST7735
;set ST7735_CS OFF;
	bcf	LATB,2
;set ST7735_DC ON;
	bsf	LATC,2
;repeat 8
	movlw	8
	movwf	SysRepeatTemp4
SysRepeatLoop4
;if ST7735SendByte.7 = ON then
	btfss	ST7735SENDBYTE,7
	goto	ELSE59_1
;set ST7735_DO ON;
	bsf	LATB,5
;else
	goto	ENDIF59
ELSE59_1
;set ST7735_DO OFF;
	bcf	LATB,5
;end if
ENDIF59
;SET GLCD_SCK OFF;
	bcf	LATB,3
;rotate ST7735SendByte left
	rlf	ST7735SENDBYTE,F
;set GLCD_SCK ON;
	bsf	LATB,3
;end Repeat
	decfsz	SysRepeatTemp4,F
	goto	SysRepeatLoop4
SysRepeatLoopEnd4
;set ST7735_CS ON;
	bsf	LATB,2
	return

;********************************************************************************

;Source: glcd_st7735.h (993)
SENDWORD_ST7735
;set ST7735_CS OFF;
	bcf	LATB,2
;set ST7735_DC ON;
	bsf	LATC,2
;repeat 16
	movlw	16
	movwf	SysRepeatTemp2
SysRepeatLoop2
;if ST7735SendWord.15 = ON then
	btfss	ST7735SENDWORD_H,7
	goto	ELSE52_1
;set ST7735_DO ON;
	bsf	LATB,5
;else
	goto	ENDIF52
ELSE52_1
;set ST7735_DO OFF;
	bcf	LATB,5
;end if
ENDIF52
;SET GLCD_SCK OFF;
	bcf	LATB,3
;rotate ST7735SendWord left
	rlf	ST7735SENDWORD,F
	rlf	ST7735SENDWORD_H,F
;set GLCD_SCK ON;
	bsf	LATB,3
;end repeat
	decfsz	SysRepeatTemp2,F
	goto	SysRepeatLoop2
SysRepeatLoopEnd2
;set ST7735_CS ON;
	bsf	LATB,2
	return

;********************************************************************************

;Source: glcd_st7735.h (1029)
SETADDRESS_ST7735
;if GLCDRotateState.0 = 0 then
	btfsc	GLCDROTATESTATE,0
	goto	ELSE53_1
;if ST7735AddressType = ST7735_COLUMN then
	movlw	42
	subwf	ST7735ADDRESSTYPE,W
	btfss	STATUS, Z
	goto	ENDIF54
;ST7735Start += ST7735_XSTART
	movlw	24
	addwf	ST7735START,F
	movlw	0
	addwfc	ST7735START_H,F
;ST7735End   += ST7735_XSTART
	movlw	24
	addwf	ST7735END,F
	movlw	0
	addwfc	ST7735END_H,F
;end if
ENDIF54
;if ST7735AddressType = ST7735_ROW then
	movlw	43
	subwf	ST7735ADDRESSTYPE,W
	btfss	STATUS, Z
	goto	ENDIF55
;ST7735Start += ST7735_YSTART
	movlw	0
	addwf	ST7735START,F
	movlw	0
	addwfc	ST7735START_H,F
;ST7735End   += ST7735_YSTART
	movlw	0
	addwf	ST7735END,F
	movlw	0
	addwfc	ST7735END_H,F
;end if
ENDIF55
;else
	goto	ENDIF53
ELSE53_1
;if ST7735AddressType = ST7735_COLUMN then
	movlw	42
	subwf	ST7735ADDRESSTYPE,W
	btfss	STATUS, Z
	goto	ENDIF56
;ST7735Start += ST7735_YSTART
	movlw	0
	addwf	ST7735START,F
	movlw	0
	addwfc	ST7735START_H,F
;ST7735End   += ST7735_YSTART
	movlw	0
	addwf	ST7735END,F
	movlw	0
	addwfc	ST7735END_H,F
;end if
ENDIF56
;if ST7735AddressType = ST7735_ROW then
	movlw	43
	subwf	ST7735ADDRESSTYPE,W
	btfss	STATUS, Z
	goto	ENDIF57
;ST7735Start += ST7735_XSTART
	movlw	24
	addwf	ST7735START,F
	movlw	0
	addwfc	ST7735START_H,F
;ST7735End   += ST7735_XSTART
	movlw	24
	addwf	ST7735END,F
	movlw	0
	addwfc	ST7735END_H,F
;end if
ENDIF57
;end if
ENDIF53
;SendCommand_ST7735 ST7735AddressType
	movf	ST7735ADDRESSTYPE,W
	movwf	ST7735SENDBYTE
	call	SENDCOMMAND_ST7735
;SendData_ST7735 ST7735Start_H
	movf	ST7735START_H,W
	movwf	ST7735SENDBYTE
	call	SENDDATA_ST7735
;SendData_ST7735 ST7735Start
	movf	ST7735START,W
	movwf	ST7735SENDBYTE
	call	SENDDATA_ST7735
;SendData_ST7735 ST7735End_H
	movf	ST7735END_H,W
	movwf	ST7735SENDBYTE
	call	SENDDATA_ST7735
;SendData_ST7735 ST7735End
	movf	ST7735END,W
	movwf	ST7735SENDBYTE
	goto	SENDDATA_ST7735

;********************************************************************************

;Source: system.h (2702)
SYSCOMPEQUAL16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX
;Test low, exit if false
;movf SysWordTempA, W
	movf	SYSWORDTEMPA, W
;subwf SysWordTempB, W
	subwf	SYSWORDTEMPB, W
;btfss STATUS, Z
	btfss	STATUS, Z
;return
	return
;Test high, exit if false
;movf SysWordTempA_H, W
	movf	SYSWORDTEMPA_H, W
;subwf SysWordTempB_H, W
	subwf	SYSWORDTEMPB_H, W
;btfss STATUS, Z
	btfss	STATUS, Z
;return
	return
;comf SysByteTempX,F
	comf	SYSBYTETEMPX,F
	return

;********************************************************************************

;Source: system.h (2843)
SYSCOMPLESSTHAN
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX
;bsf STATUS, C
	bsf	STATUS, C
;movf SysByteTempB, W
	movf	SYSBYTETEMPB, W
;subwf SysByteTempA, W
	subwf	SYSBYTETEMPA, W
;btfss STATUS, C
	btfss	STATUS, C
;comf SysByteTempX,F
	comf	SYSBYTETEMPX,F
	return

;********************************************************************************

;Source: system.h (2873)
SYSCOMPLESSTHAN16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX
;Test High, exit if more
;movf SysWordTempA_H,W
	movf	SYSWORDTEMPA_H,W
;subwf SysWordTempB_H,W
	subwf	SYSWORDTEMPB_H,W
;btfss STATUS,C
	btfss	STATUS,C
;return
	return
;Test high, exit true if less
;movf SysWordTempB_H,W
	movf	SYSWORDTEMPB_H,W
;subwf SysWordTempA_H,W
	subwf	SYSWORDTEMPA_H,W
;btfss STATUS,C
	btfss	STATUS,C
;goto SCLT16True
	goto	SCLT16TRUE
;Test Low, exit if more or equal
;movf SysWordTempB,W
	movf	SYSWORDTEMPB,W
;subwf SysWordTempA,W
	subwf	SYSWORDTEMPA,W
;btfsc STATUS,C
	btfsc	STATUS,C
;return
	return
SCLT16TRUE
;comf SysByteTempX,F
	comf	SYSBYTETEMPX,F
	return

;********************************************************************************

;Source: system.h (2520)
SYSDIVSUB16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;dim SysDivMultA as word
;dim SysDivMultB as word
;dim SysDivMultX as word
;SysDivMultA = SysWordTempA
	movf	SYSWORDTEMPA,W
	movwf	SYSDIVMULTA
	movf	SYSWORDTEMPA_H,W
	movwf	SYSDIVMULTA_H
;SysDivMultB = SysWordTempB
	movf	SYSWORDTEMPB,W
	movwf	SYSDIVMULTB
	movf	SYSWORDTEMPB_H,W
	movwf	SYSDIVMULTB_H
;SysDivMultX = 0
	clrf	SYSDIVMULTX
	clrf	SYSDIVMULTX_H
;Avoid division by zero
;if SysDivMultB = 0 then
	movf	SYSDIVMULTB,W
	movwf	SysWORDTempA
	movf	SYSDIVMULTB_H,W
	movwf	SysWORDTempA_H
	clrf	SysWORDTempB
	clrf	SysWORDTempB_H
	call	SysCompEqual16
	btfss	SysByteTempX,0
	goto	ENDIF26
;SysWordTempA = 0
	clrf	SYSWORDTEMPA
	clrf	SYSWORDTEMPA_H
;exit sub
	return
;end if
ENDIF26
;Main calc routine
;SysDivLoop = 16
	movlw	16
	movwf	SYSDIVLOOP
SYSDIV16START
;set C off
	bcf	STATUS,C
;Rotate SysDivMultA Left
	rlf	SYSDIVMULTA,F
	rlf	SYSDIVMULTA_H,F
;Rotate SysDivMultX Left
	rlf	SYSDIVMULTX,F
	rlf	SYSDIVMULTX_H,F
;SysDivMultX = SysDivMultX - SysDivMultB
	movf	SYSDIVMULTB,W
	subwf	SYSDIVMULTX,F
	movf	SYSDIVMULTB_H,W
	subwfb	SYSDIVMULTX_H,F
;Set SysDivMultA.0 On
	bsf	SYSDIVMULTA,0
;If C Off Then
	btfsc	STATUS,C
	goto	ENDIF27
;Set SysDivMultA.0 Off
	bcf	SYSDIVMULTA,0
;SysDivMultX = SysDivMultX + SysDivMultB
	movf	SYSDIVMULTB,W
	addwf	SYSDIVMULTX,F
	movf	SYSDIVMULTB_H,W
	addwfc	SYSDIVMULTX_H,F
;End If
ENDIF27
;decfsz SysDivLoop, F
	decfsz	SYSDIVLOOP, F
;goto SysDiv16Start
	goto	SYSDIV16START
;SysWordTempA = SysDivMultA
	movf	SYSDIVMULTA,W
	movwf	SYSWORDTEMPA
	movf	SYSDIVMULTA_H,W
	movwf	SYSWORDTEMPA_H
;SysWordTempX = SysDivMultX
	movf	SYSDIVMULTX,W
	movwf	SYSWORDTEMPX
	movf	SYSDIVMULTX_H,W
	movwf	SYSWORDTEMPX_H
	return

;********************************************************************************

;Source: system.h (2228)
SYSMULTSUB
;dim SysByteTempA as byte
;dim SysByteTempB as byte
;dim SysByteTempX as byte
;clrf SysByteTempX
	clrf	SYSBYTETEMPX
MUL8LOOP
;movf SysByteTempA, W
	movf	SYSBYTETEMPA, W
;btfsc SysByteTempB, 0
	btfsc	SYSBYTETEMPB, 0
;addwf SysByteTempX, F
	addwf	SYSBYTETEMPX, F
;bcf STATUS, C
	bcf	STATUS, C
;rrf SysByteTempB, F
	rrf	SYSBYTETEMPB, F
;bcf STATUS, C
	bcf	STATUS, C
;rlf SysByteTempA, F
	rlf	SYSBYTETEMPA, F
;movf SysByteTempB, F
	movf	SYSBYTETEMPB, F
;btfss STATUS, Z
	btfss	STATUS, Z
;goto MUL8LOOP
	goto	MUL8LOOP
	return

;********************************************************************************

;Source: system.h (2275)
SYSMULTSUB16
;dim SysWordTempA as word
;dim SysWordTempB as word
;dim SysWordTempX as word
;dim SysDivMultA as word
;dim SysDivMultB as word
;dim SysDivMultX as word
;SysDivMultA = SysWordTempA
	movf	SYSWORDTEMPA,W
	movwf	SYSDIVMULTA
	movf	SYSWORDTEMPA_H,W
	movwf	SYSDIVMULTA_H
;SysDivMultB = SysWordTempB
	movf	SYSWORDTEMPB,W
	movwf	SYSDIVMULTB
	movf	SYSWORDTEMPB_H,W
	movwf	SYSDIVMULTB_H
;SysDivMultX = 0
	clrf	SYSDIVMULTX
	clrf	SYSDIVMULTX_H
MUL16LOOP
;IF SysDivMultB.0 ON then SysDivMultX += SysDivMultA
	btfss	SYSDIVMULTB,0
	goto	ENDIF24
	movf	SYSDIVMULTA,W
	addwf	SYSDIVMULTX,F
	movf	SYSDIVMULTA_H,W
	addwfc	SYSDIVMULTX_H,F
ENDIF24
;set STATUS.C OFF
	bcf	STATUS,C
;rotate SysDivMultB right
	rrf	SYSDIVMULTB_H,F
	rrf	SYSDIVMULTB,F
;set STATUS.C off
	bcf	STATUS,C
;rotate SysDivMultA left
	rlf	SYSDIVMULTA,F
	rlf	SYSDIVMULTA_H,F
;if SysDivMultB > 0 then goto MUL16LOOP
	movf	SYSDIVMULTB,W
	movwf	SysWORDTempB
	movf	SYSDIVMULTB_H,W
	movwf	SysWORDTempB_H
	clrf	SysWORDTempA
	clrf	SysWORDTempA_H
	call	SysCompLessThan16
	btfsc	SysByteTempX,0
	goto	MUL16LOOP
;SysWordTempX = SysDivMultX
	movf	SYSDIVMULTX,W
	movwf	SYSWORDTEMPX
	movf	SYSDIVMULTX_H,W
	movwf	SYSWORDTEMPX_H
	return

;********************************************************************************

SysStringTables
	movf	SysStringA_H,W
	movwf	PCLATH
	movf	SysStringA,W
	incf	SysStringA,F
	btfsc	STATUS,Z
	incf	SysStringA_H,F
	movwf	PCL

StringTable1
	retlw	8
	retlw	66	;B
	retlw	117	;u
	retlw	116	;t
	retlw	116	;t
	retlw	111	;o
	retlw	110	;n
	retlw	32	; 
	retlw	65	;A


StringTable2
	retlw	8
	retlw	66	;B
	retlw	117	;u
	retlw	116	;t
	retlw	116	;t
	retlw	111	;o
	retlw	110	;n
	retlw	32	; 
	retlw	66	;B


StringTable3
	retlw	6
	retlw	83	;S
	retlw	101	;e
	retlw	108	;l
	retlw	101	;e
	retlw	99	;c
	retlw	116	;t


StringTable4
	retlw	4
	retlw	85	;U
	retlw	112	;p
	retlw	32	; 
	retlw	32	; 


StringTable5
	retlw	6
	retlw	76	;L
	retlw	101	;e
	retlw	102	;f
	retlw	116	;t
	retlw	32	; 
	retlw	32	; 


StringTable6
	retlw	4
	retlw	68	;D
	retlw	111	;o
	retlw	119	;w
	retlw	110	;n


StringTable7
	retlw	7
	retlw	82	;R
	retlw	105	;i
	retlw	103	;g
	retlw	104	;h
	retlw	116	;t
	retlw	32	; 
	retlw	32	; 


;********************************************************************************

;Start of program memory page 2
	ORG	4096
;Start of program memory page 3
	ORG	6144

 END
