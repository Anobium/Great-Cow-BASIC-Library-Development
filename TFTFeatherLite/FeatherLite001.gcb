#CHIP 16f18855,32
#OPTION Explicit

    'Generated by PIC PPS Tool for Great Cow Basic
    'PPS Tool version: 0.0.5.2
    'PinManager data: 09/02/2017
    '
    'Template comment at the start of the config file
    '
    #STARTUP InitPPS, 85

    Sub InitPPS

        'Module: EUSART
        'TX > RC0
        RC0PPS = 0x0010
        'RC0 > TX (bi-directional)
        TXPPS = 0x0008

        'Module: MSSP1
        'RC3 > SDA1
        SSP1DATPPS = 0x0013
        'SDA1 > RC3 (bi-directional)
        RC3PPS = 0x0015
        'SCL1 > RC4
        RC4PPS = 0x0014
        'RC4 > SCL1 (bi-directional)
        SSP1CLKPPS = 0x0014

    End Sub
    'Template comment at the end of the config file
    #DEFINE USART_BAUD_RATE 19200
    #DEFINE USART_TX_BLOCKING


      ' ----- Define Hardware settings for hwi2c
      ' Define I2C settings - CHANGE PORTS if required for your specific device.
      #DEFINE hi2c_BAUD_RATE 400
      #DEFINE hi2c_DATA PORTC.3
      #DEFINE hi2c_CLOCK PORTC.4
      'Initialise I2C Master
      'I2C pins need to be input for SSP2 module
      Dir hi2c_DATA In
      Dir hi2c_CLOCK In

      HI2CMode Master


    #include <glcd.h>
    #define GLCD_TYPE GLCD_TYPE_ST7735R_160_80
    ''''   #define ST7735R_HardwareSPI     ' remove comment out if you want to use software SPI.

    #define ST7735TABCOLOR ST7735_GREENTAB  ' can be ST7735_BLACKTAB, ST7735_GREENTAB or ST7735_REDTAB.  Each tab is a different ST7735 configuration.
                                      ' you may have to try all three - if you do not know what chipset you have.

    'Pin mappings for SPI
    #define GLCD_DC         portC.2              'Data/Command select
    #define GLCD_CS         portB.2              'CS Chip select
    #define GLCD_RESET      portB.1              'RESET
    #define GLCD_DO         portB.5              'SPI SDO (MOSI)
    #define GLCD_DI         portB.5              'SPI SDI (MISO)  assume bi-directional DO/DI
    #define GLCD_SCK        portB.3              'SPI SCK


    GLCDRotate ( Landscape )

    GLCDPrint (4, 0, "Great", TFT_YELLOW )
    GLCDForeground = TFT_GREEN
    GLCDPrintString (" Cow")
    GLCDForeground = TFT_WHITE
    GLCDPrintString ( " BASIC 2020" )
    Circle  80,40, 10
    FilledCircle  80,40, 9, TFT_RED




#define MiniTFT_WRITEADDR 188 ;0xBC
#define MiniTFT_READADDR 189 ;0xBD

#define Module_Base_Address_GPIO 1 ;GPIO = 1  Pg 21 of Seesaw Tutorial
#define GPIO_BULK 4 ;GPIO = 4 Reading this register reads all pins on PORTA of the seesaw device.

'Buttons
#define DirClr_GPIO 3 ;0x03 Pg 22 of Seesaw Tutorial - Writing a 1 to any bit in this register sets the direction of the corresponding pin to INPUT.
#define PullenSet_GPIO 11 ;0x0B Pg 23 of Seesaw Tutorial - Writing a 1 to any bit in this register enables the internal pullup or pulldown on the corresponding pin.
#define Set_FunctionReg 5 ;Writing a 1 to any bit in this register writes the corresponding pin HIGH. pg 22


#define Module_Base_Address_AD 9 ;AD = 9  Pg 24 of Seesaw Tutorial
#define Module_function_register_address_AD0 7 ;PA02_A0 AD  = 7
#define Module_function_register_address_AD1 8 ;PA03_A1 AD  = 8
dim FeatherWingRegister, oldFeatherWingRegister as long
dim Fourth_Byte as byte alias FeatherWingRegister_e
dim Third_Byte  as byte alias FeatherWingRegister_u
dim Button_ABS  as byte alias FeatherWingRegister_h
dim Button_XY   as byte alias FeatherWingRegister
dim ccount as byte

#Define FEATHERWING_BUTTON_A  Button_ABS.2


    Wait 2 s
    GLCDCLS
    ccount = 0


#DEFINE GLCD_OLED_FONT


    oldFeatherWingRegister = 0xffff

    box 0, 5, 158, 79

    filledbox 33,1,132,7, GLCDBackground

    GLCDPrint(35, 1, "ADAFRUIT MINI COLOR TFT", TFT_WHITE )
    GLCDPrint(30, 9,  "WITH JOYSTICK FEATHERWING", TFT_WHITE )

    GLCDPrint(4, 16, "Button A", TFT_RED )
    GLCDPrint(4, 24, "Button B", TFT_RED )
    GLCDPrint(4, 32, "Select", TFT_GREEN )
    GLCDPrint(4, 40, "Up  ", TFT_GREEN )
    GLCDPrint(4, 48, "Left  ", TFT_GREEN )
    GLCDPrint(4, 56, "Down", TFT_GREEN )
    GLCDPrint(4, 64, "Right  ", TFT_GREEN )


    DO

            'Button B problem occurs AFTER it prints "Button B" on the GLCD.  i.e. it happens after the HI2C WRITES or READ. The LCD still works properly.
        HI2CStart
            HI2CSend MiniTFT_WRITEADDR
            HI2CSend Module_Base_Address_GPIO
            HI2CSend DirClr_GPIO
            HI2CSend 211 ;Writing a 1 to any bit in this register sets the direction of the corresponding pin to INPUT.
            HI2CSend 195 ;Writing zeros to this register has no effect.
            HI2CSend 207 ;PA15:PA08 = 1100 1111 - Pin 12 to Pin 7
            HI2CSend 220 ;PA07:PA02 = 1101 1100 - Pin 6 to Pin 1   LSB
'        HI2CStop

        HI2CStart
            HI2CSend MiniTFT_WRITEADDR
            HI2CSend Module_Base_Address_GPIO ;Writing a 1 to any bit in this register enables the internal pullup or pulldown on the corresponding pin. The pull direction
            HI2CSend PullenSet_GPIO ;(up/down) is determined by the GPIO (output) value - if the corresponding GPIO register bit is low, its a pulldown. High, its a pullup.
            HI2CSend 211
            HI2CSend 195
            HI2CSend 207
            HI2CSend 220
'        HI2CStop

        HI2CStart
            HI2CSend MiniTFT_WRITEADDR
            HI2CSend Module_Base_Address_GPIO ;Writing a 1 to any bit in this register writes the corresponding pin HIGH.  Writing zeros to this register has no effect.
            HI2CSend Set_FunctionReg
            HI2CSend 211
            HI2CSend 195
            HI2CSend 207
            HI2CSend 220
'        HI2CStop

        HI2CStart
        HI2CSend MiniTFT_WRITEADDR
        HI2CSend Module_Base_Address_GPIO
        HI2CSend GPIO_BULK ;Reading this register reads all pins on PORTA of the seesaw device.
        HI2CRestart
        HI2CSend MiniTFT_READADDR
        HI2CReceive Fourth_Byte ;Bits [31:24] MSB      Seems like BIG_ENDIAN is being used - Data sheet says LITTLE_ENDIAN ????????????
        HI2CReceive Third_Byte ;Bits [23:16]         I show bit order as if it is BIG ENDIAN
        HI2CReceive Button_ABS ;Bits [15:8]
        HI2CReceive Button_XY, Nack ;Bits [7:0] LSB
        HI2CStop


        if [word]FeatherWingRegister <>  [word]oldFeatherWingRegister then

            GLCDPrint(100, 16, hex(FeatherWingRegister_E) )
            GLCDPrintString hex(FeatherWingRegister_U)
            GLCDPrintString hex(FeatherWingRegister_h)
            GLCDPrintString hex(FeatherWingRegister)

            GLCDPrint(100, 25, hex(oldFeatherWingRegister_E) )
            GLCDPrintString hex(oldFeatherWingRegister_U)
            GLCDPrintString hex(oldFeatherWingRegister_h)
            GLCDPrintString hex(oldFeatherWingRegister)

            'Button A
            GLCDLocateString 66, 3
            GLCDPrintString str(FEATHERWING_BUTTON_A)

            'Button B
            GLCDLocateString 66, 4
            GLCDPrintString str(Button_ABS.1)

            'Select
            GLCDLocateString 66, 5
            GLCDPrintString str(Button_ABS.3)

            'Up
            GLCDLocateString 66, 6
            GLCDPrintString str(Button_XY.2)

            GLCDLocateString 66, 7
            GLCDPrintString str(Button_XY.3)

            GLCDLocateString 66, 8
            GLCDPrintString str(Button_XY.4)

            GLCDLocateString 66, 9
            GLCDPrintString str(Button_XY.7)


            FilledBox 100,66, 130, 78, GLCDBackground
            GLCDPrint 100,66, ccount
            ccount++

            oldFeatherWingRegister = [word]FeatherWingRegister

        End if


    LOOP
